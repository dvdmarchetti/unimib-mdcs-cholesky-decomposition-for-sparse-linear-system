\documentclass[12pt]{article}
\usepackage{blindtext}
\usepackage{imakeidx}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{enumitem}


\title{%
  MCS 2020 \\
  \large Algebra lineare numerica \\
  Sistemi lineari con matrici sparse simmetriche e defite positive}

\date{21/05/2020}
\author{Silva Edoardo 816560, Zhigui Bryan 816335, Marchetti Davide 815990}

\begin{document}
\maketitle
%\makeindex

\section*{Abstract}

Lo scopo di questo progetto è di studiare l'implementazione in ambienti
di programmazione open source del metodo di Choleski per la risoluzione sistemi lineari
per matrici sparse, simmetriche e defite positive, e di confrontarli con l'implementazione
di MATLAB.\newline
Il confronto avverrà in termini di tempo, accuratezza, impiego della memoria e anche facilità d'uso tramite
documentazione sia in ambiente Linux che Windows, eseguendo il codice con imput \textbf{SuiteSparse Matrix Collection}
che colleziona matrici sparse derivanti daapplicazioni di problemi reali.\newline
\section{Librerie}
	\subsection{descrizione libreria matlab}
	
	\textbf{cholesky.matlab chol:} libreria ufficiale MatLab per la fattorizzazione di Choleski.	\newline
	 \large{Syntax:}
	\begin{itemize}
 		 \item \textbf{R = chol(A, [triangle]):} Fattorizza la matrice simmetrica A definita positiva in una matrice triangolare R tale che A=R'*R;\newline R di default è ''upper'', ma può essere specificata diversamente con R = chol(A, `lower'). se A è asimmetrica, allora chol la tratta come se fosse simmetrica prendendo solo la triangolare superiore.
 		 \item{\textbf{[R,flag] = chol():} ritorna in output `flag' che indica se A è simmetrica e definita positiva. Inoltre calcola R, ma non ritorna errori; flag = 0 --> la fattorizzazione è avvenuta con successo, altrimenti indica il punto di fallimento.}
 		 \item{\textbf{[R,flag,P] = chol(S, [outputForm]):}  come [R,flag] = chol(), ma ritornaanche la matrice di permutazione P,ossia il preordinamento della matrice S obtained by amd. se flag=0, allora  Sè simmetrica e definita positiva e R è la matrice triangolare superiore R'*R = P'*S*P.
 		 outputForm è specificabile per ritornare P come matrice o vettore (`matrix' di default).}
	\end{itemize}
		\subsubsection{manutentore}
		
			Rilasciata con l'aggiornamento R2013a MatLab.
		
	\subsection{descrizione libreria c++}
	
		\large{\textbf{Eigen:}} Libreria con l'obbiattivo di essere leggera offrendo supporto alle operazioni su matrici e vettori tramite overloads delle operazioni aritmetiche comuni C++ quali +, -, *, o tramite funzioni speciali come dot(), cross(), ... . \newline
		Per la classe Matrix (matrici e vettori), gli operatori sono stati sovrascritti per supportare solo operazioni di algebra lineare.\newline
		
		\begin{itemize}
			\item \textbf{Eigen::loadMarket(A, filename):} Carica matrice Eigen::SparseMatrix<Type> A dal file `filename'. \textbf{[OLD non più supportato]}
			\item \textbf{Eigen::VectorXd::Ones(A.rows()):} dichiara matrice di dimensioni fissate (prese dalle dimensioni della matrice A), package `VectorXd' usato per le operazioni su matrici dinamiche di double.
			\item \textbf{Eigen::SimplicialCholesky<SpMat> chol(A):} Pacchetto creato per gestire matrici di grandi dimensioni con pochi elementi diversi da 0. Implementa uno schema di rappresentazione e gestione dei valori diversi da 0 con uso di poca memoria e alte prestazioni.\newline Il metodo chol(A) implementa la fattorizzazione di Cholesky della matrice A.
   			\item \textbf{Eigen::VectorXd x\_ap = chol.solve(b):} Applicazione del risolutore iterativo per risolvere la fattorizzazione.
		\end{itemize}
		\subsubsection{manutentore}
			Eigen è un software gratis, open-source sotto la licenza Mozilla Public License 2.0 (MPL2:  simple weak copyleft license) dalla versione 3.1.1. \newline Precedentemente sotto GNU Lesser General Public License. 
			
	
\section{HardWare}	
	\begin{itemize}
		\item \textbf{CPU}: AMD Ryzen 5 3600, Core/Threads = 6/12, cache = 6x32+6x32+6x512+6x16M, clock = 3.6GHz*0.1GHz bus
		\item \textbf{RAM}: Crucial DDR4-3003 2*8 (16GB), 3.8GHz
		\item \textbf{HDD}: WDC 1TB HDD
		\item \textbf{GPU}: Sapphire RX 580 Pulse, 8GB VRam
	\end{itemize}
	\subsection{Windows}
	\begin{itemize}
		\item \textbf{HDD}: Samsung 850 EVO 250GB SSD
	\end{itemize}
		\subsubsection{Tempo}
			Si nota che, all'incremento delle dimensioni della matrice di input, non si rileva un incremento lineare ne costante in termini di tempo, e non si rilevano differenze eccessive tra le librerie MatLab e C++ (seppure Matlab abbia tempo meno ''disperso'' della controparte).
		\begin{figure}[h!]
			 \centering
  			\input{windows_solve.png}
 		\end{figure}
		\subsubsection{Errore relativo}
		Si nota che,sia su c++ che con la libreria MatLab, si ha un errore comparabile/quasi uguale per entrambi i metodi(leggermente migliore rispetto Linux),  e che dopo un massimo ed un minimo nelle matrici più piccole, l'errore si stabilizza intorno a $10^{-11}$, indipendentemente dalle dimensioni delle matrici che il programma riesce a caricare.
		\begin{figure}[h!]
			 \centering
  			%\includegraphics[width=\linewidth]{./Plots/windows\_error.png}
 		\end{figure}
		\subsubsection{Memoria}
				Si nota che la libreria c++ occupa meno memoria rispetto a quella di MatLab, e che la memoria occupata non scala linearmente (facendo presumere sia più un fattore di elementi contenuti nelle matrici sparse che di dimensioni?).
		\begin{figure}[h!]
			 \centering
  			%\includegraphics[width=\linewidth]{./Plots/windows\_memory.png}
 		\end{figure}
	\subsection{Linux}
	\begin{itemize}
		\item \textbf{HDD}: Sabrent 256GB NVMe
	\end{itemize}
		\subsubsection{Tempo}
		Si nota che, all'incremento delle dimensioni della matrice di input, non si rileva un incremento lineare ne costante in termini di tempo (in un punto anche decremento), e non si rilevano differenze eccessive tra le librerie MatLab e C++ (seppure Matlab abbia tempo meno ''disperso'' della controparte).
		\begin{figure}[h!]
			 \centering
  			%\includegraphics[width=\linewidth]{./Plots/unix\_solve.png}
 		\end{figure}
		\subsubsection{Errore relativo}
					Si nota che,sia su c++ che con la libreria MatLab, si ha un errore comparabile/quasi uguale per entrambi i metodi, e che dopo un massimo ed un minimo nelle matrici più piccole, l'errore si stabilizza intorno a $10^{-11}$, indipendentemente dalle dimensioni delle matrici che il programma riesce a caricare.
		\begin{figure}[h!]
			 \centering
  			%\includegraphics[width=\linewidth]{./Plots/unix\_error.png}
 		\end{figure}
		\subsubsection{Memoria}
						Si nota che la libreria c++ occupa meno memoria rispetto a quella di MatLab sulle matrici più grandi(paragonabile ai risultati windows), e che la memoria occupata non scala linearmente (facendo presumere sia più un fattore di elementi contenuti nelle matrici sparse che di dimensioni?).
		\begin{figure}[h!]
			 \centering
  			%\includegraphics[width=\linewidth]{./Plots/unix\_memory.png}
 		\end{figure}
\section{Conclusioni}
	Matlab non riesce a caricare tutte le matrici che la libreria eigen;
%results.html%
\section{Code}


\end{document}