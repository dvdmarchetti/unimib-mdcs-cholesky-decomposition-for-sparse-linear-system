<html>
<head>
<style type="text/css">
h1              { background-color: #808080; padding: 0.2em; }
h2              { background-color: #B0B0B0; padding: 0.2em; }
h3              { background-color: #E0E0E0; padding: 0.2em; }
.inlineheader   { background-color: #E8E8E8; padding: 0.1em; font-weight:bold; }
.pagecontent    { font-family: Arial; font-size: 10pt; }

a               { color:#000077; text-decoration: underline; }
a:visited       { color:#000077; text-decoration: underline;}
a:hover         { color:#000077; text-decoration: underline; }

a.toc           { color:#000077; text-decoration: none; }
a.toc:visited   { color:#000077; text-decoration: none;}
a.toc:hover     { color:#000077; text-decoration: underline; }

a.nav           { color:#000077; font-weight:bold; text-decoration: none; }
a.nav:visited   { color:#000077; font-weight:bold; text-decoration: none;}
a.nav:hover     { color:#000077; font-weight:bold; text-decoration: underline; }

.cond           { color:blue; }
.const          { color:#222222; }
.func           { color:#111111; }
</style>
</head>
<body>
<div class=pagecontent>
<a name='main_contents'></a><h1 style='background-color: #8080E8;'>Contents</h1><p style='margin-left: 0; margin-top: 0; margin-bottom: 0;'><a href='#int_main'>Introduction</a></p>
<p style='margin-left: 0; margin-top: 0; margin-bottom: 0;'><a href='#gs_main'>Getting started with ALGLIB</a></p>
<p style='margin-left: 0; margin-top: 0; margin-bottom: 0;'><a href='#_faq'>FAQ</a></p>
<p style='margin-left: 0; margin-top: 0; margin-bottom: 0;'><a href='#ap_description'>AP library description</a></p>
<p style='margin-left: 0; margin-top: 0; margin-bottom: 0;'><a href='#amp_description'>AMP library description</a></p>
<p style='margin-left: 0; margin-top: 0; margin-bottom: 0;'><a href='#alglib_main'>ALGLIB reference manual</a></p>


<a name='int_main'></a><h1>Introduction</h1>

<h3>Sections</h3>
<ul>
<li><a href='#int_license'>ALGLIB license</a></li>
<li><a href='#int_doc_license'>Documentation license</a></li>
<li><a href='#gs_guide'>Reference Manual and User Guide</a></li>
<li><a href='#int_ack'>Acknowledgements</a></li>
</ul>


<a name='int_license'></a><h2>ALGLIB license</h2>

<p align=justify>
ALGLIB is a free software which is distributed under a GPL license - version 2 or (at your option) any later version. A copy of the GNU General Public License is available at <a href='http://www.fsf.org/licensing/licenses'>http://www.fsf.org/licensing/licenses</a>
</p>

<a name='int_doc_license'></a><h2>Documentation license</h2>

<div style='width: 640px; text-align: justify;'>
<p>
<U>This reference manual is licensed under BSD-like documentation license</U>:
</p>

<p>
Copyright 1994-2009 Sergey Bochkanov, ALGLIB Project. All rights reserved.
</p>

<p>
Redistribution and use of this document (ALGLIB Reference Manual) with or without modification, are permitted provided that such redistributions will retain the above copyright notice, this condition and the following disclaimer as the first (or last) lines of this file.
</p>

<p>
THIS DOCUMENTATION IS PROVIDED BY THE ALGLIB PROJECT "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE ALGLIB PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
</div>

<a name='gs_guide'></a><h2>Reference Manual and User Guide</h2>

<p align=justify>
ALGLIB Project provides two sources of information: ALGLIB Reference Manual (this document) and <a href="http://www.alglib.net/#book">ALGLIB User Guide</a>.
</p>

<p align=justify>
ALGLIB Reference Manual contains full description of all publicly accessible ALGLIB units accompanied with examples. Reference Manual is focused on the source code: it documents units, functions, structures and so on. If you want to know what unit <code>YYY</code> can do or what subroutines unit <code>ZZZ</code> contains Reference Manual is a place to go. Free software needs free documentation - that's why ALGLIB Reference Manual is licensed under BSD-like documentation license.
</p>

<p align=justify>
Additionally to the Reference Manual we provide you <a href="http://www.alglib.net/#book">User Guide</a>. User Guide is focused on more general questions: how fast ALGLIB is? how reliable it is? what are the strong and weak sides of the algorithms used? We aim to make ALGLIB User Guide an important source of information both about ALGLIB and numerical analysis algorithms in general. We want it to be a book about algorithms, not just software documentation. And we want it to be unique - that's why ALGLIB User Guide is distributed under less-permissive <a href="http://alglib.net.localhost/#guide_license">personal-use-only license</a>.
</p>

<a name='int_ack'></a><h2>Acknowledgements</h2>

<p align=justify>
ALGLIB was not possible without the contribution of next open source projects:
</p>

<ul>
<li><a href="http://www.netlib.org/lapack/">LAPACK</a></li>
<li><a href="http://www.moshier.net/">Cephes</a></li>
<li><a href="http://gmplib.org/">GNU MP</a></li>
<li><a href="http://www.mpfr.org/">MPFR</a></li>
</ul>



<a name='gs_main'></a><h1>Getting started with ALGLIB</h1>

<h3>Sections</h3>
<ul>
<li><a href='#gs_compiling'>Compiling ALGLIB</a></li>
<li><a href='#gs_testing'>Testing ALGLIB</a></li>
<li><a href='#gs_examples'>Executing examples</a></li>
</ul>




<a name='gs_compiling'></a><h2>Compiling ALGLIB</h2>

<p align=justify>
ALGLIB has a script-based compilation system. 'Script-based' means that you don't have to use <code>make</code> to compile ALGLIB. ALGLIB distribution contains Bash scripts and BAT-files (for Windows users) which will compile and test ALGLIB for you. Each script (<code>build</code>/<code>check</code>/...) is provided in two identical versions: as a Bash script and as a Windows batch file. The only difference is a set of compilers script supports.
</p>

<h3>Selecting/configuring your compiler</h3>

<p align=justify>
If you are *nix user, your environment is ready for the ALGLIB compilation. If you are Windows user, make sure that your compiler is in your PATH. MSVC users have to execute <code>vcvars32.bat</code>, <code>vcvarsx86_amd64.bat</code> or <code>vcvarsx86_ia64.bat</code> (depending on the hardware they use) in a shell window. These scripts are located in the MS SDK or MS Visual Studio directories.
</p>

<h3>Installing precompiled GMP/MPFR</h3>

<p align=justify>
Multiple precision version of ALGLIB rely on GMP/MPFR for numerical calculations.  It needs following static libraries copied in the <code>./mpfr</code> subdirectory of the ALGLIB root: <code>mpn</code>, <code>gmp</code>, <code>mpfr</code>. If you are *nix user, you must compile/copy GMP/MPFR static libraries yourself. If you are Windows user, you can use precompiled static libraries (they are installed by executing <code>precompiled_mpfr.bat</code>
</p>

<h3>Compiling ALGLIB</h3>

<p align=justify>
To compile ALGLIB you just need to <code>cd</code> into ALGLIB directory and to execute compilation script <code>./build</code> (or <code>build.bat</code> for Windows users). You must specify compiler name and you can specify additional compiler parameters. Multiple parameters must be enclosed in double quotes.
</p>

<table cellspacing=0 cellpadding=0>
<tr><td><code>./build</code></td><td>returns full list of compilers supported</td></tr>
<tr><td><code>./build gcc</code></td><td>compilation using GCC</td></tr>
<tr><td><code>build.bat msvc</code></td><td>compilation using MSVC</td></tr>
<tr><td><code>./build gcc -m32</code></td><td>one additonal parameter, no quotes</td></tr>
<tr><td><code>./build gcc "-m32 -O3"</code>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>multiple parameters in double quotes</td></tr>
</table>

<p align=justify>
Successful compilation will be completely silent. Compiler messages will be redirected to the <code>log.txt</code> in the ALGLIB root directory. In the case of the error you will get short message, but the most detailed info will be in a log file. After compilation is done, header files, <code>libmpalglib</code> static library and GMP/MPFR static libraries will be copied to the <code>out</code> folder of the ALGLIB root directory. ALGLIB is ready to use!
</p>

<a name='gs_testing'></a><h2>Testing ALGLIB</h2>

<p align=justify>
After ALGLIB compilation it can be tested:
</p>

<table cellspacing=0 cellpadding=0>
<tr><td><code>check.bat</code></td><td>short help</td></tr>
<tr><td><code>check.bat msvc all</code></td><td>all the library is tested</td></tr>
<tr><td><code>check.bat msvc all_silent</code></td><td>silent mode, only errors are echo'ed</td></tr>
<tr><td><code>./check gcc fft</code></td><td><code>fft.cpp</code> is tested</td></tr>
<tr><td><code>./check gcc fft "-m32 -O3"&nbsp;&nbsp;&nbsp;&nbsp;</code></td><td>custom parameters are passed</td></tr>
</table>

<a name='gs_examples'></a><h2>Executing examples</h2>

<p align=justify>
Some units are accompanied by examples which can be executed by you. Example sources are stored in <code>./examples</code> directory. They can be modified - feel free to experiment with them.
</p>

<table cellspacing=0 cellpadding=0>
<tr><td><code>example.bat list autogk</code></td><td>list examples for <code>autogk.cpp</code> unit</td></tr>
<tr><td><code>example.bat view autogk_smooth</code></td><td>view example source</td></tr>
<tr><td><code>./example gcc autogk_smooth</code></td><td>execute example</td></tr>
<tr><td><code>./example gcc autogk_smooth "-m32 -O3"&nbsp;&nbsp;&nbsp;&nbsp;</code></td><td>custom parameters are passed</td></tr>
</table>



<a name='_faq'></a><h1>FAQ</h1>

<h3>Sections</h3>
<ul>
<li><a href='#faq_stdafx'>What is the blank file <code>stdafx.h</code> here for?</a></li>
<li><a href='#faq_cpparrays2'>Why are round brackets used when addressing arrays, not square brackets?</a></li>
<li><a href='#faq_amp'>What is the AMP library?</a></li>
<li><a href='#faq_ap'>What is the AP library?</a></li>
<li><a href='#faq_rcomm'>Why do some algorithms (for instance, optimization methods) use reverse communication instead of function pointers, delegates and other means of my programming language?</a></li>
<li><a href='#faq_project'>What is ALGLIB aimed at?</a></li>
<li><a href='#faq_diff'>What is the difference between ALGLIB and other similar projects?</a></li>
<li><a href='#faq_algopascal'>What is AlgoPascal?</a></li>
</ul>


<a name='faq_stdafx'></a><h2>What is the blank file <code>stdafx.h</code> here for?</h2>

<p align=justify>
MSVC and some other compilers require the <code>#include &lt;stdafx.h&gt;</code> directive in the program code to manage precompiled headers, and create the stfafx.h file when generating a new project. However, some compilers (e.g. BCB) use other tools to manage precompiled headers. In this case the <code>#include &lt;stdafx.h&gt;</code> directive as such doesn't hinder their operation, however if the file with this name is absent, a compilation error occurs. The blank file called <code>stfafx.h</code> is created to avoid this error. If your development environment already created the file, leave it unchanged.
</p>

<a name='faq_cpparrays2'></a><h2>Why are round brackets used when addressing arrays, not square brackets?</h2>

<p align=justify>
Imagine you are addressing the a matrix element in the common notation: <code>a[x][y]</code> instead of <code>a(x,y)</code>. Actually there are two index operators called here instead of one. The first is indexing of a matrix by <code>x</code>, that returns a reference to a temporary structure that describes the matrix row. The second is indexing that temporary structure by <code>y</code>, which returns the reference to the needed element. Addressing through overloading the round brackets is much more effective, as no temporary structures are required.
</p>

<a name='faq_amp'></a><h2>What is the AMP library?</h2>

<p align=justify>
The AMP library (ALGLIB Multiple Precision) is an object oriented interface for the MPFR library, which is used by the ALGLIB programs.
</p>

<a name='faq_ap'></a><h2>What is the AP library?</h2>

<p align=justify>
AP library is a generic name for a set of libraries in several programming languages performing low-level tasks depending on specific programming languages. The AP library carries out tasks such as working with dynamic one- and multidimensional arrays in languages which do not support this data type, contains implementation of basic linear algebra algorithms, etc. The library is distributed as source codes under GPL 2+ license (GPL 2 or later). The library is attached to the ALGLIB package.
</p>

<a name='faq_rcomm'></a><h2>Why do some algorithms (for instance, optimization methods) use reverse communication instead of function pointers, delegates and other means of my programming language?</h2>

<p align=justify>
Optimization, integration and other similar methods are united by one common trait. They need to have a way of calculating the meaning of a function defined by the <I>user</I> at a point defined by the <I>method</I>.
</p>

<p align=justify>
The most convenient way of solving this problem is transferring a function pointer into the module. However bear in mind that ALGLIB package is written using pseudocode that is automatically translated into different programming languages. While each language has its own function pointer analog that is often different from other languages. When the ALGLIB pseudocode was developed, at some point is became clear that adding function pointers in it will be very complex as this feature is implemented differently in every language. This is why reverse communication was chosen as a different kind of solution.
</p>

<a name='faq_project'></a><h2>What is ALGLIB aimed at?</h2>

<p align=justify>
It is aimed at creating a convenient and efficient multilingual scientific software library.
</p>

<a name='faq_diff'></a><h2>What is the difference between ALGLIB and other similar projects?</h2>

<p align=justify>
The ALGLIB package:
</p>

<ul>
<li>is a multilingual project. The main feature of the project is that each algorithm is represented by programs in several languages and the language list is the same for every algorithm. This is the main advantage of the site before other similar collections - one algorithm, several languages, identical functionality in each language.</li>
<li>is focused on numerical analysis. There are some other directions in the project but numerical analysis is a priority.</li>
<li>is easy to use. To use the ALGLIB package you don't need to learn an unknown programming language, attach additional external libraries or work with an inconvenient interface to a code written in another programming language.</li>
</ul>

<a name='faq_algopascal'></a><h2>What is AlgoPascal?</h2>

<p align=justify>
AlgoPascal is a programming language, designed particularly for this project. The programs, written in this language, are processed by an automatic translator and translated into other programming languages. Almost all ALGLIB source is produced by the AlgoPascal translator.
</p>



<a name='ap_description'></a><h1>AP library description</h1>

<h3>Sections</h3>
<ul>
<li><a href='#ap_intro'>Introduction</a></li>
<li><a href='#ap_conditionals'>Conditionals</a></li>
<li><a href='#ap_constants'>Constants</a></li>
<li><a href='#ap_functions'>Functions</a></li>
<li><a href='#ap_aperror'><code>ap::ap_error</code> class</a></li>
<li><a href='#ap_arrays'>Array classes: basic concepts</a></li>
<li><a href='#ap_template_1'><code>ap::template_1d_array</code> class</a></li>
<li><a href='#ap_template_2'><code>ap::template_2d_array</code> class</a></li>
<li><a href='#ap_blas'>Basic subroutines of linear algebra</a></li>
<li><a href='#ap_complex'><code>ap::complex</code> class</a></li>
</ul>


<a name='ap_intro'></a><h2>Introduction</h2>

<p align=justify>
The document describes a C++ version of the AP library. The AP library for C++ contains a basic set of mathematical functions and classes needed to compile ALGLIB package. The library includes the only module <code>ap.cpp</code>.
</p>

<a name='ap_conditionals'></a><h2>Conditionals</h2>

<p align=justify>
<span class=cond>AP_ASSERT</span><br> This symbol enables checking of the array boundaries. If it is set by the &quot;define&quot; directive, then at each addressing to the dynamic array elements, the transferred index is verified for its correctness. In case of error the <code>ap::ap_error</code> exception is thrown. Checking the array boundaries makes the program more reliable, but slows down the program operation.
</p>

<p align=justify>
<span class=cond>NO_AP_ASSERT</span><br> This symbol disables checking of the array boundaries. If it is set by the &quot;define&quot; directive, then the index being outside the array boundaries is not checked when the dynamic array elements are addressed.
</p>

<a name='ap_constants'></a><h2>Constants</h2>

<p align=justify>
<span class=const>ap::machineepsilon</span><br>
The constant represents the accuracy of machine operations times some small number <i>r&gt;1</i>.
</p>

<p align=justify>
<span class=const>ap::maxrealnumber</span><br> The constant represents the highest value of the positive real number, which could be represented on this machine. The constant may be taken &quot;oversized&quot;, that is real boundary can be even higher.
</p>

<p align=justify>
<span class=const>ap::minrealnumber</span><br> The constant represents the lowest value of positive real number, which could be represented on this machine. The constant may be taken &quot;oversized&quot;, that is real boundary can be even lower.
</p>

<a name='ap_functions'></a><h2>Functions</h2>

<p align=justify>
<span class=func><b>int</b> ap::sign(<b>double</b> x)</span><br> Returns:<br> +1, if X&gt;0<br> -1, if X&lt;0<br> 0, if X=0
</p>

<p align=justify>
<span class=func><b>double</b> ap::randomreal()</span><br> Returns a random real number from half-interval [0,1).
</p>

<p align=justify>
<span class=func><b>int</b> ap::randominteger(<b>int</b> maxv) </span><br> Returns a random integer between 0 and maxv-1.
</p>

<p align=justify>
<span class=func><b>double</b> ap::round(<b>double</b> x)</span><br> Returns the nearest integer to x. If x is right in the middle between two integers, then the function result depends on the implementation.
</p>

<p align=justify>
<span class=func><b>double</b> ap::trunc(<b>double</b> x)</span><br> Truncates the fractional part of x.<br> trunc(1.3) =  1<br> trunc(-1.3)= -1
</p>

<p align=justify>
<span class=func><b>double</b> ap::pi()</span><br> Returns the constant  &pi;
</p>

<p align=justify>
<span class=func><b>double</b> ap::sqr(<b>double</b> x)</span><br> Returns x<sup>2</sup>.
</p>

<p align=justify>
<span class=func><b>double</b> ap::maxreal(<b>double</b> m1, <b>double</b> m2)</span><br> Returns the maximum of two real numbers.
</p>

<p align=justify>
<span class=func><b>double</b> ap::minreal(<b>double</b> m1, <b>double</b> m2)</span><br> Returns the minimum of two real numbers.
</p>

<p align=justify>
<span class=func><b>int</b> ap::maxint(<b>int</b> m1, <b>int</b> m2)</span><br> Returns the maximum of two integers.
</p>

<p align=justify>
<span class=func><b>int</b> ap::minint(<b>int</b> m1, <b>int</b> m2)</span><br> Returns the minimum of two integers.
</p>

<a name='ap_aperror'></a><h2><code>ap::ap_error</code> class</h2>

<p align=justify>
This is a class of exception which is thrown when different errors occur in the AP library, for example - if the array index is found incorrect when the array boundaries check is enabled. Class contains one member - <code>msg</code> field which may contain additional information in textual form.
</p>

<a name='ap_arrays'></a><h2>Array classes: basic concepts</h2>

<p align=justify>
First we will discuss general principles of working with array classes, then describe the classes and their methods.
</p>

<p align=justify>
Classes of the standard library allow operations with matrixes and vectors (one-dimensional and two-dimensional arrays) of variable size and with variable numeration of elements, that is, the array numeration can start at any number, end at any number and change dynamically. Because the array classes are templates, the arrays of the same dimension have the same set of member functions. And as the member functions of arrays with different dimensions differ only by the number of arguments, there is little difference between two-dimensional and one-dimenstional arrays. 
</p>

<p align=justify>
Working with an array starts with the array creation. You should distinguish the creation of array class instance and the memory allocation for the array.  When creating the class instance, you can use constructor without any parameters, that creates an empty array without any elements, or you can use copy and assignment constructors that copy one array into another.  In case the array is created by the default constructor, it contains no elements and an attempt to address them may cause the program failure. If, during the copy operation, the source array has no memory allocated for the array elements, destination array will contain no elements either. If the source array has memory allocated for its elements, destination array will allocate the same amount of memory and copy the elements there. That is, the copy operation yields into two independent arrays with indentical contents.
</p>

<p align=justify>
After an empty array has been created, you should allocate the memory for its elements, using the <code>setlength</code> method. The content of the created array elements is not defined. If the <code>setlength</code> method is called for the array with already allocated memory, then, after changing its parameters, the newly allocated elements also become undefined and the old content is destroyed.
</p>

<p align=justify>
To address the array elements, an overloaded <code>operator()</code> is used. That is, the code addressing the element of array <code>a</code> with indexes <code>a(i,j,k)</code> will look like <code>a(i,j,k)</code>. Below is given an example of factorial array calculation, illustrating the work with arrays. 
</p>

<pre>
integer_1d_array factarr(<b>int</b> n)
{
    integer_1d_array result;
    result.setbounds(1,n);
    result(1) = 1;
    <b>for</b>(<b>int</b> i=2; i&lt;=n; i++)
        result(i) = result(i-1)*i;
    <b>return</b> result;
}
</pre>

<a name='ap_template_1'></a><h2><code>ap::template_1d_array</code> class</h2>

<p align=justify>
This class is a template of dynamical one-dimensional array with variable upper and lower boundaries. Based on this class, the following classes are constructed:
</p>

<pre>
<b>typedef</b> template_1d_array&lt;<b>int</b>&gt;     integer_1d_array;
<b>typedef</b> template_1d_array&lt;<b>double</b>&gt;  real_1d_array;
<b>typedef</b> template_1d_array&lt;<b>bool</b>&gt;    boolean_1d_array;
<b>typedef</b> template_1d_array&lt;complex&gt; complex_1d_array;
</pre>

<h3>member functions</h3>

<p align=justify>
<span class=func>template_1d_array()</span><br> Constructor. Creates an empty array.
</p>

<p align=justify>
<span class=func>~template_1d_array()</span><br> Destructor. Frees memory, which had been allocated for the array.
</p>

<p align=justify>
<span class=func>template_1d_array(<b>const</b> template_1d_array &amp;rhs)</span><br> Copy constructor. Allocates the separate storage and copies source array content there.
</p>

<p align=justify>
<span class=func><b>const</b> template_1d_array&amp; <b>operator=</b>(<b>const</b> template_1d_array &amp;rhs)</span><br> Assignment constructor. Deletes destination array content, frees allocated memory, then allocates a separate storage and copies source array content there.
</p>

<p align=justify>
<span class=func>T&amp; operator()(<b>int</b> i)</span><br> Addressing the <i>i</i>-th array element.
</p>

<p align=justify>
<span class=func><b>void</b> setbounds(<b>int</b> iLow, <b>int</b> iHigh)</span><br> Memory allocation for the array.  Deletes the array content, frees allocated memory, then allocates a separate storage for iHigh-iLow+1 elements.<br> The elements numeration in the new array starts from  <code>iLow</code> and ends at <code>iHigh</code>. The content of the new array is not defined.
</p>

<p align=justify>
<span class=func><b>void</b> setlength(<B>int</B> iLen)</span><br> Memory allocation for the array.  Deletes the array content, frees allocated memory, then allocates a separate storage for <code>iLen</code> elements.<br> The elements numeration in the new array starts from zero. The content of the new array is not defined.
</p>

<p align=justify>
<span class=func><b>void</b> setcontent(<b>int</b> iLow, <b>int</b> iHigh, <b>const</b> T *pContent)</span><br> The method is similar to the <code>setbounds()</code> method, but after allocating a memory for a destination array it copies the content of <code>pContent[]</code> there.
</p>

<p align=justify>
<span class=func>T* getcontent()</span><br>
<span class=func><B>const</B> T* getcontent() <B>const</B></span><br>
Returns pointer to the array. The data pointed by the returned pointer can be changed, and the array content will be changed as well. 
</p>

<p align=justify>
<span class=func><b>int</b> getlowbound()<br><b>int</b> gethighbound()</span><br> Get lower and upper boundaries.
</p>

<p align=justify>
<span class=func>raw_vector&lt;T&gt; getvector(<b>int</b> iStart, <b>int</b> iEnd)</span><br> The method is used by the basic subroutines of linear algebra to get access to the internal memory of the array. The method returns an object, holding the pointer to a vector part (starting from the element with <code>iStart</code> index value and finishing with <code>iEnd</code> index value). If iEnd&lt;iStart, then an empty vector is considered to be set.
</p>

<p align=justify>
<span class=func>const_raw_vector&lt;T&gt; getvector(<b>int</b> iStart, <b>int</b> iEnd) <b>const</b></span><br> The method is used by the basic subroutines of linear algebra to get access to the internal memory of the array in the read only mode. The method returns an object, holding the pointer to a vector part (starting from the element with <code>iStart</code> index value and finishing with <code>iEnd</code> index value). If iEnd&lt;iStart, then an empty vector is considered to be set.
</p>

<a name='ap_template_2'></a><h2><code>ap::template_2d_array</code> class</h2>

<p align=justify>
This class is a template of dynamical two-dimensional array with variable upper and lower boundaries. Based on this class, the following classes are constructed:
</p>

<pre>
<b>typedef</b> template_2d_array&lt;<b>int</b>&gt;     integer_2d_array;
<b>typedef</b> template_2d_array&lt;<b>double</b>&gt;  real_2d_array;
<b>typedef</b> template_2d_array&lt;<b>bool</b>&gt;    boolean_2d_array;
<b>typedef</b> template_2d_array&lt;complex&gt; complex_2d_array;
</pre>

<h3>Class members</h3>

<p align=justify>
<span class=func>template_2d_array()</span><br> Constructor. Creates an empty array.
</p>

<p align=justify>
<span class=func>~template_2d_array()</span><br> Destructor. Frees memory, which had been allocated for the array.
</p>

<p align=justify>
<span class=func>template_2d_array(<b>const</b> template_2d_array &amp;rhs)</span><br> Copy constructor. Allocates the separate storage and copies source array content there.
</p>

<p align=justify>
<span class=func><b>const</b> template_2d_array&amp; <b>operator=</b>(<b>const</b> template_2d_array &amp;rhs)</span><br> Assignment constructor. Deletes destination array content, frees allocated memory, then allocates a separate storage and copies source array content there.
</p>

<p align=justify>
<span class=func>T&amp; operator()(<b>int</b> i1, <b>int</b> i2)</span><br>
<span class=func><B>const</B> T&amp; operator()(<b>int</b> i1, <b>int</b> i2) <B>const</B></span><br>
Array element access.
</p>

<p align=justify>
<span class=func><b>void</b> setbounds(<b>int</b> iLow1, <b>int</b> iHigh1, <b>int</b> iLow2, <b>int</b> iHigh2)</span><br>
Memory allocation for the array .    Deletes the array content, frees allocated memory, then allocates a separate storage for (iHigh1-iLow1+1)*(iHigh2-iLow2+1) elements.<br> The elements numeration in the new array starts from <code>iLow1</code> and finishes at <code>iHigh1</code> for the first dimension, and similarly for the second dimension.<br> The content of the new array is not defined.
</p>

<p align=justify>
<span class=func><b>void</b> setlength(<b>int</b> iLen1, <b>int</b> iLen2)</span><br>
Same as <code>setbounds</code>. but make zero-based array allocation.
</p>

<p align=justify>
<span class=func><b>void</b> setcontent(<b>int</b> iLow1, <b>int</b> iHigh1, <b>int</b> iLow2, <b>int</b> iHigh2, <b>const</b> T *pContent)</span><br> The method is similar to the setbounds() method, but after allocating a memory for a destination array it copies the content of pContent[] there.<br> The pContent array contains two-dimensional array, written in line, that is, the first element is [iLow1, iLow2], then goes [iLow1, iLow2+1], and so on.<br>
</p>

<p align=justify>
<span class=func><b>int</b> getlowbound(<b>int</b> iBoundNum)<br><b>int</b> gethighbound(<b>int</b> iBoundNum)</span><br> Get lower and upper boundaries of one-dimensional array with number iBoundNum.
</p>

<p align=justify>
<span class=func>raw_vector<T> getcolumn(<b>int</b> iColumn, <b>int</b> iRowStart, <b>int</b> iRowEnd)<br> const_raw_vector<T> getcolumn(<b>int</b> iColumn, <b>int</b> iRowStart, <b>int</b> iRowEnd) <b>const</b><br></span> The methods are used by the basic subroutines of linear algebra to get access to the internal memory of the array. The methods return the object holding the pointer to the part of column iColumn (starting from the line iRowStart and finishing with the line iRowEnd). <br> The iColumn parameter must be the valid column number (that is be within the boundaries of the array). If iRowEnd&lt;iRowStart, then an empty column is considered to be set.
</p>

<p align=justify>
<span class=func>raw_vector<T> getrow(<b>int</b> iRow, <b>int</b> iColumnStart, <b>int</b> iColumnEnd)<br> const_raw_vector<T> getrow(<b>int</b> iRow, <b>int</b> iColumnStart, <b>int</b> iColumnEnd) <b>const</b><br></span> The methods are used by the basic subroutines of linear algebra to get access to the internal memory of the array. The methods return the object holding the pointer to the part of line iRow (starting from the column iColumnStart and finishing with the column iColumnEnd). <br> The iRow parameter must be the valid line number (that is be within the boundaries of the array). If iColumnEnd&lt;iColumnStart, then an empty line is considered to be set.
</p>

<p align=justify>
<span class=func><B>int</B> getstride() <B>const</B><br></span> Returns stride (in bytes), i.e. span between first elements of adjacent rows.
</p>

<a name='ap_blas'></a><h2>Basic subroutines of linear algebra</h2>

<p align=justify>
Basic subroutines of linear algebra included into the AP library are close by their functions to the Level 1 BLAS, allowing to perform the simplest operations with vectors and with the matrix lines and columns.
</p>

<h3>General and slow interface</h3>

<p align=justify>
Subroutines should be used in the following way. First you need to get an object of the  <code>raw_vector</code> type or  <code>const_raw_vector</code> type, pointing to the part of the matrix or array being processed using the methods <code>getcolumn</code>/<code>getrow</code> (for the matrix), or  <code>getvector</code> (for the array). The object holds the pointer for the line (or column) start, the number of elements in the processed line (column), and the interval between the two adjacent elements. When using a standard scheme for matrixes storage in the memory (that is, by lines), the interval between the elements of one line equals 1, and the interval between the adjacent elements of one column equals the number of columns. The received object is transferred as argument to the corresponding subroutine, which performs operations on the matrix part pointed by the internal object pointer.
</p>

<p align=justify>
Below is given the list of basic subroutines of linear algebra, available in the AP library.
</p>

<p align=justify>
<span class=func>template&lt;<b>class</b> T&gt; T vdotproduct(const_raw_vector&lt;T&gt; v1, const_raw_vector&lt;T&gt; v2)</span><br> The subroutine calculates the scalar product of transferred vectors.
</p>

<p align=justify>
<span class=func>template&lt;<b>class</b> T&gt; <b>void</b> vmove(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc)<br> template&lt;<b>class</b> T&gt; <b>void</b> vmoveneg(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc)<br> template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vmove(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc, T2 alpha)<br></span> This subroutine set is used to copy one vector content to another vector using different methods: simple copy, copy multiplied by -1, copy multiplied by a number.
</p>

<p align=justify>
<span class=func>template&lt;<b>class</b> T&gt; <b>void</b> vadd(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc)<br> template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vadd(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc, T2 alpha)<br></span> This subroutine set is used to add one vector to another using different methods: simple addition or addition multiplied by a number.
</p>

<p align=justify>
<span class=func>template&lt;<b>class</b> T&gt; <b>void</b> vsub(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc)<br> template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vsub(raw_vector&lt;T&gt; vdst, const_raw_vector&lt;T&gt; vsrc, T2 alpha)<br></span> This subroutine set is used to subtract one vector from another using different methods: simple subtraction or subtraction multiplied by a number.
</p>

<p align=justify>
<span class=func>template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vmul(raw_vector&lt;T&gt; vdst, T2 alpha)</span><br> Multiplies vector by a number and stores the result in the same place.
</p>

<h3>Alternative syntax (faster)</h3>

<p align=justify>
If both operands are vectors/rows with interval between the elements equals 1 and length equals N, alternative syntax can be used.
</p>

<p align=justify>
<span class=func>
template&lt;<b>class</b> T&gt; T vdotproduct(<b>const</b> T *v1, <b>const</b> T *v2, <b>int</b> N)<br>
template&lt;<b>class</b> T&gt; <b>void</b> vmove(T *vdst, <b>const</b> T *vsrc, <b>int</b> N)<br>
template&lt;<b>class</b> T&gt; <b>void</b> vmoveneg(T *vdst, <b>const</b> T *vsrc, <b>int</b> N)<br>
template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vmove(T *vdst, <b>const</b> T *vsrc, <b>int</b> N, T2 alpha)<br>
template&lt;<b>class</b> T&gt; <b>void</b> vadd(T *vdst, <b>const</b> T *vsrc, <b>int</b> N)<br>
template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vadd(T *vdst, <b>const</b> T *vsrc, <b>int</b> N, T2 alpha)<br>
template&lt;<b>class</b> T&gt; <b>void</b> vsub(T *vdst, <b>const</b> T *vsrc, <b>int</b> N)<br>
template&lt;<b>class</b> T, <b>class</b> T2&gt; <b>void</b> vsub(T *vdst, <b>const</b> T *vsrc, <b>int</b> N, T2 alpha)<br>
template&lt;<b>class</b> T, <b>class</b> T2> <b>void</b> vmul(T *vdst, <b>int</b> N, T2 alpha)
</span>
</p>

<a name='ap_complex'></a><h2><code>ap::complex</code> class</h2>

<p align=justify>
AP library includes the <code>ap::complex</code> class that allows operations with compex numbers. Access to real and imaginary parts of complex number is implemented through the public fields <code>x</code> and <code>y</code>. Arithmetical operations are supported, the same as with embedded data types, by overloading of operations: addition, subtraction, multiplication and division. Addition, subtraction and multiplication are performed by a usual way (i.e., according to their definition which can be found in any textdook in algebra), division is performed using so called &quot;safe&quot; algorithm that could never cause overflow when calculating intermediate results. The library also includes several functions performing elementary operations with complex numbers.
</p>

<p align=justify>
<span class=func><b>const</b> double abscomplex(<b>const</b> ap::complex &amp;z)</span><br>
Returns the modulus of complex number z. It should be noted that the modulus calculation is performed using so called &quot;safe&quot; algorithm, that could never cause overflow when calculating intermediate results.
</p>

<p align=justify>
<span class=func><b>const</b> ap::complex conj(<b>const</b> ap::complex &amp;z)</span><br>
Returns complex conjugate of z.
</p>

<p align=justify>
<span class=func><b>const</b> ap::complex csqr(<b>const</b> ap::complex &amp;z)</span><br>
Returns the square of z.
</p>


<a name='amp_description'></a><h1>AMP library description</h1>

<h3>Sections</h3>
<ul>
<li><a href='#amp_intro'>Introduction</a></li>
<li><a href='#amp_basics'>AMP basics</a></li>
<li><a href='#amp_exceptions'>Exception classes</a></li>
<li><a href='#amp_rec_st'><code>amp::mpfr_record</code> and <code>amp::mpfr_storage</code> classes</a></li>
<li><a href='#amp_ampf'><code>amp::ampf</code> class</a></li>
<li><a href='#amp_linalg'>Vectors, matrices and basic linear algebra operations</a></li>
<li><a href='#amp_campf'><code>amp::campf</code> class</a></li>
</ul>


<a name='amp_intro'></a><h2>Introduction</h2>

<p>
The AMP library (ALGLIB Multiple Precision) is an object oriented interface for the MPFR library. This interface was created as part of the ALGLIB project. In order to illustrate the reason why it was necessary to create yet another interface for MPFR, we should first give a brief introduction to the ALGLIB project.
</p>

<p>
The goal of the project is to create a numerical analysis library which provides programs in different programming languages for each algorithm. This goal is attained by using automatic translation. Algorithms are stored as a pseudocode which can then be translated into the required programming language. Pseudocode syntax allows automatic translation into the most popular programming languages (e.g. C++, C#, Pascal etc.). It should be noted that, in a number of cases, programs in pseudocode can be modified to use multiple precision arithmetic. For this purpose, the AMP library is used as an interface for MPFR substituting standard double precision data type.
</p>

<p>
Programs using AMP were originally implemented to work with a 64-bit accuracy. This fact has an impact on a library design. Because of this, the following features had appeared: compile time precision definition (in AMP accuracy is given by using the template class parameterization) and prohibition to operate with numbers of different precisions (e.g. addition of 256 bit and 512 bit numbers). These restrictions are necessary in order to use the library within the ALGLIB project.
</p>

<p>
It should be noted that although AMP was designed especially for the ALGLIB project, it could be useful as just an MPFR interface. Particularly, automatic garbage collection could be useful for a number of applications. It is this part of functionality that we are going to develop, because the ALGLIB part has already been developed accurately enough and doesn't need any extension.
</p>

<a name='amp_basics'></a><h2>AMP basics</h2>

<p>
<b>Real numbers</b>. MPFR (and, therefore, AMP) is almost compliant with IEE-754 which describes real number arithmetic implementation requirements. The following features are available: signed zeros, finite numbers, positive and negative infinites, NANs. Denormalized numbers are not supported.
</p>

<p>
<b>Operations and rounding</b>. MPFR supports four types of rounding: round towards plus infinity, round towards minus infinity, round to zero and round to the nearest representable value. AMP always uses the last one. Thus, all the real number operations are performed by using exact rounding. Special values (infinites or NaNs) appearing during the calculation don't cause exception generation and the calculation is continued under normal conditions. Operations with infinites and signed zeros are performed according to the rules of limits.
</p>

<p>
<b>Precision</b>. Real number precision is a number of bits in a floating-point mantissa, including the high-order one (non-zero bit). For example, if the precision of a given number is equal to 53, this number is of a standard <code>double</code> type. The AMP library allows to set any precision no less than 32 (which represents the <code>signed long</code> type) including numbers which are not powers of two. The restriction was added due to compatibility reasons: a number of mathematical programs suppose that we can set any integer value to the real variable without any loss of accuracy.
</p>

<p>
<b>Compile time precision definition</b>. The main feature of the AMP library is that class performing multiple precision real numbers operations is a template class with one parameter specifying precision of a stored value. Hence, the precision to perform the calculation with is known at the compile time (on template specialization) and could not be changed in run-time. This restriction was introduced knowingly. The reason is that the AMP library was designed to be used mainly within the ALGLIB project. In that case, the AMP library is used by the automatically translated programs. Automatically generated codes cannot work with dynamic precision real numbers due to the number of problems. For example, we can't say what precision ought to be used when some elements of the matrix have 128 bit precision and some have 256 bit. That's the reason why this restriction was introduced.
</p>

<p>
<b>Mixed precision operands</b>. There are several floating point types in C++: <code>float</code>, <code>double</code>, <code>long double</code>. At that, if operands have a different precision, it is usually performed by automatic casting from less to finer precision (e.g. sum of <code>float</code> and <code>double</code> is <code>double</code>). The AMP library does not allow automatic casting of operands with different precision. For example, the sum of <code>amp::ampf&lt;128&gt;</code> and <code>amp::ampf&lt;144&gt;</code> will cause compilation errors because it is required to cast operand types. It is partly defined by C++ restrictions (which could be overcome), and partly by the developer's conviction that in numerical analysis such functionality is very seldom required.
</p>

<p>
<b>Garbage collection</b>. Since in MPFR the memory for real numbers is allocated dynamically, real number initialization takes a great deal of time comparatively. In order to increase performance, the AMP library doesn't free used memory, but puts needless variables into the list. When it is necessary to create a new real number, it is taken from the list.
</p>

<p>
<b>No multithreading</b>. The AMP library doesn't support multithreading. The library can work in a multithreaded environment, but it can't be used by two or more threads simultaneously.
</p>

<a name='amp_exceptions'></a><h2>Exception classes</h2>

<p>
The AMP library includes the following exception classes:
</p>

<ol>
<li><code>amp::incorrectPrecision</code> - generated when the real number of an invalid precision is initialized (less than 32 or more than MPFR library limitations)</li>
<li><code>amp::invalidConversion</code> - generated when the real number to be rounded using <code>trunc</code>/<code>round</code>/<code>ceil</code>/<code>floor</code> doesn't fit in the <code>signed long</code> type</li>
<li><code>amp::internalError</code> - generated when an internal AMP library error occurs (it should not happen under normal conditions)</li>
</ol>

<a name='amp_rec_st'></a><h2><code>amp::mpfr_record</code> and <code>amp::mpfr_storage</code> classes</h2>

<p>
These classes are service classes. Although these classes are available to the programmer, he shouldn't use them, because they aren't intended to be used outside the AMP library.
</p>

<a name='amp_ampf'></a><h2><code>amp::ampf</code> class</h2>

<h3>Key Concepts</h3>

<p>
<code>amp::ampf class</code> is a template class incapsulating real numbers in MPFR library format. Class implements memory allocation, memory release and garbage collection. Arithmetic operations are overloaded. In most cases, code using this class is almost the same as code working with real numbers.
</p>

<h3>amp::ampf members</h3>

<pre>
<code>
    <b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;
    <b>class</b> ampf
    {
    <b>public</b>:
        ~ampf();

        ampf ();        
        ampf (<b>long double</b> v);
        ampf (<b>double</b> v);
        ampf (<b>float</b> v);
        ampf (<b>signed long</b> v);
        ampf (<b>unsigned long</b> v);
        ampf (<b>signed int</b> v);
        ampf (<b>unsigned int</b> v);
        ampf (<b>signed short</b> v);
        ampf (<b>unsigned short</b> v);
        ampf (<b>signed char</b> v);
        ampf (<b>unsigned char</b> v);
        ampf (<b>const</b> std::string &amp;s);
        ampf (<b>const char</b> *s);
        
        ampf(<b>const</b> ampf&amp; r);
        <b>template</b>&lt;<b>unsigned int</b> Precision2&gt;
        ampf(<b>const</b> ampf&lt;Precision2&gt;&amp; r);

        ampf&amp; <b>operator</b>= (<b>long double</b> v);
        ampf&amp; <b>operator</b>= (<b>double</b> v);
        ampf&amp; <b>operator</b>= (<b>float</b> v);
        ampf&amp; <b>operator</b>= (<b>signed long</b> v);
        ampf&amp; <b>operator</b>= (<b>unsigned long</b> v);
        ampf&amp; <b>operator</b>= (<b>signed int</b> v);
        ampf&amp; <b>operator</b>= (<b>unsigned int</b> v);
        ampf&amp; <b>operator</b>= (<b>signed short</b> v);
        ampf&amp; <b>operator</b>= (<b>unsigned short</b> v);
        ampf&amp; <b>operator</b>= (<b>signed char</b> v);
        ampf&amp; <b>operator</b>= (<b>unsigned char</b> v);
        ampf&amp; <b>operator</b>= (<b>const char</b> *s);
        ampf&amp; <b>operator</b>= (<b>const</b> std::string &amp;s);
        ampf&amp; <b>operator</b>= (<b>const</b> ampf&amp; r);
        <b>template</b>&lt;<b>unsigned int</b> Precision2&gt;
        ampf&amp; <b>operator</b>= (<b>const</b> ampf&lt;Precision2&gt;&amp; r);
        
        <b>template</b>&lt;<b>class</b> T&gt;
        ampf&amp; <b>operator</b>+=(<b>const</b> T&amp; v);
        <b>template</b>&lt;<b>class</b> T&gt;
        ampf&amp; <b>operator-</b>=(<b>const</b> T&amp; v);
        <b>template</b>&lt;class T&gt;
        ampf&amp; <b>operator</b>*=(<b>const</b> T&amp; v);
        <b>template</b>&lt;class T&gt;
        ampf&amp; <b>operator</b>/=(<b>const</b> T&amp; v);
        
        mpfr_srcptr getReadPtr() <b>const</b>;
        mpfr_ptr getWritePtr();
        
        <b>bool</b> isFiniteNumber() <b>const</b>;
        <b>bool</b> isPositiveNumber() <b>const</b>;
        <b>bool</b> isZero() <b>const</b>;
        <b>bool</b> isNegativeNumber() <b>const</b>;
        <b>const</b> ampf getUlpOf();

        <b>double</b> toDouble() <b>const</b>;
        std::string toHex() <b>const</b>;
        std::string toDec() <b>const</b>;
        
        <b>static const</b> ampf getUlpOf(<b>const</b> ampf &amp;x);
        <b>static const</b> ampf getUlp();
        <b>static const</b> ampf getUlp256();
        <b>static const</b> ampf getUlp512();
        <b>static const</b> ampf getMaxNumber();
        <b>static const</b> ampf getMinNumber();
        <b>static const</b> ampf getAlgoPascalEpsilon();
        <b>static const</b> ampf getAlgoPascalMaxNumber();
        <b>static const</b> ampf getAlgoPascalMinNumber();
        <b>static const</b> ampf getRandom();
    };
</code>
</pre>

<h3>Variable Declaration and Initialization</h3>

<p>
<code>amp::ampf</code> is a template class having one parameter which specifies the precision of a real number. Thus, it is necessary to determine what degree of precision is required before using this class. A number of constructors are defined for class initialization. They can take instance of the same class, integer numbers, standard real numbers (float, double, long double) and strings as the input. Strings can have fractional ("12.34") or exponential form, at that the mantissa could be decimal or hexadecimal (see MPFR library description).
</p>

<p>
Example:
</p>

<pre>
<code>
    <b>int</b> i = 3;
    <b>double</b> d = 2.5;
    amp::ampf&lt;128&gt; a(i), b(d), c("2.33");
    a = "1.56E-3";
    b = a;
</code>
</pre>

<h3>Text Conversions</h3>

<p>
To convert a number into a text form, you can use member functions <code>toDec()</code> and <code>toHex()</code>. They return decimal and hexadecimal exponential representation of a number (at that, the hexadecimal conversion is performed faster than the decimal one, therefore if performance is critical it is better to use the hexadecimal conversion). You can't set the format of the result: all significant digits of the number are output.
</p>

<p>
Example:
</p>

<pre>
<code>
    amp::ampf&lt;128&gt; a;
    a = "11";
    printf("%s\n", amp::sqrt(a).toDec().c_str());
</code>
</pre>

<h3>Properties Checking</h3>

<p>
In order to check whether a real number is finite (as opposed to one of the special values), positive, zero or negative, use member function <code>isFiniteNumber()</code>, <code>isPositiveNumber()</code>, <code>isZero()</code>, <code>isNegativeNumber()</code>.
</p>

<h3>Information Functions</h3>

<p>
A number of functions were designed to get information about data type properties:
</p>

<ul>
<li>member function <code>getUlpOf()</code> returns a value of the ULP, Unit-in-Last-Place, of the given <code>x</code>. This value is similar to machine precision. Static function <code>getUlpOf()</code> has the same functionality.</li>
<li>static function <code>getUlp()</code> is equivalent to <code>amp::ampf&lt;Precision&gt;::getUlpOf(1)</code></li>
<li>static function <code>getMaxNumber()</code> returns the biggest representable (using this data type) positive number</li>
<li>static function <code>getMinNumber()</code> returns the smallest representable (using this data type) positive number</li>
<li>functions <code>getAlgoPascalEpsilon()</code>, <code>getAlgoPascalMaxNumber()</code>, <code>getAlgoPascalMinNumber()</code> are similar to the above-mentioned ones, but they return values with safety margin. These functions are used by the ALGLIB project programs.</li>
</ul>

<h3>Access to the <code>mpfr_t</code> Pointer</h3>

<p>
The <code>getReadPtr()</code> and <code>getWritePtr()</code> functions provide access to mpfr_t pointer. The <code>getReadPtr()</code> function allows to get a read-only pointer, which can be passed into an MPFR library function as an argument. The <code>getWritePtr()</code> function allows to get a writable pointer, which can be passed into an MPFR library function as a place to store the result in.
</p>

<p>
It should be noted that the AMP library uses copy-on-write technique, i.e. pointer which has been received by <code>getReadPtr()</code> could be common to several objects. Thus, such a pointer must not be used in operations which can change its contents.
</p>

<p>
A pointer which has been received by <code>getWritePtr()</code> can be used in operations which can change its contents, but these operations should not change the precision of a pointer contents. You should take into account that due to its using copy-on-write technique, the pointer which has been received by <code>getWritePtr()</code> could differ from the pointer which had previously been received by <code>getReadPtr()</code>.
</p>

<h3>Random Numbers Generation</h3>

<p>
In order to generate random numbers from [0, 1), use the static function <code>getRandom()</code>. At first, the call function initializes a random number generator using system time.
</p>

<h3>Arithmetic Operations</h3>

<p>
<code>amp::ampf</code> class overloads comparison, addition, subtraction, multiplication and division operations. The result is rounded by using exact rounding. Two objects of <code>amp::ampf</code> class with the same precision could be the operands. It is acceptable to use objects of <code>amp::ampf</code> class and variables of standard data types. You can also use two objects of <code>amp::ampf</code> class with different precision as operands, but one of them should be casted to precision of another one.
</p>

<p>
Example:
</p>

<pre>
<code>
    amp::ampf&lt;128&gt; a(3), b(4), c(99);
    amp::ampf&lt;256&gt; d(1);

    a = b+c;          <i>//</i>
    b = c+2.3;        <i>// acceptable  expressions</i>
    c = (2*a-5)/b;    <i>//</i>

    a = b+d;          <i>// compile time error -</i>
                      <i>// arguments of a different type</i>

    a = b + amp::ampf&lt;128&gt;(d); <i>// this is the right way</i>

    a = d;            <i>// this is also acceptable</i>
</code>
</pre>

<h3>Mathematical functions</h3>

<p>
All functions described here are members of the <code>amp</code> namespace. Thus, when you call, for example, the <code>sqr</code> function, you should write <code>amp::sqr</code>. Unless otherwise specified, the result is rounded up by using exact rounding.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; sqr(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Returns the square of <code>x</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> <b>int</b> sign(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Returns:<br>
+1, if X&gt;0<br>
-1, if X&lt;0<br>
0, if X=0
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; abs(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Returns the absolute value of <code>x</code>.
</p>


<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; maximum(<b>const</b> ampf&lt;Precision&gt; &amp;x, <b>const</b> ampf&lt;Precision&gt; &amp;y)<br>
</span>
Returns the maximum of two integers.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; minimum(<b>const</b> ampf&lt;Precision&gt; &amp;x, <b>const</b> ampf&lt;Precision&gt; &amp;y)<br>
</span>
Returns the minimum of two real numbers.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; sqrt(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Returns the square root of <code>x</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> <b>signed</b> <b>long</b> trunc(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Rounds towards zero. Throws <code>amp::invalidConversion</code> if result doesn't fit in the in the <code>signed long</code> type.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; frac(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Returns  <code>x-trunc(x)</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> <b>signed</b> <b>long</b> floor(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Rounds towards minus infinity. Throws <code>amp::invalidConversion</code> if result doesn't fit in the in the <code>signed long</code> type.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> <b>signed</b> <b>long</b> ceil(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Rounds towards plus infinity. Throws <code>amp::invalidConversion</code> if result doesn't fit in the in the <code>signed long</code> type.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> <b>signed</b> <b>long</b> round(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Rounds towards nearest integer, rounding halfway cases away from zero. Throws <code>amp::invalidConversion</code> if result doesn't fit in the in the <code>signed long</code> type.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; frexp2(<b>const</b> ampf&lt;Precision&gt; &amp;x, mp_exp_t *exponent)<br>
</span>
Splits a number into mantissa and exponent.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; ldexp2(<b>const</b> ampf&lt;Precision&gt; &amp;x, mp_exp_t exponent)<br>
</span>
Calculates x*2<sup>exponent</sup>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; pi()<br>
</span>
Returns <code>Pi</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; halfpi()<br>
</span>
Returns <code>0.5*Pi</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; twopi()<br>
</span>
Returns <code>2*Pi</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; sin(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the sine of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; cos(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the cosine of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; tan(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the tangent of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; asin(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the arcsine of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; acos(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the arccosine of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; atan(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the arctangent of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; atan2(<b>const</b> ampf&lt;Precision&gt; &amp;y, <b>con</b>st ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the arc tangent of y/x. It produces correct results even when the resulting angle is near pi/2 or -pi/2 (x near 0).
</p>
    
<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; log(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the natural logarithm of x.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; log2(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the binary logarithm of x.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; log10(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the base 10 logarithm of x.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; exp(<b>const</b> ampf&lt;Precision&gt; &amp;_x)<br>
</span>
Calculates the exponential e to the x.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; sinh(<b>const</b> ampf&lt;Precision&gt; &amp;x)<br>
</span>
Calculates the hyperbolic sine of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; cosh(<b>const</b> ampf&lt;Precision&gt; &amp;_x)<br>
</span>
Calculates the hyperbolic cosine of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; tanh(<b>const</b> ampf&lt;Precision&gt; &amp;_x)<br>
</span>
Calculates the hyperbolic tangent of a value.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; pow(<b>const</b> ampf&lt;Precision&gt; &amp;x, <b>const</b> ampf&lt;Precision&gt; &amp;y)<br>
</span>
Calculates x to the power of y.
</p>

<a name='amp_linalg'></a><h2>Vectors, matrices and basic linear algebra operations</h2>

<h3>Introduction</h3>

<p>
The AP library, part of the ALGLIB project, includes vector and matrix template classes as well as subroutines performing basic linear algebra operations (Level 1 BLAS). Since the AP library implements matrix classes using templates, you can use these classes when working with matrices of multiple precision numbers. Therefore, the AMP library doesn't include vector and matrix classes.
Basic linear algebra operations are also implemented by using templates in the AP library, but AMP includes its own classes specially designed to work with multiple precision numbers. The AMP library subroutines are optimized to reduce memory manager loading, thus it is better to use these subroutines when performing vector operations over multiple precision numbers.
</p>

<h3>Description</h3>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
ampf&lt;Precision&gt; vDotProduct(ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; v1, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; v2)<br>
</span>
The subroutine calculates the scalar product of two vectors. For more information about <code>ap::const_raw_vector</code> see <a href="#ap_blas">description of AP library</a>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>void</b> vMove(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc)<br>
</span>
This function copies <code>vSrc</code> vector to <code>vDst</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>void</b> vMoveNeg(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc)<br>
</span>
This function copies <code>-vSrc</code> vector to <code>vDst</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision, <b>class</b> T2&gt;<br>
<b>void</b> vMove(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc, T2 alpha)<br>
</span>
This function copies <code>alpha*vSrc</code> vector to <code>vDst</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>void</b> vAdd(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc)<br>
</span>
This function adds <code>vSrc</code> vector to <code>vDst</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision, <b>class</b> T2&gt;<br>
<b>void</b> vAdd(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc, T2 alpha)<br>
</span>
This function adds <code>alpha*vSrc</code> vector to <code>vDst</code>.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>void</b> vSub(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc)<br>
</span>
This function subtracts <code>vSrc</code> vector from <code>vDst</code> vector.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision, <b>class</b> T2&gt;<br>
<b>void</b> vSub(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, ap::const_raw_vector&lt; ampf&lt;Precision&gt; &gt; vSrc, T2 alpha)<br>
</span>
This function subtracts <code>alpha*vSrc</code> from <code>vDst</code> vector.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision, <b>class</b> T2&gt;<br>
<b>void</b> vMul(ap::raw_vector&lt; ampf&lt;Precision&gt; &gt; vDst, T2 alpha)<br>
</span>
This function multiplies vector by a number and stores the result in the same place
</p>

<a name='amp_campf'></a><h2><code>amp::campf</code> class</h2>

<h3>Key concepts</h3>

<p>
<code>amp::campf</code> class implements multiple precision complex number operations. Real and imaginary parts are stored in <code>x</code> and <code>y</code> fields of type <code>amp::ampf</code>. You can perform arithmetic and comparison operations over the objects of this class. Moreover, a number of standard mathematical functions are defined for this data type.
</p>

<h3><code>amp::ampf</code> members</h3>

<pre>
<code>
    <b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;
    class campf
    {
    public:
        campf():x(0),y(0);
        campf(<b>long</b> <b>double</b> v);
        campf(<b>double</b> v);
        campf(<b>float</b> v);
        campf(<b>signed</b> <b>long</b> v);
        campf(<b>unsigned</b> <b>long</b> v);
        campf(<b>signed</b> <b>int</b> v);
        campf(<b>unsigned</b> <b>int</b> v);
        campf(<b>signed</b> <b>short</b> v);
        campf(<b>unsigned</b> <b>short</b> v);
        campf(<b>signed</b> <b>char</b> v);
        campf(<b>unsigned</b> <b>char</b> v);
        campf(<b>const</b> ampf&lt;Precision&gt; &amp;_x);
        campf(<b>const</b> ampf&lt;Precision&gt; &amp;_x, <b>const</b> ampf&lt;Precision&gt; &amp;_y);
        campf(<b>const</b> campf &amp;z):x(z.x),y(z.y);
        <b>template</b>&lt;<b>unsigned</b> <b>int</b> Prec2&gt;
        campf(<b>const</b> campf&lt;Prec2&gt; &amp;z);

        campf&amp; <b>operator</b>= (<b>long double</b> v);
        campf&amp; <b>operator</b>= (<b>double</b> v);
        campf&amp; <b>operator</b>= (<b>float</b> v);
        campf&amp; <b>operator</b>= (<b>signed long</b> v);
        campf&amp; <b>operator</b>= (<b>unsigned long</b> v);
        campf&amp; <b>operator</b>= (<b>signed int</b> v);
        campf&amp; <b>operator</b>= (<b>unsigned int</b> v);
        campf&amp; <b>operator</b>= (<b>signed short</b> v);
        campf&amp; <b>operator</b>= (<b>unsigned short</b> v);
        campf&amp; <b>operator</b>= (<b>signed char</b> v);
        campf&amp; <b>operator</b>= (<b>unsigned char</b> v);
        campf&amp; <b>operator</b>= (<b>const char</b> *s);
        campf&amp; <b>operator</b>= (<b>const</b> std::string &amp;s);
        campf&amp; <b>operator</b>= (<b>const</b> campf&amp; r);
        <b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision2&gt;
        campf&amp; <b>operator</b>= (<b>const</b> campf&lt;Precision2&gt;&amp; r);

        ampf&lt;Precision&gt; x, y;
    };
</code>
</pre>

<h3>Arithmetic Operations</h3>

<p>
<code>amp::campf</code> class overrides comparison, addition, subtraction, multiplication and division operations. Two objects of <code>amp::campf</code> class of the same precision could be the operands. It is acceptable to use objects of <code>amp::campf</code> and <code>amp::ampf</code> types and variables of standard data types as operands. You can also use <code>amp::campf</code> instances with different precision, but they should be casted.
</p>

<h3>Standard Functions</h3>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> ampf&lt;Precision&gt; abscomplex(<b>const</b> campf&lt;Precision&gt; &amp;z)<br>
</span>
Returns the modulus of complex number z. It should be noted that the modulus calculation is performed using so called "safe" algorithm, that could never cause overflow when calculating intermediate results.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> campf&lt;Precision&gt; conj(<b>const</b> campf&lt;Precision&gt; &amp;z)<br>
</span>
Returns complex conjugate of z.
</p>

<p>
<span class=func>
<b>template</b>&lt;<b>unsigned</b> <b>int</b> Precision&gt;<br>
<b>const</b> campf&lt;Precision&gt; csqr(<b>const</b> campf&lt;Precision&gt; &amp;z)<br>
</span>
Returns the square of z.
</p>

<a name='alglib_main'></a><h1>ALGLIB reference manual</h1>
<a name='alglib_packages'></a><h2>Packages and units</h2>
<table border=0 cellspacing=0>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>DiffEquations</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_odesolver' class=toc>odesolver</a></td><td width=15>&nbsp;</td><td>Ordinary differential equation solver</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>FastTransforms</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_conv' class=toc>conv</a></td><td width=15>&nbsp;</td><td>Fast real/complex convolution</td></tr>
<tr align=left valign=top><td><a href='#unit_corr' class=toc>corr</a></td><td width=15>&nbsp;</td><td>Fast real/complex cross-correlation</td></tr>
<tr align=left valign=top><td><a href='#unit_fft' class=toc>fft</a></td><td width=15>&nbsp;</td><td>Real/complex FFT</td></tr>
<tr align=left valign=top><td><a href='#unit_fht' class=toc>fht</a></td><td width=15>&nbsp;</td><td>Real Fast Hartley Transform</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Integration</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_autogk' class=toc>autogk</a></td><td width=15>&nbsp;</td><td>Adaptive 1-dimensional integration</td></tr>
<tr align=left valign=top><td><a href='#unit_gkq' class=toc>gkq</a></td><td width=15>&nbsp;</td><td>Gauss-Kronrod quadrature generator</td></tr>
<tr align=left valign=top><td><a href='#unit_gq' class=toc>gq</a></td><td width=15>&nbsp;</td><td>Gaussian quadrature generator</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Interpolation</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_idwint' class=toc>idwint</a></td><td width=15>&nbsp;</td><td>Inverse distance weighting: interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_lsfit' class=toc>lsfit</a></td><td width=15>&nbsp;</td><td>Linear and nonlinear least-squares solvers</td></tr>
<tr align=left valign=top><td><a href='#unit_polint' class=toc>polint</a></td><td width=15>&nbsp;</td><td>Polynomial interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_pspline' class=toc>pspline</a></td><td width=15>&nbsp;</td><td>Parametric spline interpolation</td></tr>
<tr align=left valign=top><td><a href='#unit_ratint' class=toc>ratint</a></td><td width=15>&nbsp;</td><td>Rational interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_spline1d' class=toc>spline1d</a></td><td width=15>&nbsp;</td><td>1D spline interpolation/fitting</td></tr>
<tr align=left valign=top><td><a href='#unit_spline2d' class=toc>spline2d</a></td><td width=15>&nbsp;</td><td>2D spline interpolation</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>LinAlg</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_ablas' class=toc>ablas</a></td><td width=15>&nbsp;</td><td>Level 2 and Level 3 BLAS operations</td></tr>
<tr align=left valign=top><td><a href='#unit_bdsvd' class=toc>bdsvd</a></td><td width=15>&nbsp;</td><td>Bidiagonal SVD</td></tr>
<tr align=left valign=top><td><a href='#unit_evd' class=toc>evd</a></td><td width=15>&nbsp;</td><td>Eigensolvers</td></tr>
<tr align=left valign=top><td><a href='#unit_inverseupdate' class=toc>inverseupdate</a></td><td width=15>&nbsp;</td><td>Sherman-Morrison update of the inverse matrix</td></tr>
<tr align=left valign=top><td><a href='#unit_ldlt' class=toc>ldlt</a></td><td width=15>&nbsp;</td><td>LDLT decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_matdet' class=toc>matdet</a></td><td width=15>&nbsp;</td><td>Determinant calculation</td></tr>
<tr align=left valign=top><td><a href='#unit_matgen' class=toc>matgen</a></td><td width=15>&nbsp;</td><td>Random matrix generation</td></tr>
<tr align=left valign=top><td><a href='#unit_matinv' class=toc>matinv</a></td><td width=15>&nbsp;</td><td>Matrix inverse</td></tr>
<tr align=left valign=top><td><a href='#unit_ortfac' class=toc>ortfac</a></td><td width=15>&nbsp;</td><td>Real/complex QR, LQ, bi(tri)diagonal, Hessenberg decompositions</td></tr>
<tr align=left valign=top><td><a href='#unit_rcond' class=toc>rcond</a></td><td width=15>&nbsp;</td><td>Condition number estimate</td></tr>
<tr align=left valign=top><td><a href='#unit_schur' class=toc>schur</a></td><td width=15>&nbsp;</td><td>Schur decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_sdet' class=toc>sdet</a></td><td width=15>&nbsp;</td><td>Determinant of a symmetric matrix</td></tr>
<tr align=left valign=top><td><a href='#unit_sinverse' class=toc>sinverse</a></td><td width=15>&nbsp;</td><td>Symmetric inversion</td></tr>
<tr align=left valign=top><td><a href='#unit_spdgevd' class=toc>spdgevd</a></td><td width=15>&nbsp;</td><td>Generalized symmetric eigensolver</td></tr>
<tr align=left valign=top><td><a href='#unit_srcond' class=toc>srcond</a></td><td width=15>&nbsp;</td><td>Condition number estimate for symmetric matrices</td></tr>
<tr align=left valign=top><td><a href='#unit_svd' class=toc>svd</a></td><td width=15>&nbsp;</td><td>Singular value decomposition</td></tr>
<tr align=left valign=top><td><a href='#unit_trfac' class=toc>trfac</a></td><td width=15>&nbsp;</td><td>LU and Cholesky decompositions</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Optimization</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_minasa' class=toc>minasa</a></td><td width=15>&nbsp;</td><td>ASA bound constrained optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_mincg' class=toc>mincg</a></td><td width=15>&nbsp;</td><td>Conjugate gradient optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minlbfgs' class=toc>minlbfgs</a></td><td width=15>&nbsp;</td><td>Limited memory BFGS optimizer</td></tr>
<tr align=left valign=top><td><a href='#unit_minlm' class=toc>minlm</a></td><td width=15>&nbsp;</td><td>Improved Levenberg-Marquardt optimizer</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
<tr align=left valign=top><td colspan=3 bgcolor=#E8E8E8><b><code>Solvers</code> package</b></td></tr>
<tr align=left valign=top><td><a href='#unit_densesolver' class=toc>densesolver</a></td><td width=15>&nbsp;</td><td>Dense linear system solver</td></tr>
<tr align=left valign=top><td><a href='#unit_ssolve' class=toc>ssolve</a></td><td width=15>&nbsp;</td><td>Symmetric dense linear system solver</td></tr>
<tr align=left valign=top><td colspan=2>&nbsp;</td></tr>
</table>
<a name=unit_ablas></a><h2><code>ablas</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_ablasblocksize' class=toc>ablasblocksize</a><br>
<a href='#sub_ablascomplexblocksize' class=toc>ablascomplexblocksize</a><br>
<a href='#sub_ablascomplexsplitlength' class=toc>ablascomplexsplitlength</a><br>
<a href='#sub_ablasmicroblocksize' class=toc>ablasmicroblocksize</a><br>
<a href='#sub_ablassplitlength' class=toc>ablassplitlength</a><br>
<a href='#sub_cmatrixcopy' class=toc>cmatrixcopy</a><br>
<a href='#sub_cmatrixgemm' class=toc>cmatrixgemm</a><br>
<a href='#sub_cmatrixlefttrsm' class=toc>cmatrixlefttrsm</a><br>
<a href='#sub_cmatrixmv' class=toc>cmatrixmv</a><br>
<a href='#sub_cmatrixrank1' class=toc>cmatrixrank1</a><br>
<a href='#sub_cmatrixrighttrsm' class=toc>cmatrixrighttrsm</a><br>
<a href='#sub_cmatrixsyrk' class=toc>cmatrixsyrk</a><br>
<a href='#sub_cmatrixtranspose' class=toc>cmatrixtranspose</a><br>
<a href='#sub_rmatrixcopy' class=toc>rmatrixcopy</a><br>
<a href='#sub_rmatrixgemm' class=toc>rmatrixgemm</a><br>
<a href='#sub_rmatrixlefttrsm' class=toc>rmatrixlefttrsm</a><br>
<a href='#sub_rmatrixmv' class=toc>rmatrixmv</a><br>
<a href='#sub_rmatrixrank1' class=toc>rmatrixrank1</a><br>
<a href='#sub_rmatrixrighttrsm' class=toc>rmatrixrighttrsm</a><br>
<a href='#sub_rmatrixsyrk' class=toc>rmatrixsyrk</a><br>
<a href='#sub_rmatrixtranspose' class=toc>rmatrixtranspose</a><br>
<a name='sub_ablasblocksize'></a><h3><code>ablasblocksize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns block size - subdivision size where  cache-oblivious  soubroutines
switch to the optimized kernel.

INPUT PARAMETERS
    A   -   real matrix, is passed to ensure that we didn't split
            complex matrix using real splitting subroutine.
            matrix itself is not changed.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>int</b> ablasblocksize(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_ablascomplexblocksize'></a><h3><code>ablascomplexblocksize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Block size for complex subroutines.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>int</b> ablascomplexblocksize(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_ablascomplexsplitlength'></a><h3><code>ablascomplexsplitlength</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Complex ABLASSplitLength

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> ablascomplexsplitlength(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>int</b>&amp; n1,
    <b>int</b>&amp; n2);
</div></pre>
<a name='sub_ablasmicroblocksize'></a><h3><code>ablasmicroblocksize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Microblock size

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>int</b> ablasmicroblocksize();
</div></pre>
<a name='sub_ablassplitlength'></a><h3><code>ablassplitlength</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Splits matrix length in two parts, left part should match ABLAS block size

INPUT PARAMETERS
    A   -   real matrix, is passed to ensure that we didn't split
            complex matrix using real splitting subroutine.
            matrix itself is not changed.
    N   -   length, N&gt;0

OUTPUT PARAMETERS
    N1  -   length
    N2  -   length

N1+N2=N, N1&gt;=N2, N2 may be zero

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> ablassplitlength(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>int</b>&amp; n1,
    <b>int</b>&amp; n2);
</div></pre>
<a name='sub_cmatrixcopy'></a><h3><code>cmatrixcopy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Copy

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    B   -   destination matrix
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixcopy(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> ib,
    <b>int</b> jb);
</div></pre>
<a name='sub_cmatrixgemm'></a><h3><code>cmatrixgemm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates C = alpha*op1(A)*op2(B) +beta*C where:
* C is MxN general matrix
* op1(A) is MxK matrix
* op2(B) is KxN matrix
* &quot;op&quot; may be identity transformation, transposition, conjugate transposition

Additional info:
* cache-oblivious algorithm is used.
* multiplication result replaces C. If Beta=0, C elements are not used in
  calculations (not multiplied by zero - just not referenced)
* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
* if both Beta and Alpha are zero, C is filled by zeros.

INPUT PARAMETERS
    N       -   matrix size, N&gt;0
    M       -   matrix size, N&gt;0
    K       -   matrix size, K&gt;0
    Alpha   -   coefficient
    A       -   matrix
    IA      -   submatrix offset
    JA      -   submatrix offset
    OpTypeA -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    B       -   matrix
    IB      -   submatrix offset
    JB      -   submatrix offset
    OpTypeB -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    Beta    -   coefficient
    C       -   matrix
    IC      -   submatrix offset
    JC      -   submatrix offset

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixgemm(<b>int</b> m,
    <b>int</b> n,
    <b>int</b> k,
    amp::campf&lt;Precision&gt; alpha,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    <b>int</b> optypea,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> ib,
    <b>int</b> jb,
    <b>int</b> optypeb,
    amp::campf&lt;Precision&gt; beta,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> ic,
    <b>int</b> jc);
</div></pre>
<a name='sub_cmatrixlefttrsm'></a><h3><code>cmatrixlefttrsm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates op(A^-1)*X where:
* X is MxN general matrix
* A is MxM upper/lower triangular/unitriangular matrix
* &quot;op&quot; may be identity transformation, transposition, conjugate transposition

Multiplication result replaces X.
Cache-oblivious algorithm is used.

INPUT PARAMETERS
    N   -   matrix size, N&gt;=0
    M   -   matrix size, N&gt;=0
    A       -   matrix, actial matrix is stored in A[I1:I1+M-1,J1:J1+M-1]
    I1      -   submatrix offset
    J1      -   submatrix offset
    IsUpper -   whether matrix is upper triangular
    IsUnit  -   whether matrix is unitriangular
    OpType  -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
    I2  -   submatrix offset
    J2  -   submatrix offset

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlefttrsm(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> i1,
    <b>int</b> j1,
    <b>bool</b> isupper,
    <b>bool</b> isunit,
    <b>int</b> optype,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> i2,
    <b>int</b> j2);
</div></pre>
<a name='sub_cmatrixmv'></a><h3><code>cmatrixmv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Matrix-vector product: y := op(A)*x

INPUT PARAMETERS:
    M   -   number of rows of op(A)
            M&gt;=0
    N   -   number of columns of op(A)
            N&gt;=0
    A   -   target matrix
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    OpA -   operation type:
            * OpA=0     =&gt;  op(A) = A
            * OpA=1     =&gt;  op(A) = A^T
            * OpA=2     =&gt;  op(A) = A^H
    X   -   input vector
    IX  -   subvector offset
    IY  -   subvector offset

OUTPUT PARAMETERS:
    Y   -   vector which stores result

if M=0, then subroutine does nothing.
if N=0, Y is filled by zeros.


  -- ALGLIB routine --

     28.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixmv(<b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    <b>int</b> opa,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> ix,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> iy);
</div></pre>
<a name='sub_cmatrixrank1'></a><h3><code>cmatrixrank1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rank-1 correction: A := A + u*v'

INPUT PARAMETERS:
    M   -   number of rows
    N   -   number of columns
    A   -   target matrix, MxN submatrix is updated
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    U   -   vector #1
    IU  -   subvector offset
    V   -   vector #2
    IV  -   subvector offset
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixrank1(<b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; u,
    <b>int</b> iu,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; v,
    <b>int</b> iv);
</div></pre>
<a name='sub_cmatrixrighttrsm'></a><h3><code>cmatrixrighttrsm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates X*op(A^-1) where:
* X is MxN general matrix
* A is NxN upper/lower triangular/unitriangular matrix
* &quot;op&quot; may be identity transformation, transposition, conjugate transposition

Multiplication result replaces X.
Cache-oblivious algorithm is used.

INPUT PARAMETERS
    N   -   matrix size, N&gt;=0
    M   -   matrix size, N&gt;=0
    A       -   matrix, actial matrix is stored in A[I1:I1+N-1,J1:J1+N-1]
    I1      -   submatrix offset
    J1      -   submatrix offset
    IsUpper -   whether matrix is upper triangular
    IsUnit  -   whether matrix is unitriangular
    OpType  -   transformation type:
                * 0 - no transformation
                * 1 - transposition
                * 2 - conjugate transposition
    C   -   matrix, actial matrix is stored in C[I2:I2+M-1,J2:J2+N-1]
    I2  -   submatrix offset
    J2  -   submatrix offset

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixrighttrsm(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> i1,
    <b>int</b> j1,
    <b>bool</b> isupper,
    <b>bool</b> isunit,
    <b>int</b> optype,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> i2,
    <b>int</b> j2);
</div></pre>
<a name='sub_cmatrixsyrk'></a><h3><code>cmatrixsyrk</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates  C=alpha*A*A^H+beta*C  or  C=alpha*A^H*A+beta*C
where:
* C is NxN Hermitian matrix given by its upper/lower triangle
* A is NxK matrix when A*A^H is calculated, KxN matrix otherwise

Additional info:
* cache-oblivious algorithm is used.
* multiplication result replaces C. If Beta=0, C elements are not used in
  calculations (not multiplied by zero - just not referenced)
* if Alpha=0, A is not used (not multiplied by zero - just not referenced)
* if both Beta and Alpha are zero, C is filled by zeros.

INPUT PARAMETERS
    N       -   matrix size, N&gt;=0
    K       -   matrix size, K&gt;=0
    Alpha   -   coefficient
    A       -   matrix
    IA      -   submatrix offset
    JA      -   submatrix offset
    OpTypeA -   multiplication type:
                * 0 - A*A^H is calculated
                * 2 - A^H*A is calculated
    Beta    -   coefficient
    C       -   matrix
    IC      -   submatrix offset
    JC      -   submatrix offset
    IsUpper -   whether C is upper triangular or lower triangular

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixsyrk(<b>int</b> n,
    <b>int</b> k,
    amp::ampf&lt;Precision&gt; alpha,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    <b>int</b> optypea,
    amp::ampf&lt;Precision&gt; beta,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> ic,
    <b>int</b> jc,
    <b>bool</b> isupper);
</div></pre>
<a name='sub_cmatrixtranspose'></a><h3><code>cmatrixtranspose</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivous complex &quot;copy-and-transpose&quot;

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    A   -   destination matrix
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixtranspose(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> ib,
    <b>int</b> jb);
</div></pre>
<a name='sub_rmatrixcopy'></a><h3><code>rmatrixcopy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Copy

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    B   -   destination matrix
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixcopy(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> ib,
    <b>int</b> jb);
</div></pre>
<a name='sub_rmatrixgemm'></a><h3><code>rmatrixgemm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as CMatrixGEMM, but for real numbers.
OpType may be only 0 or 1.

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixgemm(<b>int</b> m,
    <b>int</b> n,
    <b>int</b> k,
    amp::ampf&lt;Precision&gt; alpha,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    <b>int</b> optypea,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> ib,
    <b>int</b> jb,
    <b>int</b> optypeb,
    amp::ampf&lt;Precision&gt; beta,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> ic,
    <b>int</b> jc);
</div></pre>
<a name='sub_rmatrixlefttrsm'></a><h3><code>rmatrixlefttrsm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as CMatrixLeftTRSM, but for real matrices

OpType may be only 0 or 1.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlefttrsm(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> i1,
    <b>int</b> j1,
    <b>bool</b> isupper,
    <b>bool</b> isunit,
    <b>int</b> optype,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> i2,
    <b>int</b> j2);
</div></pre>
<a name='sub_rmatrixmv'></a><h3><code>rmatrixmv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Matrix-vector product: y := op(A)*x

INPUT PARAMETERS:
    M   -   number of rows of op(A)
    N   -   number of columns of op(A)
    A   -   target matrix
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    OpA -   operation type:
            * OpA=0     =&gt;  op(A) = A
            * OpA=1     =&gt;  op(A) = A^T
    X   -   input vector
    IX  -   subvector offset
    IY  -   subvector offset

OUTPUT PARAMETERS:
    Y   -   vector which stores result

if M=0, then subroutine does nothing.
if N=0, Y is filled by zeros.


  -- ALGLIB routine --

     28.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixmv(<b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    <b>int</b> opa,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> ix,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> iy);
</div></pre>
<a name='sub_rmatrixrank1'></a><h3><code>rmatrixrank1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rank-1 correction: A := A + u*v'

INPUT PARAMETERS:
    M   -   number of rows
    N   -   number of columns
    A   -   target matrix, MxN submatrix is updated
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    U   -   vector #1
    IU  -   subvector offset
    V   -   vector #2
    IV  -   subvector offset
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixrank1(<b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; u,
    <b>int</b> iu,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; v,
    <b>int</b> iv);
</div></pre>
<a name='sub_rmatrixrighttrsm'></a><h3><code>rmatrixrighttrsm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as CMatrixRightTRSM, but for real matrices

OpType may be only 0 or 1.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixrighttrsm(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> i1,
    <b>int</b> j1,
    <b>bool</b> isupper,
    <b>bool</b> isunit,
    <b>int</b> optype,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> i2,
    <b>int</b> j2);
</div></pre>
<a name='sub_rmatrixsyrk'></a><h3><code>rmatrixsyrk</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Same as CMatrixSYRK, but for real matrices

OpType may be only 0 or 1.

  -- ALGLIB routine --
     16.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixsyrk(<b>int</b> n,
    <b>int</b> k,
    amp::ampf&lt;Precision&gt; alpha,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    <b>int</b> optypea,
    amp::ampf&lt;Precision&gt; beta,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> ic,
    <b>int</b> jc,
    <b>bool</b> isupper);
</div></pre>
<a name='sub_rmatrixtranspose'></a><h3><code>rmatrixtranspose</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivous real &quot;copy-and-transpose&quot;

Input parameters:
    M   -   number of rows
    N   -   number of columns
    A   -   source matrix, MxN submatrix is copied and transposed
    IA  -   submatrix offset (row index)
    JA  -   submatrix offset (column index)
    A   -   destination matrix
    IB  -   submatrix offset (row index)
    JB  -   submatrix offset (column index)
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixtranspose(<b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> ia,
    <b>int</b> ja,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> ib,
    <b>int</b> jb);
</div></pre>
<a name=unit_autogk></a><h2><code>autogk</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_autogkreport' class=toc>autogkreport</a><br>
<a href='#struct_autogkstate' class=toc>autogkstate</a><br>
<h3>Functions</h3>
<a href='#sub_autogkiteration' class=toc>autogkiteration</a><br>
<a href='#sub_autogkresults' class=toc>autogkresults</a><br>
<a href='#sub_autogksingular' class=toc>autogksingular</a><br>
<a href='#sub_autogksmooth' class=toc>autogksmooth</a><br>
<a href='#sub_autogksmoothw' class=toc>autogksmoothw</a><br>
<h3>Examples</h3>
<a href='#example_autogk_singular' class=toc>autogk_singular</a><br>
<a href='#example_autogk_smooth' class=toc>autogk_smooth</a><br>
<a name='struct_autogkreport'></a><h3><code>autogkreport</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration report:
* TerminationType = completetion code:
    * -5    non-convergence of Gauss-Kronrod nodes
            calculation subroutine.
    * -1    incorrect parameters were specified
    *  1    OK
* Rep.NFEV countains number of function calculations
* Rep.NIntervals contains number of intervals [a,b]
  was partitioned into.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> autogkreport
{
<b>public</b>:
    <b>int</b> terminationtype;
    <b>int</b> nfev;
    <b>int</b> nintervals;
};
</div></pre>
<a name='struct_autogkstate'></a><h3><code>autogkstate</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This structure stores internal state of the integration algorithm  between
subsequent calls of the AutoGKIteration() subroutine.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> autogkstate
{
<b>public</b>:
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;
    amp::ampf&lt;Precision&gt; alpha;
    amp::ampf&lt;Precision&gt; beta;
    amp::ampf&lt;Precision&gt; xwidth;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; xminusa;
    amp::ampf&lt;Precision&gt; bminusx;
    amp::ampf&lt;Precision&gt; f;
    <b>int</b> wrappermode;
    autogkinternalstate&lt;Precision&gt; internalstate;
    amp::rcommstate&lt;Precision&gt; rstate;
    amp::ampf&lt;Precision&gt; v;
    <b>int</b> terminationtype;
    <b>int</b> nfev;
    <b>int</b> nintervals;
};
</div></pre>
<a name='sub_autogkiteration'></a><h3><code>autogkiteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One step of adaptive integration process.

Called after initialization with one of AutoGKXXX subroutines.
See HTML documentation for examples.

Input parameters:
    State   -   structure which stores algorithm state between  calls  and
                which  is  used  for   reverse   communication.   Must  be
                initialized with one of AutoGKXXX subroutines.

If suborutine returned False, iterative proces has converged. If subroutine
returned True, caller should calculate function value State.F  at  State.X
and call AutoGKIteration again.

NOTE:

When integrating &quot;difficult&quot; functions with integrable singularities like

    F(x) = (x-A)^alpha * (B-x)^beta

subroutine may require the value of F at points which are too close to A/B.
Sometimes to calculate integral with high enough precision we  may need to
calculate F(A+delta) when delta is less than machine  epsilon.  In  finite
precision arithmetics A+delta will be effectively equal to A,  so  we  may
find us in situation when  we  are  trying  to  calculate  something  like
1/sqrt(1-1).

To avoid  such  situations,  AutoGKIteration  subroutine  fills  not  only
State.X  field,  but  also   State.XMinusA   (which  equals  to  X-A)  and
State.BMinusX  (which  equals to B-X) fields.  If X is too close to A or B
(X-A&lt;0.001*A, or B-X&lt;0.001*B, for example) use  these  fields  instead  of
State.X


  -- ALGLIB --
     Copyright 07.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> autogkiteration(autogkstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_singular' class=nav>autogk_singular</a>&nbsp;&nbsp;<a href='#example_autogk_smooth' class=nav>autogk_smooth</a>&nbsp;&nbsp;</p>
<a name='sub_autogkresults'></a><h3><code>autogkresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Adaptive integration results

Called after AutoGKIteration returned False.

Input parameters:
    State   -   algorithm state (used by AutoGKIteration).

Output parameters:
    V       -   integral(f(x)dx,a,b)
    Rep     -   optimization report (see AutoGKReport description)

  -- ALGLIB --
     Copyright 14.11.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> autogkresults(<b>const</b> autogkstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt;&amp; v,
    autogkreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_singular' class=nav>autogk_singular</a>&nbsp;&nbsp;<a href='#example_autogk_smooth' class=nav>autogk_smooth</a>&nbsp;&nbsp;</p>
<a name='sub_autogksingular'></a><h3><code>autogksingular</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration on a finite interval [A,B].
Integrand have integrable singularities at A/B.

F(X) must diverge as &quot;(x-A)^alpha&quot; at A, as &quot;(B-x)^beta&quot; at B,  with known
alpha/beta (alpha&gt;-1, beta&gt;-1).  If alpha/beta  are  not known,  estimates
from below can be used (but these estimates should be greater than -1 too).

One  of  alpha/beta variables (or even both alpha/beta) may be equal to 0,
which means than function F(x) is non-singular at A/B. Anyway (singular at
bounds or not), function F(x) is supposed to be continuous on (A,B).

Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
is calculated with accuracy close to the machine precision.

INPUT PARAMETERS:
    A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)
    Alpha   -   power-law coefficient of the F(x) at A,
                Alpha&gt;-1
    Beta    -   power-law coefficient of the F(x) at B,
                Beta&gt;-1

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state between  subsequent
                calls of AutoGKIteration.  Used for reverse communication.
                This structure should be  passed  to  the  AutoGKIteration
                subroutine.

SEE ALSO
    AutoGKSmooth, AutoGKSmoothW, AutoGKIteration, AutoGKResults.


  -- ALGLIB --
     Copyright 06.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> autogksingular(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    amp::ampf&lt;Precision&gt; alpha,
    amp::ampf&lt;Precision&gt; beta,
    autogkstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_singular' class=nav>autogk_singular</a>&nbsp;&nbsp;</p>
<a name='sub_autogksmooth'></a><h3><code>autogksmooth</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration of a smooth function F(x) on a finite interval [a,b].

Fast-convergent algorithm based on a Gauss-Kronrod formula is used. Result
is calculated with accuracy close to the machine precision.

Algorithm works well only with smooth integrands.  It  may  be  used  with
continuous non-smooth integrands, but with  less  performance.

It should never be used with integrands which have integrable singularities
at lower or upper limits - algorithm may crash. Use AutoGKSingular in such
cases.

INPUT PARAMETERS:
    A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)
    
OUTPUT PARAMETERS
    State   -   structure which stores algorithm state between  subsequent
                calls of AutoGKIteration.  Used for reverse communication.
                This structure should be  passed  to  the  AutoGKIteration
                subroutine.

SEE ALSO
    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.
    

  -- ALGLIB --
     Copyright 06.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> autogksmooth(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    autogkstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_autogk_smooth' class=nav>autogk_smooth</a>&nbsp;&nbsp;</p>
<a name='sub_autogksmoothw'></a><h3><code>autogksmoothw</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Integration of a smooth function F(x) on a finite interval [a,b].

This subroutine is same as AutoGKSmooth(), but it guarantees that interval
[a,b] is partitioned into subintervals which have width at most XWidth.

Subroutine  can  be  used  when  integrating nearly-constant function with
narrow &quot;bumps&quot; (about XWidth wide). If &quot;bumps&quot; are too narrow, AutoGKSmooth
subroutine can overlook them.

INPUT PARAMETERS:
    A, B    -   interval boundaries (A&lt;B, A=B or A&gt;B)

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state between  subsequent
                calls of AutoGKIteration.  Used for reverse communication.
                This structure should be  passed  to  the  AutoGKIteration
                subroutine.

SEE ALSO
    AutoGKSmooth, AutoGKSingular, AutoGKIteration, AutoGKResults.


  -- ALGLIB --
     Copyright 06.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> autogksmoothw(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    amp::ampf&lt;Precision&gt; xwidth,
    autogkstate&lt;Precision&gt;&amp; state);
</div></pre>
<a name='example_autogk_singular'></a><h3>autogk_singular example</h3>
<pre>
    autogk::autogkstate&lt;Precision&gt; state;
    amp::ampf&lt;Precision&gt; v;
    autogk::autogkreport&lt;Precision&gt; rep;
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;
    amp::ampf&lt;Precision&gt; alpha;


    
<font color=navy>    //</font>
<font color=navy>    // f1(x) = (1+x)*(x-a)^alpha, alpha=-0.3</font>
<font color=navy>    // Exact answer is (B-A)^(Alpha+2)/(Alpha+2) + (1+A)*(B-A)^(Alpha+1)/(Alpha+1)</font>
<font color=navy>    //</font>
<font color=navy>    // This code demonstrates use of the State.XMinusA (State.BMinusX) field.</font>
<font color=navy>    //</font>
<font color=navy>    // If we try to use State.X instead of State.XMinusA,</font>
<font color=navy>    // we will end up dividing by zero! (in 64-bit precision)</font>
<font color=navy>    //</font>
    a = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
    b = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;5.0&quot;</font>);
    alpha = -amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.9&quot;</font>);
    autogk::autogksingular&lt;Precision&gt;(a, b, alpha, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), state);
    <b>while</b>( autogk::autogkiteration&lt;Precision&gt;(state) )
    {
        state.f = amp::pow&lt;Precision&gt;(state.xminusa, alpha)*(1+state.x);
    }
    autogk::autogkresults&lt;Precision&gt;(state, v, rep);
    printf(<font color=blue>&quot;integral((1+x)*(x-a)^alpha) on [%0.1lf; %0.1lf] = %0.2lf\nExact answer is %0.2lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(a).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(b).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::pow&lt;Precision&gt;(b-a, alpha+2)/(alpha+2)+(1+a)*amp::pow&lt;Precision&gt;(b-a, alpha+1)/(alpha+1)).toDouble()));

</pre><a name='example_autogk_smooth'></a><h3>autogk_smooth example</h3>
<pre>
    autogk::autogkstate&lt;Precision&gt; state;
    amp::ampf&lt;Precision&gt; v;
    autogk::autogkreport&lt;Precision&gt; rep;


    
<font color=navy>    //</font>
<font color=navy>    // f(x) = x*sin(x), integrated at [-pi, pi].</font>
<font color=navy>    // Exact answer is 2*pi</font>
<font color=navy>    //</font>
    autogk::autogksmooth&lt;Precision&gt;(-amp::pi&lt;Precision&gt;(), +amp::pi&lt;Precision&gt;(), state);
    <b>while</b>( autogk::autogkiteration&lt;Precision&gt;(state) )
    {
        state.f = state.x*amp::sin&lt;Precision&gt;(state.x);
    }
    autogk::autogkresults&lt;Precision&gt;(state, v, rep);
    printf(<font color=blue>&quot;integral(x*sin(x),-pi,+pi) = %0.2lf\nExact answer is %0.2lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(2*amp::pi&lt;Precision&gt;()).toDouble()));

</pre><a name=unit_bdsvd></a><h2><code>bdsvd</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_rmatrixbdsvd' class=toc>rmatrixbdsvd</a><br>
<a name='sub_rmatrixbdsvd'></a><h3><code>rmatrixbdsvd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Singular value decomposition of a bidiagonal matrix (extended algorithm)

The algorithm performs the singular value decomposition  of  a  bidiagonal
matrix B (upper or lower) representing it as B = Q*S*P^T, where Q and  P -
orthogonal matrices, S - diagonal matrix with non-negative elements on the
main diagonal, in descending order.

The  algorithm  finds  singular  values.  In  addition,  the algorithm can
calculate  matrices  Q  and P (more precisely, not the matrices, but their
product  with  given  matrices U and VT - U*Q and (P^T)*VT)).  Of  course,
matrices U and VT can be of any type, including identity. Furthermore, the
algorithm can calculate Q'*C (this product is calculated more  effectively
than U*Q,  because  this calculation operates with rows instead  of matrix
columns).

The feature of the algorithm is its ability to find  all  singular  values
including those which are arbitrarily close to 0  with  relative  accuracy
close to  machine precision. If the parameter IsFractionalAccuracyRequired
is set to True, all singular values will have high relative accuracy close
to machine precision. If the parameter is set to False, only  the  biggest
singular value will have relative accuracy  close  to  machine  precision.
The absolute error of other singular values is equal to the absolute error
of the biggest singular value.

Input parameters:
    D       -   main diagonal of matrix B.
                Array whose index ranges within [0..N-1].
    E       -   superdiagonal (or subdiagonal) of matrix B.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix B.
    IsUpper -   True, if the matrix is upper bidiagonal.
    IsFractionalAccuracyRequired -
                accuracy to search singular values with.
    U       -   matrix to be multiplied by Q.
                Array whose indexes range within [0..NRU-1, 0..N-1].
                The matrix can be bigger, in that case only the  submatrix
                [0..NRU-1, 0..N-1] will be multiplied by Q.
    NRU     -   number of rows in matrix U.
    C       -   matrix to be multiplied by Q'.
                Array whose indexes range within [0..N-1, 0..NCC-1].
                The matrix can be bigger, in that case only the  submatrix
                [0..N-1, 0..NCC-1] will be multiplied by Q'.
    NCC     -   number of columns in matrix C.
    VT      -   matrix to be multiplied by P^T.
                Array whose indexes range within [0..N-1, 0..NCVT-1].
                The matrix can be bigger, in that case only the  submatrix
                [0..N-1, 0..NCVT-1] will be multiplied by P^T.
    NCVT    -   number of columns in matrix VT.

Output parameters:
    D       -   singular values of matrix B in descending order.
    U       -   if NRU&gt;0, contains matrix U*Q.
    VT      -   if NCVT&gt;0, contains matrix (P^T)*VT.
    C       -   if NCC&gt;0, contains matrix Q'*C.

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged (rare case).

Additional information:
    The type of convergence is controlled by the internal  parameter  TOL.
    If the parameter is greater than 0, the singular values will have
    relative accuracy TOL. If TOL&lt;0, the singular values will have
    absolute accuracy ABS(TOL)*norm(B).
    By default, |TOL| falls within the range of 10*Epsilon and 100*Epsilon,
    where Epsilon is the machine precision. It is not  recommended  to  use
    TOL less than 10*Epsilon since this will  considerably  slow  down  the
    algorithm and may not lead to error decreasing.
History:
    * 31 March, 2007.
        changed MAXITR from 6 to 12.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1999.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> rmatrixbdsvd(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; e,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isfractionalaccuracyrequired,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; u,
    <b>int</b> nru,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> ncc,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; vt,
    <b>int</b> ncvt);
</div></pre>
<a name=unit_conv></a><h2><code>conv</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_convc1d' class=toc>convc1d</a><br>
<a href='#sub_convc1dcircular' class=toc>convc1dcircular</a><br>
<a href='#sub_convc1dcircularinv' class=toc>convc1dcircularinv</a><br>
<a href='#sub_convc1dinv' class=toc>convc1dinv</a><br>
<a href='#sub_convc1dx' class=toc>convc1dx</a><br>
<a href='#sub_convr1d' class=toc>convr1d</a><br>
<a href='#sub_convr1dcircular' class=toc>convr1dcircular</a><br>
<a href='#sub_convr1dcircularinv' class=toc>convr1dcircularinv</a><br>
<a href='#sub_convr1dinv' class=toc>convr1dinv</a><br>
<a href='#sub_convr1dx' class=toc>convr1dx</a><br>
<a name='sub_convc1d'></a><h3><code>convc1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex convolution.

For given A/B returns conv(A,B) (non-circular). Subroutine can automatically
choose between three implementations: straightforward O(M*N)  formula  for
very small N (or M), overlap-add algorithm for  cases  where  max(M,N)  is
significantly larger than min(M,N), but O(M*N) algorithm is too slow,  and
general FFT-based formula for cases where two previois algorithms are  too
slow.

Algorithm has max(M,N)*log(max(M,N)) complexity for any M/N.

INPUT PARAMETERS
    A   -   array[0..M-1] - complex function to be transformed
    M   -   problem size
    B   -   array[0..N-1] - complex function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..N+M-2].

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convc1d(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convc1dcircular'></a><h3><code>convc1dcircular</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular complex convolution.

For given S/R returns conv(S,R) (circular). Algorithm has linearithmic
complexity for any M/N.

IMPORTANT:  normal convolution is commutative,  i.e.   it  is symmetric  -
conv(A,B)=conv(B,A).  Cyclic convolution IS NOT.  One function - S - is  a
signal,  periodic function, and another - R - is a response,  non-periodic
function with limited length.

INPUT PARAMETERS
    S   -   array[0..M-1] - complex periodic signal
    M   -   problem size
    B   -   array[0..N-1] - complex non-periodic response
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convc1dcircular(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; s,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; c);
</div></pre>
<a name='sub_convc1dcircularinv'></a><h3><code>convc1dcircularinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular complex deconvolution (inverse of ConvC1DCircular()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved periodic signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - non-periodic response
    N   -   response length

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-1].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convc1dcircularinv(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convc1dinv'></a><h3><code>convc1dinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex non-circular deconvolution (inverse of ConvC1D()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - response
    N   -   response length, N&lt;=M

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-N].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convc1dinv(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convc1dx'></a><h3><code>convc1dx</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex convolution.

Extended subroutine which allows to choose convolution algorithm.
Intended for internal use, ALGLIB users should call ConvC1D()/ConvC1DCircular().

INPUT PARAMETERS
    A   -   array[0..M-1] - complex function to be transformed
    M   -   problem size
    B   -   array[0..N-1] - complex function to be transformed
    N   -   problem size, N&lt;=M
    Alg -   algorithm type:
            *-2     auto-select Q for overlap-add
            *-1     auto-select algorithm and parameters
            * 0     straightforward formula for small N's
            * 1     general FFT-based code
            * 2     overlap-add with length Q
    Q   -   length for overlap-add

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..N+M-1].

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convc1dx(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    <b>bool</b> circular,
    <b>int</b> alg,
    <b>int</b> q,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convr1d'></a><h3><code>convr1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real convolution.

Analogous to ConvC1D(), see ConvC1D() comments for more details.

INPUT PARAMETERS
    A   -   array[0..M-1] - real function to be transformed
    M   -   problem size
    B   -   array[0..N-1] - real function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..N+M-2].

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convr1d(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convr1dcircular'></a><h3><code>convr1dcircular</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular real convolution.

Analogous to ConvC1DCircular(), see ConvC1DCircular() comments for more details.

INPUT PARAMETERS
    S   -   array[0..M-1] - real signal
    M   -   problem size
    B   -   array[0..N-1] - real response
    N   -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convr1dcircular(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; s,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c);
</div></pre>
<a name='sub_convr1dcircularinv'></a><h3><code>convr1dcircularinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex deconvolution (inverse of ConvC1D()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - response
    N   -   response length

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-N].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that B is zero at T&lt;0. If  it  has  non-zero  values  at
negative T's, you can still use this subroutine - just  shift  its  result
correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convr1dcircularinv(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convr1dinv'></a><h3><code>convr1dinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real deconvolution (inverse of ConvC1D()).

Algorithm has M*log(M)) complexity for any M (composite or prime).

INPUT PARAMETERS
    A   -   array[0..M-1] - convolved signal, A = conv(R, B)
    M   -   convolved signal length
    B   -   array[0..N-1] - response
    N   -   response length, N&lt;=M

OUTPUT PARAMETERS
    R   -   deconvolved signal. array[0..M-N].

NOTE:
    deconvolution is unstable process and may result in division  by  zero
(if your response function is degenerate, i.e. has zero Fourier coefficient).

NOTE:
    It is assumed that A is zero at T&lt;0, B is zero too.  If  one  or  both
functions have non-zero values at negative T's, you  can  still  use  this
subroutine - just shift its result correspondingly.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convr1dinv(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_convr1dx'></a><h3><code>convr1dx</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real convolution.

Extended subroutine which allows to choose convolution algorithm.
Intended for internal use, ALGLIB users should call ConvR1D().

INPUT PARAMETERS
    A   -   array[0..M-1] - complex function to be transformed
    M   -   problem size
    B   -   array[0..N-1] - complex function to be transformed
    N   -   problem size, N&lt;=M
    Alg -   algorithm type:
            *-2     auto-select Q for overlap-add
            *-1     auto-select algorithm and parameters
            * 0     straightforward formula for small N's
            * 1     general FFT-based code
            * 2     overlap-add with length Q
    Q   -   length for overlap-add

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..N+M-1].

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> convr1dx(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    <b>bool</b> circular,
    <b>int</b> alg,
    <b>int</b> q,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name=unit_corr></a><h2><code>corr</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_corrc1d' class=toc>corrc1d</a><br>
<a href='#sub_corrc1dcircular' class=toc>corrc1dcircular</a><br>
<a href='#sub_corrr1d' class=toc>corrr1d</a><br>
<a href='#sub_corrr1dcircular' class=toc>corrr1dcircular</a><br>
<a name='sub_corrc1d'></a><h3><code>corrc1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (non-circular).

Correlation is calculated using reduction to  convolution.  Algorithm with
max(N,N)*log(max(N,N)) complexity is used (see  ConvC1D()  for  more  info
about performance).

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order: CorrC1D(Signal, Pattern) = Pattern x Signal (using  traditional
    definition of cross-correlation, denoting cross-correlation as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - complex function to be transformed,
                signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - complex function to be transformed,
                pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R       -   cross-correlation, array[0..N+M-2]:
                * positive lags are stored in R[0..N-1],
                  R[i] = sum(conj(pattern[j])*signal[i+j]
                * negative lags are stored in R[N..N+M-2],
                  R[N+M-1-i] = sum(conj(pattern[j])*signal[-i+j]

NOTE:
    It is assumed that pattern domain is [0..M-1].  If Pattern is non-zero
on [-K..M-1],  you can still use this subroutine, just shift result by K.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> corrc1d(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; signal,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; pattern,
    <b>int</b> m,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_corrc1dcircular'></a><h3><code>corrc1dcircular</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular complex cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (circular).
Algorithm has linearithmic complexity for any M/N.

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order:   CorrC1DCircular(Signal, Pattern) = Pattern x Signal    (using
    traditional definition of cross-correlation, denoting cross-correlation
    as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - complex function to be transformed,
                periodic signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - complex function to be transformed,
                non-periodic pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].


  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> corrc1dcircular(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; signal,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; pattern,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; c);
</div></pre>
<a name='sub_corrr1d'></a><h3><code>corrr1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (non-circular).

Correlation is calculated using reduction to  convolution.  Algorithm with
max(N,N)*log(max(N,N)) complexity is used (see  ConvC1D()  for  more  info
about performance).

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order: CorrR1D(Signal, Pattern) = Pattern x Signal (using  traditional
    definition of cross-correlation, denoting cross-correlation as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - real function to be transformed,
                signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - real function to be transformed,
                pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R       -   cross-correlation, array[0..N+M-2]:
                * positive lags are stored in R[0..N-1],
                  R[i] = sum(pattern[j]*signal[i+j]
                * negative lags are stored in R[N..N+M-2],
                  R[N+M-1-i] = sum(pattern[j]*signal[-i+j]

NOTE:
    It is assumed that pattern domain is [0..M-1].  If Pattern is non-zero
on [-K..M-1],  you can still use this subroutine, just shift result by K.

  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> corrr1d(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; signal,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; pattern,
    <b>int</b> m,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_corrr1dcircular'></a><h3><code>corrr1dcircular</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional circular real cross-correlation.

For given Pattern/Signal returns corr(Pattern,Signal) (circular).
Algorithm has linearithmic complexity for any M/N.

IMPORTANT:
    for  historical reasons subroutine accepts its parameters in  reversed
    order:   CorrR1DCircular(Signal, Pattern) = Pattern x Signal    (using
    traditional definition of cross-correlation, denoting cross-correlation
    as &quot;x&quot;).

INPUT PARAMETERS
    Signal  -   array[0..N-1] - real function to be transformed,
                periodic signal containing pattern
    N       -   problem size
    Pattern -   array[0..M-1] - real function to be transformed,
                non-periodic pattern to search withing signal
    M       -   problem size

OUTPUT PARAMETERS
    R   -   convolution: A*B. array[0..M-1].


  -- ALGLIB --
     Copyright 21.07.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> corrr1dcircular(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; signal,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; pattern,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c);
</div></pre>
<a name=unit_densesolver></a><h2><code>densesolver</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixlusolve' class=toc>cmatrixlusolve</a><br>
<a href='#sub_cmatrixlusolvem' class=toc>cmatrixlusolvem</a><br>
<a href='#sub_cmatrixmixedsolve' class=toc>cmatrixmixedsolve</a><br>
<a href='#sub_cmatrixmixedsolvem' class=toc>cmatrixmixedsolvem</a><br>
<a href='#sub_cmatrixsolve' class=toc>cmatrixsolve</a><br>
<a href='#sub_cmatrixsolvem' class=toc>cmatrixsolvem</a><br>
<a href='#sub_hpdmatrixcholeskysolve' class=toc>hpdmatrixcholeskysolve</a><br>
<a href='#sub_hpdmatrixcholeskysolvem' class=toc>hpdmatrixcholeskysolvem</a><br>
<a href='#sub_hpdmatrixsolve' class=toc>hpdmatrixsolve</a><br>
<a href='#sub_hpdmatrixsolvem' class=toc>hpdmatrixsolvem</a><br>
<a href='#sub_rmatrixlusolve' class=toc>rmatrixlusolve</a><br>
<a href='#sub_rmatrixlusolvem' class=toc>rmatrixlusolvem</a><br>
<a href='#sub_rmatrixmixedsolve' class=toc>rmatrixmixedsolve</a><br>
<a href='#sub_rmatrixmixedsolvem' class=toc>rmatrixmixedsolvem</a><br>
<a href='#sub_rmatrixsolve' class=toc>rmatrixsolve</a><br>
<a href='#sub_rmatrixsolvels' class=toc>rmatrixsolvels</a><br>
<a href='#sub_rmatrixsolvem' class=toc>rmatrixsolvem</a><br>
<a href='#sub_spdmatrixcholeskysolve' class=toc>spdmatrixcholeskysolve</a><br>
<a href='#sub_spdmatrixcholeskysolvem' class=toc>spdmatrixcholeskysolvem</a><br>
<a href='#sub_spdmatrixsolve' class=toc>spdmatrixsolve</a><br>
<a href='#sub_spdmatrixsolvem' class=toc>spdmatrixsolvem</a><br>
<a name='sub_cmatrixlusolve'></a><h3><code>cmatrixlusolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixLUSolve(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation

No iterative refinement is provided because exact form of original matrix
is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlusolve(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_cmatrixlusolvem'></a><h3><code>cmatrixlusolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixLUSolveM(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation

No iterative refinement  is provided because exact form of original matrix
is not known to subroutine. Use CMatrixSolve or CMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlusolvem(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_cmatrixmixedsolve'></a><h3><code>cmatrixmixedsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixMixedSolve(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolveM
    Rep     -   same as in RMatrixSolveM
    X       -   same as in RMatrixSolveM

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixmixedsolve(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_cmatrixmixedsolvem'></a><h3><code>cmatrixmixedsolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixMixedSolveM(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(M*N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, CMatrixLU result
    P       -   array[0..N-1], pivots array, CMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolveM
    Rep     -   same as in RMatrixSolveM
    X       -   same as in RMatrixSolveM

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixmixedsolvem(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_cmatrixsolve'></a><h3><code>cmatrixsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixSolve(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^3) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixsolve(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_cmatrixsolvem'></a><h3><code>cmatrixsolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixSolveM(), but for complex matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^3+M*N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size
    RFS     -   iterative refinement switch:
                * True - refinement is used.
                  Less performance, more precision.
                * False - refinement is not used.
                  More performance, less precision.

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixsolvem(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>bool</b> rfs,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_hpdmatrixcholeskysolve'></a><h3><code>hpdmatrixcholeskysolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixLUSolve(), but for  HPD matrices  represented
by their Cholesky decomposition.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of A
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixcholeskysolve(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; cha,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_hpdmatrixcholeskysolvem'></a><h3><code>hpdmatrixcholeskysolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixLUSolveM(), but for HPD matrices  represented
by their Cholesky decomposition.

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                HPDMatrixCholesky result
    N       -   size of CHA
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixcholeskysolvem(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; cha,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_hpdmatrixsolve'></a><h3><code>hpdmatrixsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixSolve(),  but for Hermitian positive definite
matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
                Returns -3 for non-HPD matrices.
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixsolve(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_hpdmatrixsolvem'></a><h3><code>hpdmatrixsolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixSolveM(), but for Hermitian positive definite
matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3+M*N^2) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve.
                Returns -3 for non-HPD matrices.
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixsolvem(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixlusolve'></a><h3><code>rmatrixlusolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*X=B,  where A is NxN non-denegerate
real matrix given by its LU decomposition, X and B are NxM real matrices.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation

No iterative refinement  is provided because exact form of original matrix
is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve
    
  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlusolve(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixlusolvem'></a><h3><code>rmatrixlusolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixLUSolve() but solves task with multiple right parts
(where b and x are NxM matrices).

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation

No iterative refinement  is provided because exact form of original matrix
is not known to subroutine. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlusolvem(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixmixedsolve'></a><h3><code>rmatrixmixedsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*x=b,  where BOTH ORIGINAL A AND ITS
LU DECOMPOSITION ARE KNOWN. You can use it if for some  reasons  you  have
both A and its LU decomposition.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolveM
    Rep     -   same as in RMatrixSolveM
    X       -   same as in RMatrixSolveM

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixmixedsolve(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixmixedsolvem'></a><h3><code>rmatrixmixedsolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixMixedSolve() but  solves task with multiple right  parts
(where b and x are NxM matrices).

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(M*N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    LUA     -   array[0..N-1,0..N-1], LU decomposition, RMatrixLU result
    P       -   array[0..N-1], pivots array, RMatrixLU result
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolveM
    Rep     -   same as in RMatrixSolveM
    X       -   same as in RMatrixSolveM

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixmixedsolvem(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; lua,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; p,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixsolve'></a><h3><code>rmatrixsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This  subroutine  solves  a  system  A*x=b,  where A is NxN non-denegerate
real matrix, x and b are vectors.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* iterative refinement
* O(N^3) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   return code:
                * -3    A is singular, or VERY close to singular.
                        X is filled by zeros in such cases.
                * -1    N&lt;=0 was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   solver report, see below for more info
    X       -   array[0..N-1], it contains:
                * solution of A*x=b if A is non-singular (well-conditioned
                  or ill-conditioned, but not very close to singular)
                * zeros,  if  A  is  singular  or  VERY  close to singular
                  (in this case Info=-3).

SOLVER REPORT

Subroutine sets following fields of the Rep structure:
* R1        reciprocal of condition number: 1/cond(A), 1-norm.
* RInf      reciprocal of condition number: 1/cond(A), inf-norm.

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixsolve(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixsolvels'></a><h3><code>rmatrixsolvels</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

This subroutine finds solution of the linear system A*X=B with non-square,
possibly degenerate A.  System  is  solved in the least squares sense, and
general least squares solution  X = X0 + CX*y  which  minimizes |A*X-B| is
returned. If A is non-degenerate, solution in the  usual sense is returned

Algorithm features:
* automatic detection of degenerate cases
* iterative refinement
* O(N^3) complexity

INPUT PARAMETERS
    A       -   array[0..NRows-1,0..NCols-1], system matrix
    NRows   -   vertical size of A
    NCols   -   horizontal size of A
    B       -   array[0..NCols-1], right part
    Threshold-  a number in [0,1]. Singular values  beyond  Threshold  are
                considered  zero.  Set  it to 0.0, if you don't understand
                what it means, so the solver will choose good value on its
                own.
                
OUTPUT PARAMETERS
    Info    -   return code:
                * -4    SVD subroutine failed
                * -1    if NRows&lt;=0 or NCols&lt;=0 or Threshold&lt;0 was passed
                *  1    if task is solved
    Rep     -   solver report, see below for more info
    X       -   array[0..N-1,0..M-1], it contains:
                * solution of A*X=B if A is non-singular (well-conditioned
                  or ill-conditioned, but not very close to singular)
                * zeros,  if  A  is  singular  or  VERY  close to singular
                  (in this case Info=-3).

SOLVER REPORT

Subroutine sets following fields of the Rep structure:
* R2        reciprocal of condition number: 1/cond(A), 2-norm.
* N         = NCols
* K         dim(Null(A))
* CX        array[0..N-1,0..K-1], kernel of A.
            Columns of CX store such vectors that A*CX[i]=0.

  -- ALGLIB --
     Copyright 24.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixsolvels(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> nrows,
    <b>int</b> ncols,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    amp::ampf&lt;Precision&gt; threshold,
    <b>int</b>&amp; info,
    densesolverlsreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_rmatrixsolvem'></a><h3><code>rmatrixsolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver.

Similar to RMatrixSolve() but solves task with multiple right parts (where
b and x are NxM matrices).

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* optional iterative refinement
* O(N^3+M*N^2) complexity

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size
    RFS     -   iterative refinement switch:
                * True - refinement is used.
                  Less performance, more precision.
                * False - refinement is not used.
                  More performance, less precision.

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixsolvem(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>bool</b> rfs,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_spdmatrixcholeskysolve'></a><h3><code>spdmatrixcholeskysolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixLUSolve(), but for  SPD matrices  represented
by their Cholesky decomposition.

Algorithm features:
* automatic detection of degenerate cases
* O(N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of A
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixcholeskysolve(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; cha,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_spdmatrixcholeskysolvem'></a><h3><code>spdmatrixcholeskysolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixLUSolveM(), but for SPD matrices  represented
by their Cholesky decomposition.

Algorithm features:
* automatic detection of degenerate cases
* O(M*N^2) complexity
* condition number estimation
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    CHA     -   array[0..N-1,0..N-1], Cholesky decomposition,
                SPDMatrixCholesky result
    N       -   size of CHA
    IsUpper -   what half of CHA is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixcholeskysolvem(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; cha,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_spdmatrixsolve'></a><h3><code>spdmatrixsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixSolve(), but for SPD matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1], right part

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve
                Returns -3 for non-SPD matrices.
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixsolve(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_spdmatrixsolvem'></a><h3><code>spdmatrixsolvem</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Dense solver. Same as RMatrixSolveM(), but for symmetric positive definite
matrices.

Algorithm features:
* automatic detection of degenerate cases
* condition number estimation
* O(N^3+M*N^2) complexity
* matrix is represented by its upper or lower triangle

No iterative refinement is provided because such partial representation of
matrix does not allow efficient calculation of extra-precise  matrix-vector
products for large matrices. Use RMatrixSolve or RMatrixMixedSolve  if  you
need iterative refinement.

INPUT PARAMETERS
    A       -   array[0..N-1,0..N-1], system matrix
    N       -   size of A
    IsUpper -   what half of A is provided
    B       -   array[0..N-1,0..M-1], right part
    M       -   right part size

OUTPUT PARAMETERS
    Info    -   same as in RMatrixSolve.
                Returns -3 for non-SPD matrices.
    Rep     -   same as in RMatrixSolve
    X       -   same as in RMatrixSolve

  -- ALGLIB --
     Copyright 27.01.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixsolvem(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b>&amp; info,
    densesolverreport&lt;Precision&gt;&amp; rep,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name=unit_evd></a><h2><code>evd</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_hmatrixevd' class=toc>hmatrixevd</a><br>
<a href='#sub_hmatrixevdi' class=toc>hmatrixevdi</a><br>
<a href='#sub_hmatrixevdr' class=toc>hmatrixevdr</a><br>
<a href='#sub_rmatrixevd' class=toc>rmatrixevd</a><br>
<a href='#sub_smatrixevd' class=toc>smatrixevd</a><br>
<a href='#sub_smatrixevdi' class=toc>smatrixevdi</a><br>
<a href='#sub_smatrixevdr' class=toc>smatrixevdr</a><br>
<a href='#sub_smatrixtdevd' class=toc>smatrixtdevd</a><br>
<a href='#sub_smatrixtdevdi' class=toc>smatrixtdevdi</a><br>
<a href='#sub_smatrixtdevdr' class=toc>smatrixtdevdr</a><br>
<a name='sub_hmatrixevd'></a><h3><code>hmatrixevd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding the eigenvalues and eigenvectors of a Hermitian matrix

The algorithm finds eigen pairs of a Hermitian matrix by  reducing  it  to
real tridiagonal form and using the QL/QR algorithm.

Input parameters:
    A       -   Hermitian matrix which is given  by  its  upper  or  lower
                triangular part.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.
    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
                not. If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.

Output parameters:
    D       -   eigenvalues in ascending order.
                Array whose index ranges within [0..N-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains the eigenvectors.
                Array whose indexes range within [0..N-1, 0..N-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged (rare case).

Note:
    eigenvectors of Hermitian matrix are defined up to  multiplication  by
    a complex number L, such that |L|=1.

  -- ALGLIB --
     Copyright 2005, 23 March 2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> hmatrixevd(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_hmatrixevdi'></a><h3><code>hmatrixevdi</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues and  eigenvectors  of  a  Hermitian
matrix with given indexes by using bisection and inverse iteration methods

Input parameters:
    A       -   Hermitian matrix which is given  by  its  upper  or  lower
                triangular part.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
                not. If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    I1, I2 -    index interval for searching (from I1 to I2).
                0 &lt;= I1 &lt;= I2 &lt;= N-1.

Output parameters:
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..I2-I1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..I2-I1].
                In  that  case,  the eigenvectors are stored in the matrix
                columns.

Result:
    True, if successful. W contains the eigenvalues, Z contains the
    eigenvectors (if needed).

    False, if the bisection method subroutine  wasn't  able  to  find  the
    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
    subroutine wasn't able to find  all  the  corresponding  eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned.

Note:
    eigen vectors of Hermitian matrix are defined up to multiplication  by
    a complex number L, such as |L|=1.

  -- ALGLIB --
     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> hmatrixevdi(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>bool</b> isupper,
    <b>int</b> i1,
    <b>int</b> i2,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_hmatrixevdr'></a><h3><code>hmatrixevdr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues (and eigenvectors) of  a  Hermitian
matrix  in  a  given half-interval (A, B] by using a bisection and inverse
iteration

Input parameters:
    A       -   Hermitian matrix which is given  by  its  upper  or  lower
                triangular  part.  Array  whose   indexes   range   within
                [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors  are  needed  or
                not. If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    B1, B2 -    half-interval (B1, B2] to search eigenvalues in.

Output parameters:
    M       -   number of eigenvalues found in a given half-interval, M&gt;=0
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..M-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..M-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if successful. M contains the number of eigenvalues in the given
    half-interval (could be equal to 0), W contains the eigenvalues,
    Z contains the eigenvectors (if needed).

    False, if the bisection method subroutine  wasn't  able  to  find  the
    eigenvalues  in  the  given  interval  or  if  the  inverse  iteration
    subroutine  wasn't  able  to  find all the corresponding eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned, M  is
    equal to 0.

Note:
    eigen vectors of Hermitian matrix are defined up to multiplication  by
    a complex number L, such as |L|=1.

  -- ALGLIB --
     Copyright 07.01.2006, 24.03.2007 by Bochkanov Sergey.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> hmatrixevdr(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>bool</b> isupper,
    amp::ampf&lt;Precision&gt; b1,
    amp::ampf&lt;Precision&gt; b2,
    <b>int</b>&amp; m,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_rmatrixevd'></a><h3><code>rmatrixevd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding eigenvalues and eigenvectors of a general matrix

The algorithm finds eigenvalues and eigenvectors of a general matrix by
using the QR algorithm with multiple shifts. The algorithm can find
eigenvalues and both left and right eigenvectors.

The right eigenvector is a vector x such that A*x = w*x, and the left
eigenvector is a vector y such that y'*A = w*y' (here y' implies a complex
conjugate transposition of vector y).

Input parameters:
    A       -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    VNeeded -   flag controlling whether eigenvectors are needed or not.
                If VNeeded is equal to:
                 * 0, eigenvectors are not returned;
                 * 1, right eigenvectors are returned;
                 * 2, left eigenvectors are returned;
                 * 3, both left and right eigenvectors are returned.

Output parameters:
    WR      -   real parts of eigenvalues.
                Array whose index ranges within [0..N-1].
    WR      -   imaginary parts of eigenvalues.
                Array whose index ranges within [0..N-1].
    VL, VR  -   arrays of left and right eigenvectors (if they are needed).
                If WI[i]=0, the respective eigenvalue is a real number,
                and it corresponds to the column number I of matrices VL/VR.
                If WI[i]&gt;0, we have a pair of complex conjugate numbers with
                positive and negative imaginary parts:
                    the first eigenvalue WR[i] + sqrt(-1)*WI[i];
                    the second eigenvalue WR[i+1] + sqrt(-1)*WI[i+1];
                    WI[i]&gt;0
                    WI[i+1] = -WI[i] &lt; 0
                In that case, the eigenvector  corresponding to the first
                eigenvalue is located in i and i+1 columns of matrices
                VL/VR (the column number i contains the real part, and the
                column number i+1 contains the imaginary part), and the vector
                corresponding to the second eigenvalue is a complex conjugate to
                the first vector.
                Arrays whose indexes range within [0..N-1, 0..N-1].

Result:
    True, if the algorithm has converged.
    False, if the algorithm has not converged.

Note 1:
    Some users may ask the following question: what if WI[N-1]&gt;0?
    WI[N] must contain an eigenvalue which is complex conjugate to the
    N-th eigenvalue, but the array has only size N?
    The answer is as follows: such a situation cannot occur because the
    algorithm finds a pairs of eigenvalues, therefore, if WI[i]&gt;0, I is
    strictly less than N-1.

Note 2:
    The algorithm performance depends on the value of the internal parameter
    NS of the InternalSchurDecomposition subroutine which defines the number
    of shifts in the QR algorithm (similarly to the block width in block-matrix
    algorithms of linear algebra). If you require maximum performance
    on your machine, it is recommended to adjust this parameter manually.


See also the InternalTREVC subroutine.

The algorithm is based on the LAPACK 3.0 library.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> rmatrixevd(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> vneeded,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wr,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wi,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; vl,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; vr);
</div></pre>
<a name='sub_smatrixevd'></a><h3><code>smatrixevd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding the eigenvalues and eigenvectors of a symmetric matrix

The algorithm finds eigen pairs of a symmetric matrix by reducing it to
tridiagonal form and using the QL/QR algorithm.

Input parameters:
    A       -   symmetric matrix which is given by its upper or lower
                triangular part.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.

Output parameters:
    D       -   eigenvalues in ascending order.
                Array whose index ranges within [0..N-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains the eigenvectors.
                Array whose indexes range within [0..N-1, 0..N-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged (rare case).

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixevd(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_smatrixevdi'></a><h3><code>smatrixevdi</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues and  eigenvectors  of  a  symmetric
matrix with given indexes by using bisection and inverse iteration methods.

Input parameters:
    A       -   symmetric matrix which is given by its upper or lower
                triangular part. Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    I1, I2 -    index interval for searching (from I1 to I2).
                0 &lt;= I1 &lt;= I2 &lt;= N-1.

Output parameters:
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..I2-I1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..I2-I1].
                In that case, the eigenvectors are stored in the matrix columns.

Result:
    True, if successful. W contains the eigenvalues, Z contains the
    eigenvectors (if needed).

    False, if the bisection method subroutine wasn't able to find the
    eigenvalues in the given interval or if the inverse iteration subroutine
    wasn't able to find all the corresponding eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned.

  -- ALGLIB --
     Copyright 07.01.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixevdi(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>bool</b> isupper,
    <b>int</b> i1,
    <b>int</b> i2,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_smatrixevdr'></a><h3><code>smatrixevdr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the eigenvalues (and eigenvectors) of  a  symmetric
matrix  in  a  given half open interval (A, B] by using  a  bisection  and
inverse iteration

Input parameters:
    A       -   symmetric matrix which is given by its upper or lower
                triangular part. Array [0..N-1, 0..N-1].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not returned;
                 * 1, the eigenvectors are returned.
    IsUpperA -  storage format of matrix A.
    B1, B2 -    half open interval (B1, B2] to search eigenvalues in.

Output parameters:
    M       -   number of eigenvalues found in a given half-interval (M&gt;=0).
    W       -   array of the eigenvalues found.
                Array whose index ranges within [0..M-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains eigenvectors.
                Array whose indexes range within [0..N-1, 0..M-1].
                The eigenvectors are stored in the matrix columns.

Result:
    True, if successful. M contains the number of eigenvalues in the given
    half-interval (could be equal to 0), W contains the eigenvalues,
    Z contains the eigenvectors (if needed).

    False, if the bisection method subroutine wasn't able to find the
    eigenvalues in the given interval or if the inverse iteration subroutine
    wasn't able to find all the corresponding eigenvectors.
    In that case, the eigenvalues and eigenvectors are not returned,
    M is equal to 0.

  -- ALGLIB --
     Copyright 07.01.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixevdr(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>bool</b> isupper,
    amp::ampf&lt;Precision&gt; b1,
    amp::ampf&lt;Precision&gt; b2,
    <b>int</b>&amp; m,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_smatrixtdevd'></a><h3><code>smatrixtdevd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Finding the eigenvalues and eigenvectors of a tridiagonal symmetric matrix

The algorithm finds the eigen pairs of a tridiagonal symmetric matrix by
using an QL/QR algorithm with implicit shifts.

Input parameters:
    D       -   the main diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-1].
    E       -   the secondary diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix A.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not needed;
                 * 1, the eigenvectors of a tridiagonal matrix
                   are multiplied by the square matrix Z. It is used if the
                   tridiagonal matrix is obtained by the similarity
                   transformation of a symmetric matrix;
                 * 2, the eigenvectors of a tridiagonal matrix replace the
                   square matrix Z;
                 * 3, matrix Z contains the first row of the eigenvectors
                   matrix.
    Z       -   if ZNeeded=1, Z contains the square matrix by which the
                eigenvectors are multiplied.
                Array whose indexes range within [0..N-1, 0..N-1].

Output parameters:
    D       -   eigenvalues in ascending order.
                Array whose index ranges within [0..N-1].
    Z       -   if ZNeeded is equal to:
                 * 0, Z hasnt changed;
                 * 1, Z contains the product of a given matrix (from the left)
                   and the eigenvectors matrix (from the right);
                 * 2, Z contains the eigenvectors.
                 * 3, Z contains the first row of the eigenvectors matrix.
                If ZNeeded&lt;3, Z is the array whose indexes range within [0..N-1, 0..N-1].
                In that case, the eigenvectors are stored in the matrix columns.
                If ZNeeded=3, Z is the array whose indexes range within [0..0, 0..N-1].

Result:
    True, if the algorithm has converged.
    False, if the algorithm hasn't converged.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixtdevd(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; e,
    <b>int</b> n,
    <b>int</b> zneeded,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_smatrixtdevdi'></a><h3><code>smatrixtdevdi</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding tridiagonal matrix eigenvalues/vectors with given
indexes (in ascending order) by using the bisection and inverse iteraion.

Input parameters:
    D       -   the main diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-1].
    E       -   the secondary diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix. N&gt;=0.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not needed;
                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
                   by the square matrix Z. It is used if the
                   tridiagonal matrix is obtained by the similarity transformation
                   of a symmetric matrix.
                 * 2, the eigenvectors of a tridiagonal matrix replace
                   matrix Z.
    I1, I2  -   index interval for searching (from I1 to I2).
                0 &lt;= I1 &lt;= I2 &lt;= N-1.
    Z       -   if ZNeeded is equal to:
                 * 0, Z isn't used and remains unchanged;
                 * 1, Z contains the square matrix (array whose indexes range within [0..N-1, 0..N-1])
                   which reduces the given symmetric matrix to  tridiagonal form;
                 * 2, Z isn't used (but changed on the exit).

Output parameters:
    D       -   array of the eigenvalues found.
                Array whose index ranges within [0..I2-I1].
    Z       -   if ZNeeded is equal to:
                 * 0, doesn't contain any information;
                 * 1, contains the product of a given NxN matrix Z (from the left) and
                   Nx(I2-I1) matrix of the eigenvectors found (from the right).
                   Array whose indexes range within [0..N-1, 0..I2-I1].
                 * 2, contains the matrix of the eigenvalues found.
                   Array whose indexes range within [0..N-1, 0..I2-I1].


Result:

    True, if successful. In that case, D contains the eigenvalues,
    Z contains the eigenvectors (if needed).
    It should be noted that the subroutine changes the size of arrays D and Z.

    False, if the bisection method subroutine wasn't able to find the eigenvalues
    in the given interval or if the inverse iteration subroutine wasn't able
    to find all the corresponding eigenvectors. In that case, the eigenvalues
    and eigenvectors are not returned.

  -- ALGLIB --
     Copyright 25.12.2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixtdevdi(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; e,
    <b>int</b> n,
    <b>int</b> zneeded,
    <b>int</b> i1,
    <b>int</b> i2,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_smatrixtdevdr'></a><h3><code>smatrixtdevdr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine for finding the tridiagonal matrix eigenvalues/vectors in a
given half-interval (A, B] by using bisection and inverse iteration.

Input parameters:
    D       -   the main diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-1].
    E       -   the secondary diagonal of a tridiagonal matrix.
                Array whose index ranges within [0..N-2].
    N       -   size of matrix, N&gt;=0.
    ZNeeded -   flag controlling whether the eigenvectors are needed or not.
                If ZNeeded is equal to:
                 * 0, the eigenvectors are not needed;
                 * 1, the eigenvectors of a tridiagonal matrix are multiplied
                   by the square matrix Z. It is used if the tridiagonal
                   matrix is obtained by the similarity transformation
                   of a symmetric matrix.
                 * 2, the eigenvectors of a tridiagonal matrix replace matrix Z.
    A, B    -   half-interval (A, B] to search eigenvalues in.
    Z       -   if ZNeeded is equal to:
                 * 0, Z isn't used and remains unchanged;
                 * 1, Z contains the square matrix (array whose indexes range
                   within [0..N-1, 0..N-1]) which reduces the given symmetric
                   matrix to tridiagonal form;
                 * 2, Z isn't used (but changed on the exit).

Output parameters:
    D       -   array of the eigenvalues found.
                Array whose index ranges within [0..M-1].
    M       -   number of eigenvalues found in the given half-interval (M&gt;=0).
    Z       -   if ZNeeded is equal to:
                 * 0, doesn't contain any information;
                 * 1, contains the product of a given NxN matrix Z (from the
                   left) and NxM matrix of the eigenvectors found (from the
                   right). Array whose indexes range within [0..N-1, 0..M-1].
                 * 2, contains the matrix of the eigenvectors found.
                   Array whose indexes range within [0..N-1, 0..M-1].

Result:

    True, if successful. In that case, M contains the number of eigenvalues
    in the given half-interval (could be equal to 0), D contains the eigenvalues,
    Z contains the eigenvectors (if needed).
    It should be noted that the subroutine changes the size of arrays D and Z.

    False, if the bisection method subroutine wasn't able to find the
    eigenvalues in the given interval or if the inverse iteration subroutine
    wasn't able to find all the corresponding eigenvectors. In that case,
    the eigenvalues and eigenvectors are not returned, M is equal to 0.

  -- ALGLIB --
     Copyright 31.03.2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixtdevdr(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; e,
    <b>int</b> n,
    <b>int</b> zneeded,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>int</b>&amp; m,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name=unit_fft></a><h2><code>fft</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_fftc1d' class=toc>fftc1d</a><br>
<a href='#sub_fftc1dinv' class=toc>fftc1dinv</a><br>
<a href='#sub_fftr1d' class=toc>fftr1d</a><br>
<a href='#sub_fftr1dinternaleven' class=toc>fftr1dinternaleven</a><br>
<a href='#sub_fftr1dinv' class=toc>fftr1dinv</a><br>
<a href='#sub_fftr1dinvinternaleven' class=toc>fftr1dinvinternaleven</a><br>
<a name='sub_fftc1d'></a><h3><code>fftc1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex FFT.

Array size N may be arbitrary number (composite or prime).  Composite  N's
are handled with cache-oblivious variation of  a  Cooley-Tukey  algorithm.
Small prime-factors are transformed using hard coded  codelets (similar to
FFTW codelets, but without low-level  optimization),  large  prime-factors
are handled with Bluestein's algorithm.

Fastests transforms are for smooth N's (prime factors are 2, 3,  5  only),
most fast for powers of 2. When N have prime factors  larger  than  these,
but orders of magnitude smaller than N, computations will be about 4 times
slower than for nearby highly composite N's. When N itself is prime, speed
will be 6 times lower.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - complex function to be transformed
    N   -   problem size
    
OUTPUT PARAMETERS
    A   -   DFT of a input array, array[0..N-1]
            A_out[j] = SUM(A_in[k]*exp(-2*pi*sqrt(-1)*j*k/N), k = 0..N-1)


  -- ALGLIB --
     Copyright 29.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fftc1d(ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name='sub_fftc1dinv'></a><h3><code>fftc1dinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional complex inverse FFT.

Array size N may be arbitrary number (composite or prime).  Algorithm  has
O(N*logN) complexity for any N (composite or prime).

See FFTC1D() description for more information about algorithm performance.

INPUT PARAMETERS
    A   -   array[0..N-1] - complex array to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    A   -   inverse DFT of a input array, array[0..N-1]
            A_out[j] = SUM(A_in[k]/N*exp(+2*pi*sqrt(-1)*j*k/N), k = 0..N-1)


  -- ALGLIB --
     Copyright 29.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fftc1dinv(ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name='sub_fftr1d'></a><h3><code>fftr1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real FFT.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - real function to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    F   -   DFT of a input array, array[0..N-1]
            F[j] = SUM(A[k]*exp(-2*pi*sqrt(-1)*j*k/N), k = 0..N-1)

NOTE:
    F[] satisfies symmetry property F[k] = conj(F[N-k]),  so just one half
of  array  is  usually needed. But for convinience subroutine returns full
complex array (with frequencies above N/2), so its result may be  used  by
other FFT-related subroutines.


  -- ALGLIB --
     Copyright 01.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fftr1d(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; f);
</div></pre>
<a name='sub_fftr1dinternaleven'></a><h3><code>fftr1dinternaleven</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Internal subroutine. Never call it directly!


  -- ALGLIB --
     Copyright 01.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fftr1dinternaleven(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; buf,
    ftbase::ftplan&lt;Precision&gt;&amp; plan);
</div></pre>
<a name='sub_fftr1dinv'></a><h3><code>fftr1dinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional real inverse FFT.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    F   -   array[0..floor(N/2)] - frequencies from forward real FFT
    N   -   problem size

OUTPUT PARAMETERS
    A   -   inverse DFT of a input array, array[0..N-1]

NOTE:
    F[] should satisfy symmetry property F[k] = conj(F[N-k]), so just  one
half of frequencies array is needed - elements from 0 to floor(N/2).  F[0]
is ALWAYS real. If N is even F[floor(N/2)] is real too. If N is odd,  then
F[floor(N/2)] has no special properties.

Relying on properties noted above, FFTR1DInv subroutine uses only elements
from 0th to floor(N/2)-th. It ignores imaginary part of F[0],  and in case
N is even it ignores imaginary part of F[floor(N/2)] too.  So you can pass
either frequencies array with N elements or reduced array with roughly N/2
elements - subroutine will successfully transform both.


  -- ALGLIB --
     Copyright 01.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fftr1dinv(<b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; f,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_fftr1dinvinternaleven'></a><h3><code>fftr1dinvinternaleven</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Internal subroutine. Never call it directly!


  -- ALGLIB --
     Copyright 01.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fftr1dinvinternaleven(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; buf,
    ftbase::ftplan&lt;Precision&gt;&amp; plan);
</div></pre>
<a name=unit_fht></a><h2><code>fht</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_fhtr1d' class=toc>fhtr1d</a><br>
<a href='#sub_fhtr1dinv' class=toc>fhtr1dinv</a><br>
<a name='sub_fhtr1d'></a><h3><code>fhtr1d</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional Fast Hartley Transform.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - real function to be transformed
    N   -   problem size
    
OUTPUT PARAMETERS
    A   -   FHT of a input array, array[0..N-1],
            A_out[k] = sum(A_in[j]*(cos(2*pi*j*k/N)+sin(2*pi*j*k/N)), j=0..N-1)


  -- ALGLIB --
     Copyright 04.06.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fhtr1d(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name='sub_fhtr1dinv'></a><h3><code>fhtr1dinv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional inverse FHT.

Algorithm has O(N*logN) complexity for any N (composite or prime).

INPUT PARAMETERS
    A   -   array[0..N-1] - complex array to be transformed
    N   -   problem size

OUTPUT PARAMETERS
    A   -   inverse FHT of a input array, array[0..N-1]


  -- ALGLIB --
     Copyright 29.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> fhtr1dinv(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name=unit_gkq></a><h2><code>gkq</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_gkqgenerategaussjacobi' class=toc>gkqgenerategaussjacobi</a><br>
<a href='#sub_gkqgenerategausslegendre' class=toc>gkqgenerategausslegendre</a><br>
<a href='#sub_gkqgeneraterec' class=toc>gkqgeneraterec</a><br>
<a href='#sub_gkqlegendrecalc' class=toc>gkqlegendrecalc</a><br>
<a href='#sub_gkqlegendretbl' class=toc>gkqlegendretbl</a><br>
<a name='sub_gkqgenerategaussjacobi'></a><h3><code>gkqgenerategaussjacobi</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns   Gauss   and   Gauss-Kronrod   nodes/weights   for   Gauss-Jacobi
quadrature on [-1,1] with weight function

    W(x)=Power(1-x,Alpha)*Power(1+x,Beta).

INPUT PARAMETERS:
    N           -   number of Kronrod nodes, must be odd number, &gt;=3.
    Alpha       -   power-law coefficient, Alpha&gt;-1
    Beta        -   power-law coefficient, Beta&gt;-1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -5    no real and positive Gauss-Kronrod formula can
                            be created for such a weight function  with  a
                            given number of nodes.
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes. Alpha or  Beta  are  too  close
                            to -1 to obtain weights/nodes with high enough
                            accuracy, or, may be, N is too large.  Try  to
                            use multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N was passed
                    * +1    OK
                    * +2    OK, but quadrature rule have exterior  nodes,
                            x[0]&lt;-1 or x[n-1]&gt;+1
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gkqgenerategaussjacobi(<b>int</b> n,
    amp::ampf&lt;Precision&gt; alpha,
    amp::ampf&lt;Precision&gt; beta,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wkronrod,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wgauss);
</div></pre>
<a name='sub_gkqgenerategausslegendre'></a><h3><code>gkqgenerategausslegendre</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns   Gauss   and   Gauss-Kronrod   nodes/weights  for  Gauss-Legendre
quadrature with N points.

GKQLegendreCalc (calculation) or  GKQLegendreTbl  (precomputed  table)  is
used depending on machine precision and number of nodes.

INPUT PARAMETERS:
    N           -   number of Kronrod nodes, must be odd number, &gt;=3.

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error   was   detected   when  calculating
                            weights/nodes.  N  is  too  large   to  obtain
                            weights/nodes  with  high   enough   accuracy.
                            Try  to   use   multiple   precision  version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gkqgenerategausslegendre(<b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wkronrod,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wgauss);
</div></pre>
<a name='sub_gkqgeneraterec'></a><h3><code>gkqgeneraterec</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights of a Gauss-Kronrod quadrature formula

The algorithm generates the N-point Gauss-Kronrod quadrature formula  with
weight  function  given  by  coefficients  alpha  and beta of a recurrence
relation which generates a system of orthogonal polynomials:

    P-1(x)   =  0
    P0(x)    =  1
    Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zero moment Mu0

    Mu0 = integral(W(x)dx,a,b)


INPUT PARAMETERS:
    Alpha          alpha coefficients, array[0..floor(3*K/2)].
    Beta           beta coefficients,  array[0..ceil(3*K/2)].
                    Beta[0] is not used and may be arbitrary.
                    Beta[I]&gt;0.
    Mu0            zeroth moment of the weight function.
    N              number of nodes of the Gauss-Kronrod quadrature formula,
                    N &gt;= 3,
                    N =  2*K+1.

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -5    no real and positive Gauss-Kronrod formula can
                            be created for such a weight function  with  a
                            given number of nodes.
                    * -4    N is too large, task may be ill  conditioned -
                            x[i]=x[i+1] found.
                    * -3    internal eigenproblem solver hasn't converged
                    * -2    Beta[i]&lt;=0
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).

  -- ALGLIB --
     Copyright 08.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gkqgeneraterec(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; alpha,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; beta,
    amp::ampf&lt;Precision&gt; mu0,
    <b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wkronrod,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wgauss);
</div></pre>
<a name='sub_gkqlegendrecalc'></a><h3><code>gkqlegendrecalc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns Gauss and Gauss-Kronrod nodes for quadrature with N points.

Reduction to tridiagonal eigenproblem is used.

INPUT PARAMETERS:
    N           -   number of Kronrod nodes, must be odd number, &gt;=3.

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error   was   detected   when  calculating
                            weights/nodes.  N  is  too  large   to  obtain
                            weights/nodes  with  high   enough   accuracy.
                            Try  to   use   multiple   precision  version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).

  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gkqlegendrecalc(<b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wkronrod,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wgauss);
</div></pre>
<a name='sub_gkqlegendretbl'></a><h3><code>gkqlegendretbl</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns Gauss and Gauss-Kronrod nodes for quadrature with N  points  using
pre-calculated table. Nodes/weights were  computed  with  accuracy  up  to
1.0E-32 (if MPFR version of ALGLIB is used). In standard double  precision
accuracy reduces to something about 2.0E-16 (depending  on your compiler's
handling of long floating point constants).

INPUT PARAMETERS:
    N           -   number of Kronrod nodes.
                    N can be 15, 21, 31, 41, 51, 61.

OUTPUT PARAMETERS:
    X           -   array[0..N-1] - array of quadrature nodes, ordered in
                    ascending order.
    WKronrod    -   array[0..N-1] - Kronrod weights
    WGauss      -   array[0..N-1] - Gauss weights (interleaved with zeros
                    corresponding to extended Kronrod nodes).


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gkqlegendretbl(<b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wkronrod,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; wgauss,
    amp::ampf&lt;Precision&gt;&amp; eps);
</div></pre>
<a name=unit_gq></a><h2><code>gq</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_gqgenerategausshermite' class=toc>gqgenerategausshermite</a><br>
<a href='#sub_gqgenerategaussjacobi' class=toc>gqgenerategaussjacobi</a><br>
<a href='#sub_gqgenerategausslaguerre' class=toc>gqgenerategausslaguerre</a><br>
<a href='#sub_gqgenerategausslegendre' class=toc>gqgenerategausslegendre</a><br>
<a href='#sub_gqgenerategausslobattorec' class=toc>gqgenerategausslobattorec</a><br>
<a href='#sub_gqgenerategaussradaurec' class=toc>gqgenerategaussradaurec</a><br>
<a href='#sub_gqgeneraterec' class=toc>gqgeneraterec</a><br>
<a name='sub_gqgenerategausshermite'></a><h3><code>gqgenerategausshermite</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns  nodes/weights  for  Gauss-Hermite  quadrature on (-inf,+inf) with
weight function W(x)=Exp(-x*x)

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes.  May be, N is too large. Try to
                            use multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N/Alpha was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgenerategausshermite(<b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_gqgenerategaussjacobi'></a><h3><code>gqgenerategaussjacobi</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns  nodes/weights  for  Gauss-Jacobi quadrature on [-1,1] with weight
function W(x)=Power(1-x,Alpha)*Power(1+x,Beta).

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1
    Alpha       -   power-law coefficient, Alpha&gt;-1
    Beta        -   power-law coefficient, Beta&gt;-1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes. Alpha or  Beta  are  too  close
                            to -1 to obtain weights/nodes with high enough
                            accuracy, or, may be, N is too large.  Try  to
                            use multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N/Alpha/Beta was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgenerategaussjacobi(<b>int</b> n,
    amp::ampf&lt;Precision&gt; alpha,
    amp::ampf&lt;Precision&gt; beta,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_gqgenerategausslaguerre'></a><h3><code>gqgenerategausslaguerre</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns  nodes/weights  for  Gauss-Laguerre  quadrature  on  [0,+inf) with
weight function W(x)=Power(x,Alpha)*Exp(-x)

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1
    Alpha       -   power-law coefficient, Alpha&gt;-1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error  was   detected   when   calculating
                            weights/nodes. Alpha is too  close  to  -1  to
                            obtain weights/nodes with high enough accuracy
                            or, may  be,  N  is  too  large.  Try  to  use
                            multiple precision version.
                    * -3    internal eigenproblem solver hasn't converged
                    * -1    incorrect N/Alpha was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgenerategausslaguerre(<b>int</b> n,
    amp::ampf&lt;Precision&gt; alpha,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_gqgenerategausslegendre'></a><h3><code>gqgenerategausslegendre</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Returns nodes/weights for Gauss-Legendre quadrature on [-1,1] with N
nodes.

INPUT PARAMETERS:
    N           -   number of nodes, &gt;=1

OUTPUT PARAMETERS:
    Info        -   error code:
                    * -4    an  error   was   detected   when  calculating
                            weights/nodes.  N  is  too  large   to  obtain
                            weights/nodes  with  high   enough   accuracy.
                            Try  to   use   multiple   precision  version.
                    * -3    internal eigenproblem solver hasn't  converged
                    * -1    incorrect N was passed
                    * +1    OK
    X           -   array[0..N-1] - array of quadrature nodes,
                    in ascending order.
    W           -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 12.05.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgenerategausslegendre(<b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_gqgenerategausslobattorec'></a><h3><code>gqgenerategausslobattorec</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights for a Gauss-Lobatto quadrature formula

The algorithm generates the N-point Gauss-Lobatto quadrature formula  with
weight function given by coefficients alpha and beta of a recurrence which
generates a system of orthogonal polynomials.

P-1(x)   =  0
P0(x)    =  1
Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zeroth moment Mu0

Mu0 = integral(W(x)dx,a,b)

INPUT PARAMETERS:
    Alpha      array[0..N-2], alpha coefficients
    Beta       array[0..N-2], beta coefficients.
                Zero-indexed element is not used, may be arbitrary.
                Beta[I]&gt;0
    Mu0        zeroth moment of the weighting function.
    A          left boundary of the integration interval.
    B          right boundary of the integration interval.
    N          number of nodes of the quadrature formula, N&gt;=3
                (including the left and right boundary nodes).

OUTPUT PARAMETERS:
    Info    -   error code:
                * -3    internal eigenproblem solver hasn't converged
                * -2    Beta[i]&lt;=0
                * -1    incorrect N was passed
                *  1    OK
    X       -   array[0..N-1] - array of quadrature nodes,
                in ascending order.
    W       -   array[0..N-1] - array of quadrature weights.

  -- ALGLIB --
     Copyright 2005-2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgenerategausslobattorec(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; alpha,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; beta,
    amp::ampf&lt;Precision&gt; mu0,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_gqgenerategaussradaurec'></a><h3><code>gqgenerategaussradaurec</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights for a Gauss-Radau quadrature formula

The algorithm generates the N-point Gauss-Radau  quadrature  formula  with
weight function given by the coefficients alpha and  beta  of a recurrence
which generates a system of orthogonal polynomials.

P-1(x)   =  0
P0(x)    =  1
Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zeroth moment Mu0

Mu0 = integral(W(x)dx,a,b)

INPUT PARAMETERS:
    Alpha      array[0..N-2], alpha coefficients.
    Beta       array[0..N-1], beta coefficients
                Zero-indexed element is not used.
                Beta[I]&gt;0
    Mu0        zeroth moment of the weighting function.
    A          left boundary of the integration interval.
    N          number of nodes of the quadrature formula, N&gt;=2
                (including the left boundary node).

OUTPUT PARAMETERS:
    Info    -   error code:
                * -3    internal eigenproblem solver hasn't converged
                * -2    Beta[i]&lt;=0
                * -1    incorrect N was passed
                *  1    OK
    X       -   array[0..N-1] - array of quadrature nodes,
                in ascending order.
    W       -   array[0..N-1] - array of quadrature weights.


  -- ALGLIB --
     Copyright 2005-2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgenerategaussradaurec(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; alpha,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; beta,
    amp::ampf&lt;Precision&gt; mu0,
    amp::ampf&lt;Precision&gt; a,
    <b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_gqgeneraterec'></a><h3><code>gqgeneraterec</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Computation of nodes and weights for a Gauss quadrature formula

The algorithm generates the N-point Gauss quadrature formula  with  weight
function given by coefficients alpha and beta  of  a  recurrence  relation
which generates a system of orthogonal polynomials:

P-1(x)   =  0
P0(x)    =  1
Pn+1(x)  =  (x-alpha(n))*Pn(x)  -  beta(n)*Pn-1(x)

and zeroth moment Mu0

Mu0 = integral(W(x)dx,a,b)

INPUT PARAMETERS:
    Alpha      array[0..N-1], alpha coefficients
    Beta       array[0..N-1], beta coefficients
                Zero-indexed element is not used and may be arbitrary.
                Beta[I]&gt;0.
    Mu0        zeroth moment of the weight function.
    N          number of nodes of the quadrature formula, N&gt;=1

OUTPUT PARAMETERS:
    Info    -   error code:
                * -3    internal eigenproblem solver hasn't converged
                * -2    Beta[i]&lt;=0
                * -1    incorrect N was passed
                *  1    OK
    X       -   array[0..N-1] - array of quadrature nodes,
                in ascending order.
    W       -   array[0..N-1] - array of quadrature weights.

  -- ALGLIB --
     Copyright 2005-2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> gqgeneraterec(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; alpha,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; beta,
    amp::ampf&lt;Precision&gt; mu0,
    <b>int</b> n,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name=unit_idwint></a><h2><code>idwint</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_idwinterpolant' class=toc>idwinterpolant</a><br>
<h3>Functions</h3>
<a href='#sub_idwbuildmodifiedshepard' class=toc>idwbuildmodifiedshepard</a><br>
<a href='#sub_idwbuildmodifiedshepardr' class=toc>idwbuildmodifiedshepardr</a><br>
<a href='#sub_idwbuildnoisy' class=toc>idwbuildnoisy</a><br>
<a href='#sub_idwcalc' class=toc>idwcalc</a><br>
<a name='struct_idwinterpolant'></a><h3><code>idwinterpolant</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolant.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> idwinterpolant
{
<b>public</b>:
    <b>int</b> n;
    <b>int</b> nx;
    <b>int</b> d;
    amp::ampf&lt;Precision&gt; r;
    <b>int</b> nw;
    nearestneighbor::kdtree&lt;Precision&gt; tree;
    <b>int</b> modeltype;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; q;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; xbuf;
    ap::template_1d_array&lt; <b>int</b> &gt; tbuf;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; rbuf;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; xybuf;
    <b>int</b> debugsolverfailures;
    amp::ampf&lt;Precision&gt; debugworstrcond;
    amp::ampf&lt;Precision&gt; debugbestrcond;
};
</div></pre>
<a name='sub_idwbuildmodifiedshepard'></a><h3><code>idwbuildmodifiedshepard</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolant using modified Shepard method for uniform point
distributions.

INPUT PARAMETERS:
    XY  -   X and Y values, array[0..N-1,0..NX].
            First NX columns contain X-values, last column contain
            Y-values.
    N   -   number of nodes, N&gt;0.
    NX  -   space dimension, NX&gt;=1.
    D   -   nodal function type, either:
            * 0     constant  model.  Just  for  demonstration only, worst
                    model ever.
            * 1     linear model, least squares fitting. Simpe  model  for
                    datasets too small for quadratic models
            * 2     quadratic  model,  least  squares  fitting. Best model
                    available (if your dataset is large enough).
            * -1    &quot;fast&quot;  linear  model,  use  with  caution!!!   It  is
                    significantly  faster than linear/quadratic and better
                    than constant model. But it is less robust (especially
                    in the presence of noise).
    NQ  -   number of points used to calculate  nodal  functions  (ignored
            for constant models). NQ should be LARGER than:
            * max(1.5*(1+NX),2^NX+1) for linear model,
            * max(3/4*(NX+2)*(NX+1),2^NX+1) for quadratic model.
            Values less than this threshold will be silently increased.
    NW  -   number of points used to calculate weights and to interpolate.
            Required: &gt;=2^NX+1, values less than this  threshold  will  be
            silently increased.
            Recommended value: about 2*NQ

OUTPUT PARAMETERS:
    Z   -   IDW interpolant.
    
NOTES:
  * best results are obtained with quadratic models, worst - with constant
    models
  * when N is large, NQ and NW must be significantly smaller than  N  both
    to obtain optimal performance and to obtain optimal accuracy. In 2  or
    3-dimensional tasks NQ=15 and NW=25 are good values to start with.
  * NQ  and  NW  may  be  greater  than  N.  In  such  cases  they will be
    automatically decreased.
  * this subroutine is always succeeds (as long as correct parameters  are
    passed).
  * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
    Robert J. Renka for more information on this algorithm.
  * this subroutine assumes that point distribution is uniform at the small
    scales.  If  it  isn't  -  for  example,  points are concentrated along
    &quot;lines&quot;, but &quot;lines&quot; distribution is uniform at the larger scale - then
    you should use IDWBuildModifiedShepardR()


  -- ALGLIB PROJECT --
     Copyright 02.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> idwbuildmodifiedshepard(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xy,
    <b>int</b> n,
    <b>int</b> nx,
    <b>int</b> d,
    <b>int</b> nq,
    <b>int</b> nw,
    idwinterpolant&lt;Precision&gt;&amp; z);
</div></pre>
<a name='sub_idwbuildmodifiedshepardr'></a><h3><code>idwbuildmodifiedshepardr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolant using modified Shepard method for non-uniform datasets.

This type of model uses  constant  nodal  functions and interpolates using
all nodes which are closer than user-specified radius R. It  may  be  used
when points distribution is non-uniform at the small scale, but it  is  at
the distances as large as R.

INPUT PARAMETERS:
    XY  -   X and Y values, array[0..N-1,0..NX].
            First NX columns contain X-values, last column contain
            Y-values.
    N   -   number of nodes, N&gt;0.
    NX  -   space dimension, NX&gt;=1.
    R   -   radius, R&gt;0

OUTPUT PARAMETERS:
    Z   -   IDW interpolant.

NOTES:
* if there is less than IDWKMin points within  R-ball,  algorithm  selects
  IDWKMin closest ones, so that continuity properties of  interpolant  are
  preserved even far from points.

  -- ALGLIB PROJECT --
     Copyright 11.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> idwbuildmodifiedshepardr(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xy,
    <b>int</b> n,
    <b>int</b> nx,
    amp::ampf&lt;Precision&gt; r,
    idwinterpolant&lt;Precision&gt;&amp; z);
</div></pre>
<a name='sub_idwbuildnoisy'></a><h3><code>idwbuildnoisy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW model for noisy data.

This subroutine may be used to handle noisy data, i.e. data with noise  in
OUTPUT values.  It differs from IDWBuildModifiedShepard() in the following
aspects:
* nodal functions are not constrained to pass through  nodes:  Qi(xi)&lt;&gt;yi,
  i.e. we have fitting  instead  of  interpolation.
* weights which are used during least  squares fitting stage are all equal
  to 1.0 (independently of distance)
* &quot;fast&quot;-linear or constant nodal functions are not supported (either  not
  robust enough or too rigid)

This problem require far more complex tuning than interpolation  problems.
Below you can find some recommendations regarding this problem:
* focus on tuning NQ; it controls noise reduction. As for NW, you can just
  make it equal to 2*NQ.
* you can use cross-validation to determine optimal NQ.
* optimal NQ is a result of complex tradeoff  between  noise  level  (more
  noise = larger NQ required) and underlying  function  complexity  (given
  fixed N, larger NQ means smoothing of compex features in the data).  For
  example, NQ=N will reduce noise to the minimum level possible,  but  you
  will end up with just constant/linear/quadratic (depending on  D)  least
  squares model for the whole dataset.

INPUT PARAMETERS:
    XY  -   X and Y values, array[0..N-1,0..NX].
            First NX columns contain X-values, last column contain
            Y-values.
    N   -   number of nodes, N&gt;0.
    NX  -   space dimension, NX&gt;=1.
    D   -   nodal function degree, either:
            * 1     linear model, least squares fitting. Simpe  model  for
                    datasets too small for quadratic models (or  for  very
                    noisy problems).
            * 2     quadratic  model,  least  squares  fitting. Best model
                    available (if your dataset is large enough).
    NQ  -   number of points used to calculate nodal functions.  NQ should
            be  significantly   larger   than  1.5  times  the  number  of
            coefficients in a nodal function to overcome effects of noise:
            * larger than 1.5*(1+NX) for linear model,
            * larger than 3/4*(NX+2)*(NX+1) for quadratic model.
            Values less than this threshold will be silently increased.
    NW  -   number of points used to calculate weights and to interpolate.
            Required: &gt;=2^NX+1, values less than this  threshold  will  be
            silently increased.
            Recommended value: about 2*NQ or larger

OUTPUT PARAMETERS:
    Z   -   IDW interpolant.

NOTES:
  * best results are obtained with quadratic models, linear models are not
    recommended to use unless you are pretty sure that it is what you want
  * this subroutine is always succeeds (as long as correct parameters  are
    passed).
  * see  'Multivariate  Interpolation  of Large Sets of Scattered Data' by
    Robert J. Renka for more information on this algorithm.


  -- ALGLIB PROJECT --
     Copyright 02.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> idwbuildnoisy(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xy,
    <b>int</b> n,
    <b>int</b> nx,
    <b>int</b> d,
    <b>int</b> nq,
    <b>int</b> nw,
    idwinterpolant&lt;Precision&gt;&amp; z);
</div></pre>
<a name='sub_idwcalc'></a><h3><code>idwcalc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
IDW interpolation

INPUT PARAMETERS:
    Z   -   IDW interpolant built with one of model building
            subroutines.
    X   -   array[0..NX-1], interpolation point

Result:
    IDW interpolant Z(X)

  -- ALGLIB --
     Copyright 02.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; idwcalc(idwinterpolant&lt;Precision&gt;&amp; z,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name=unit_inverseupdate></a><h2><code>inverseupdate</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_rmatrixinvupdatecolumn' class=toc>rmatrixinvupdatecolumn</a><br>
<a href='#sub_rmatrixinvupdaterow' class=toc>rmatrixinvupdaterow</a><br>
<a href='#sub_rmatrixinvupdatesimple' class=toc>rmatrixinvupdatesimple</a><br>
<a href='#sub_rmatrixinvupdateuv' class=toc>rmatrixinvupdateuv</a><br>
<a name='sub_rmatrixinvupdatecolumn'></a><h3><code>rmatrixinvupdatecolumn</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm updates matrix A^-1 when adding a vector to a column
of matrix A.

Input parameters:
    InvA        -   inverse of matrix A.
                    Array whose indexes range within [0..N-1, 0..N-1].
    N           -   size of matrix A.
    UpdColumn   -   the column of A whose vector U was added.
                    0 &lt;= UpdColumn &lt;= N-1
    U           -   the vector to be added to a column.
                    Array whose index ranges within [0..N-1].

Output parameters:
    InvA        -   inverse of modified matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixinvupdatecolumn(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; inva,
    <b>int</b> n,
    <b>int</b> updcolumn,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; u);
</div></pre>
<a name='sub_rmatrixinvupdaterow'></a><h3><code>rmatrixinvupdaterow</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm updates matrix A^-1 when adding a vector to a row
of matrix A.

Input parameters:
    InvA    -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    UpdRow  -   the row of A whose vector V was added.
                0 &lt;= Row &lt;= N-1
    V       -   the vector to be added to a row.
                Array whose index ranges within [0..N-1].

Output parameters:
    InvA    -   inverse of modified matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixinvupdaterow(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; inva,
    <b>int</b> n,
    <b>int</b> updrow,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; v);
</div></pre>
<a name='sub_rmatrixinvupdatesimple'></a><h3><code>rmatrixinvupdatesimple</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm updates matrix A^-1 when adding a number to an element
of matrix A.

Input parameters:
    InvA    -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    UpdRow  -   row where the element to be updated is stored.
    UpdColumn - column where the element to be updated is stored.
    UpdVal  -   a number to be added to the element.


Output parameters:
    InvA    -   inverse of modified matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixinvupdatesimple(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; inva,
    <b>int</b> n,
    <b>int</b> updrow,
    <b>int</b> updcolumn,
    amp::ampf&lt;Precision&gt; updval);
</div></pre>
<a name='sub_rmatrixinvupdateuv'></a><h3><code>rmatrixinvupdateuv</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inverse matrix update by the Sherman-Morrison formula

The algorithm computes the inverse of matrix A+u*v by using the given matrix
A^-1 and the vectors u and v.

Input parameters:
    InvA    -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].
    N       -   size of matrix A.
    U       -   the vector modifying the matrix.
                Array whose index ranges within [0..N-1].
    V       -   the vector modifying the matrix.
                Array whose index ranges within [0..N-1].

Output parameters:
    InvA - inverse of matrix A + u*v'.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixinvupdateuv(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; inva,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; u,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; v);
</div></pre>
<a name=unit_ldlt></a><h2><code>ldlt</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_smatrixldlt' class=toc>smatrixldlt</a><br>
<a name='sub_smatrixldlt'></a><h3><code>smatrixldlt</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LDLTDecomposition of a symmetric matrix

The algorithm represents a symmetric matrix (which is not necessarily
positive definite) as A=L*D*L' or A = U*D*U', where D is a block-diagonal
matrix with blocks 1x1 or 2x2, matrix L (matrix U) is a product of lower
(upper) triangular matrices with unit diagonal and permutation matrices.

Input parameters:
    A       -   factorized matrix, array with elements [0..N-1, 0..N-1].
                If IsUpper  True, then the upper triangle contains
                elements of symmetric matrix A, and the lower triangle is
                not used.
                The same applies if IsUpper = False.
    N       -   size of factorized matrix.
    IsUpper -   parameter which shows a method of matrix definition (lower
                or upper triangle).

Output parameters:
    A       -   matrices D and U, if IsUpper = True, or L, if IsUpper = False,
                in compact form, replacing the upper (lower) triangle of
                matrix A. In that case, the elements under (over) the main
                diagonal are not used nor modified.
    Pivots  -   tables of performed permutations (see below).

If IsUpper = True, then A = U*D*U', U = P(n)*U(n)*...*P(k)*U(k), where
P(k) is the permutation matrix, U(k) - upper triangular matrix with its
unit main diagonal and k decreases from n with step s which is equal to
1 or 2 (according to the size of the blocks of matrix D).

        (   I    v    0   )   k-s+1
U(k) =  (   0    I    0   )   s
        (   0    0    I   )   n-k-1
           k-s+1 s   n-k-1

If Pivots[k]&gt;=0, then s=1, P(k) - permutation of rows k and Pivots[k], the
vectorv forming matrix U(k) is stored in elements A(0:k-1,k), D(k) replaces
A(k,k). If Pivots[k]=Pivots[k-1]&lt;0 then s=2, P(k) - permutation of rows k-1
and N+Pivots[k-1], the vector v forming matrix U(k) is stored in elements
A(0:k-1,k:k+1), the upper triangle of block D(k) is stored in A(k,k),
A(k,k+1) and A(k+1,k+1).

If IsUpper = False, then A = L*D*L', L=P(0)*L(0)*...*P(k)*L(k), where P(k)
is the permutation matrix, L(k)  lower triangular matrix with unit main
diagonal and k decreases from 1 with step s which is equal to 1 or 2
(according to the size of the blocks of matrix D).

        (   I    0     0   )  k-1
L(k) =  (   0    I     0   )  s
        (   0    v     I   )  n-k-s+1
           k-1   s  n-k-s+1

If Pivots[k]&gt;=0 then s=1, P(k)  permutation of rows k and Pivots[k], the
vector v forming matrix L(k) is stored in elements A(k+1:n-1,k), D(k)
replaces A(k,k). If Pivots[k]=Pivots[k+1]&lt;0 then s=2, P(k) - permutation
of rows k+1 and N+Pivots[k+1], the vector v forming matrix L(k) is stored
in elements A(k+2:n-1,k:k+1), the lower triangle of block D(k) is stored in
A(k,k), A(k+1,k) and A(k+1,k+1).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     June 30, 1999
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> smatrixldlt(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots);
</div></pre>
<a name=unit_lsfit></a><h2><code>lsfit</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_lsfitreport' class=toc>lsfitreport</a><br>
<h3>Functions</h3>
<a href='#sub_lsfitlinear' class=toc>lsfitlinear</a><br>
<a href='#sub_lsfitlinearc' class=toc>lsfitlinearc</a><br>
<a href='#sub_lsfitlinearw' class=toc>lsfitlinearw</a><br>
<a href='#sub_lsfitlinearwc' class=toc>lsfitlinearwc</a><br>
<a href='#sub_lsfitnonlinearfg' class=toc>lsfitnonlinearfg</a><br>
<a href='#sub_lsfitnonlinearfgh' class=toc>lsfitnonlinearfgh</a><br>
<a href='#sub_lsfitnonlineariteration' class=toc>lsfitnonlineariteration</a><br>
<a href='#sub_lsfitnonlinearresults' class=toc>lsfitnonlinearresults</a><br>
<a href='#sub_lsfitnonlinearsetcond' class=toc>lsfitnonlinearsetcond</a><br>
<a href='#sub_lsfitnonlinearsetstpmax' class=toc>lsfitnonlinearsetstpmax</a><br>
<a href='#sub_lsfitnonlinearwfg' class=toc>lsfitnonlinearwfg</a><br>
<a href='#sub_lsfitnonlinearwfgh' class=toc>lsfitnonlinearwfgh</a><br>
<h3>Examples</h3>
<a href='#example_lsfit_linear' class=toc>lsfit_linear</a><br>
<a href='#example_lsfit_nonlinear' class=toc>lsfit_nonlinear</a><br>
<a href='#example_lsfit_nonlinear2' class=toc>lsfit_nonlinear2</a><br>
<a name='struct_lsfitreport'></a><h3><code>lsfitreport</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting report:
    TaskRCond       reciprocal of task's condition number
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> lsfitreport
{
<b>public</b>:
    amp::ampf&lt;Precision&gt; taskrcond;
    amp::ampf&lt;Precision&gt; rmserror;
    amp::ampf&lt;Precision&gt; avgerror;
    amp::ampf&lt;Precision&gt; avgrelerror;
    amp::ampf&lt;Precision&gt; maxerror;
};
</div></pre>
<a name='sub_lsfitlinear'></a><h3><code>lsfitlinear</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Linear least squares fitting, without weights.

See LSFitLinearW for more information.

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitlinear(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; fmatrix,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    lsfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_linear' class=nav>lsfit_linear</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearc'></a><h3><code>lsfitlinearc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Constained linear least squares fitting, without weights.

See LSFitLinearWC() for more information.

  -- ALGLIB --
     Copyright 07.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitlinearc(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; fmatrix,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; cmatrix,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b> k,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    lsfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_linear' class=nav>lsfit_linear</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearw'></a><h3><code>lsfitlinearw</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted linear least squares fitting.

QR decomposition is used to reduce task to MxM, then triangular solver  or
SVD-based solver is used depending on condition number of the  system.  It
allows to maximize speed and retain decent accuracy.

INPUT PARAMETERS:
    Y       -   array[0..N-1] Function values in  N  points.
    W       -   array[0..N-1]  Weights  corresponding to function  values.
                Each summand in square  sum  of  approximation  deviations
                from  given  values  is  multiplied  by  the   square   of
                corresponding weight.
    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                FMatrix[I, J] - value of J-th basis function in I-th point.
    N       -   number of points used. N&gt;=1.
    M       -   number of basis functions, M&gt;=1.

OUTPUT PARAMETERS:
    Info    -   error code:
                * -4    internal SVD decomposition subroutine failed (very
                        rare and for degenerate systems only)
                * -1    incorrect N/M were specified
                *  1    task is solved
    C       -   decomposition coefficients, array[0..M-1]
    Rep     -   fitting report. Following fields are set:
                * Rep.TaskRCond     reciprocal of condition number
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

SEE ALSO
    LSFitLinear
    LSFitLinearC
    LSFitLinearWC

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitlinearw(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; fmatrix,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    lsfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_linear' class=nav>lsfit_linear</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitlinearwc'></a><h3><code>lsfitlinearwc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted constained linear least squares fitting.

This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
that  K  additional  constaints  C*x=bc are satisfied. It reduces original
task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
is called.

INPUT PARAMETERS:
    Y       -   array[0..N-1] Function values in  N  points.
    W       -   array[0..N-1]  Weights  corresponding to function  values.
                Each summand in square  sum  of  approximation  deviations
                from  given  values  is  multiplied  by  the   square   of
                corresponding weight.
    FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                FMatrix[I,J] - value of J-th basis function in I-th point.
    CMatrix -   a table of constaints, array[0..K-1,0..M].
                I-th row of CMatrix corresponds to I-th linear constraint:
                CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
    N       -   number of points used. N&gt;=1.
    M       -   number of basis functions, M&gt;=1.
    K       -   number of constraints, 0 &lt;= K &lt; M
                K=0 corresponds to absence of constraints.

OUTPUT PARAMETERS:
    Info    -   error code:
                * -4    internal SVD decomposition subroutine failed (very
                        rare and for degenerate systems only)
                * -3    either   too   many  constraints  (M   or   more),
                        degenerate  constraints   (some   constraints  are
                        repetead twice) or inconsistent  constraints  were
                        specified.
                * -1    incorrect N/M/K were specified
                *  1    task is solved
    C       -   decomposition coefficients, array[0..M-1]
    Rep     -   fitting report. Following fields are set:
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

SEE ALSO
    LSFitLinear
    LSFitLinearC
    LSFitLinearWC

  -- ALGLIB --
     Copyright 07.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitlinearwc(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; fmatrix,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; cmatrix,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b> k,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    lsfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_linear' class=nav>lsfit_linear</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitnonlinearfg'></a><h3><code>lsfitnonlinearfg</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting, no individual weights.
See LSFitNonlinearWFG for more information.

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearfg(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b> k,
    <b>bool</b> cheapfg,
    lsfitstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_nonlinear' class=nav>lsfit_nonlinear</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitnonlinearfgh'></a><h3><code>lsfitnonlinearfgh</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting using gradient/Hessian without  individual
weights. See LSFitNonlinearWFGH() for more information.


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearfgh(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b> k,
    lsfitstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_nonlinear2' class=nav>lsfit_nonlinear2</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitnonlineariteration'></a><h3><code>lsfitnonlineariteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting. Algorithm iteration.

Called after inialization of the State structure with  LSFitNonlinearXXX()
subroutine. See HTML docs for examples.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between  subsequent
                calls and which is used for reverse communication. Must be
                initialized with LSFitNonlinearXXX() call first.

RESULT
1. If subroutine returned False, iterative algorithm has converged.
2. If subroutine returned True, then if:
* if State.NeedF=True,      function value F(X,C) is required
* if State.NeedFG=True,     function value F(X,C) and gradient  dF/dC(X,C)
                            are required
* if State.NeedFGH=True     function value F(X,C), gradient dF/dC(X,C) and
                            Hessian are required

One and only one of this fields can be set at time.

Function, its gradient and Hessian are calculated at  (X,C),  where  X  is
stored in State.X[0..M-1] and C is stored in State.C[0..K-1].

Results are stored:
* function value            -   in State.F
* gradient                  -   in State.G[0..K-1]
* Hessian                   -   in State.H[0..K-1,0..K-1]

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> lsfitnonlineariteration(lsfitstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_nonlinear' class=nav>lsfit_nonlinear</a>&nbsp;&nbsp;<a href='#example_lsfit_nonlinear2' class=nav>lsfit_nonlinear2</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitnonlinearresults'></a><h3><code>lsfitnonlinearresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Nonlinear least squares fitting results.

Called after LSFitNonlinearIteration() returned False.

INPUT PARAMETERS:
    State   -   algorithm state (used by LSFitNonlinearIteration).

OUTPUT PARAMETERS:
    Info    -   completetion code:
                    * -1    incorrect parameters were specified
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
    C       -   array[0..K-1], solution
    Rep     -   optimization report. Following fields are set:
                * Rep.TerminationType completetion code:
                * RMSError          rms error on the (X,Y).
                * AvgError          average error on the (X,Y).
                * AvgRelError       average relative error on the non-zero Y
                * MaxError          maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearresults(<b>const</b> lsfitstate&lt;Precision&gt;&amp; state,
    <b>int</b>&amp; info,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    lsfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_nonlinear' class=nav>lsfit_nonlinear</a>&nbsp;&nbsp;<a href='#example_lsfit_nonlinear2' class=nav>lsfit_nonlinear2</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitnonlinearsetcond'></a><h3><code>lsfitnonlinearsetcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Stopping conditions for nonlinear least squares fitting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with LSFitNonLinearCreate???()
    EpsF    -   stopping criterion. Algorithm stops if
                |F(k+1)-F(k)| &lt;= EpsF*max{|F(k)|, |F(k+1)|, 1}
    EpsX    -   stopping criterion. Algorithm stops if
                |X(k+1)-X(k)| &lt;= EpsX*(1+|X(k)|)
    MaxIts  -   stopping criterion. Algorithm stops after MaxIts iterations.
                MaxIts=0 means no stopping criterion.

NOTE

Passing EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to automatic
stopping criterion selection (according to the scheme used by MINLM unit).


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearsetcond(lsfitstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; epsf,
    amp::ampf&lt;Precision&gt; epsx,
    <b>int</b> maxits);
</div></pre>
<a name='sub_lsfitnonlinearsetstpmax'></a><h3><code>lsfitnonlinearsetstpmax</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with LSFitNonLinearCreate???()
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

NOTE: non-zero StpMax leads to moderate  performance  degradation  because
intermediate  step  of  preconditioned L-BFGS optimization is incompatible
with limits on step size.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearsetstpmax(lsfitstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; stpmax);
</div></pre>
<a name='sub_lsfitnonlinearwfg'></a><h3><code>lsfitnonlinearwfg</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted nonlinear least squares fitting using gradient and Hessian.

Nonlinear task min(F(c)) is solved, where

    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,
    
    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * w is an N-dimensional vector of weight coefficients,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted
    
This subroutine uses only f(x[i],c) and its gradient.
    
INPUT PARAMETERS:
    X       -   array[0..N-1,0..M-1], points (one row = one point)
    Y       -   array[0..N-1], function values.
    W       -   weights, array[0..N-1]
    C       -   array[0..K-1], initial approximation to the solution,
    N       -   number of points, N&gt;1
    M       -   dimension of space
    K       -   number of parameters being fitted
    CheapFG -   boolean flag, which is:
                * True  if both function and gradient calculation complexity
                        are less than O(M^2).  An improved  algorithm  can
                        be  used  which corresponds  to  FGJ  scheme  from
                        MINLM unit.
                * False otherwise.
                        Standard Jacibian-bases  Levenberg-Marquardt  algo
                        will be used (FJ scheme).

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state between subsequent
                calls  of   LSFitNonlinearIteration.   Used  for  reverse
                communication.  This  structure   should   be  passed  to
                LSFitNonlinearIteration subroutine.

See also:
    LSFitNonlinearIteration
    LSFitNonlinearResults
    LSFitNonlinearFG (fitting without weights)
    LSFitNonlinearWFGH (fitting using Hessian)
    LSFitNonlinearFGH (fitting using Hessian, without weights)


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearwfg(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b> k,
    <b>bool</b> cheapfg,
    lsfitstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_nonlinear' class=nav>lsfit_nonlinear</a>&nbsp;&nbsp;</p>
<a name='sub_lsfitnonlinearwfgh'></a><h3><code>lsfitnonlinearwfgh</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted nonlinear least squares fitting using gradient/Hessian.

Nonlinear task min(F(c)) is solved, where

    F(c) = (w[0]*(f(x[0],c)-y[0]))^2 + ... + (w[n-1]*(f(x[n-1],c)-y[n-1]))^2,

    * N is a number of points,
    * M is a dimension of a space points belong to,
    * K is a dimension of a space of parameters being fitted,
    * w is an N-dimensional vector of weight coefficients,
    * x is a set of N points, each of them is an M-dimensional vector,
    * c is a K-dimensional vector of parameters being fitted

This subroutine uses f(x[i],c), its gradient and its Hessian.

See LSFitNonlinearWFG() subroutine for information about function
parameters.

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> lsfitnonlinearwfgh(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; c,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b> k,
    lsfitstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_lsfit_nonlinear2' class=nav>lsfit_nonlinear2</a>&nbsp;&nbsp;</p>
<a name='example_lsfit_linear'></a><h3>lsfit_linear example</h3>
<pre>
    <b>int</b> m;
    <b>int</b> n;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; fmatrix;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; cmatrix;
    lsfit::lsfitreport&lt;Precision&gt; rep;
    <b>int</b> info;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; c;
    <b>int</b> i;
    <b>int</b> j;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;


    printf(<font color=blue>&quot;\n\nFitting tan(x) by third degree polynomial\n\n&quot;</font>);
    printf(<font color=blue>&quot;Fit type             rms.err max.err    p(0)   dp(0)\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Fitting tan(x) at [0, 0.4*pi] by third degree polynomial:</font>
<font color=navy>    // a) without constraints</font>
<font color=navy>    // b) constrained at x=0: p(0)=0</font>
<font color=navy>    // c) constrained at x=0: p'(0)=1</font>
<font color=navy>    // c) constrained at x=0: p(0)=0, p'(0)=1</font>
<font color=navy>    //</font>
    m = 4;
    n = 100;
    a = 0;
    b = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.4&quot;</font>)*amp::pi&lt;Precision&gt;();
    
<font color=navy>    //</font>
<font color=navy>    // Prepare task matrix</font>
<font color=navy>    //</font>
    y.setlength(n);
    fmatrix.setlength(n, m);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x = a+(b-a)*i/(n-1);
        y(i) = amp::tan&lt;Precision&gt;(x);
        fmatrix(i,0) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
        <b>for</b>(j=1; j&lt;=m-1; j++)
        {
            fmatrix(i,j) = x*fmatrix(i,j-1);
        }
    }
    
<font color=navy>    //</font>
<font color=navy>    // Solve unconstrained task</font>
<font color=navy>    //</font>
    lsfit::lsfitlinear&lt;Precision&gt;(y, fmatrix, n, m, info, c, rep);
    printf(<font color=blue>&quot;Unconstrained        %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(0)).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(1)).toDouble()));
    
<font color=navy>    //</font>
<font color=navy>    // Solve constrained task, p(0)=0</font>
<font color=navy>    // Prepare constraints matrix:</font>
<font color=navy>    // * first M columns store values of basis functions at X=0</font>
<font color=navy>    // * last column stores zero (desired value at X=0)</font>
<font color=navy>    //</font>
    cmatrix.setlength(1, m+1);
    cmatrix(0,0) = 1;
    <b>for</b>(i=1; i&lt;=m-1; i++)
    {
        cmatrix(0,i) = 0;
    }
    cmatrix(0,m) = 0;
    lsfit::lsfitlinearc&lt;Precision&gt;(y, fmatrix, cmatrix, n, m, 1, info, c, rep);
    printf(<font color=blue>&quot;Constrained, p(0)=0  %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(0)).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(1)).toDouble()));
    
<font color=navy>    //</font>
<font color=navy>    // Solve constrained task, p'(0)=0</font>
<font color=navy>    // Prepare constraints matrix:</font>
<font color=navy>    // * first M columns store derivatives of basis functions at X=0</font>
<font color=navy>    // * last column stores 1.0 (desired derivative at X=0)</font>
<font color=navy>    //</font>
    cmatrix.setlength(1, m+1);
    <b>for</b>(i=0; i&lt;=m-1; i++)
    {
        cmatrix(0,i) = 0;
    }
    cmatrix(0,1) = 1;
    cmatrix(0,m) = 1;
    lsfit::lsfitlinearc&lt;Precision&gt;(y, fmatrix, cmatrix, n, m, 1, info, c, rep);
    printf(<font color=blue>&quot;Constrained, dp(0)=1 %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(0)).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(1)).toDouble()));
    
<font color=navy>    //</font>
<font color=navy>    // Solve constrained task, p(0)=0, p'(0)=0</font>
<font color=navy>    // Prepare constraints matrix:</font>
<font color=navy>    // * first M columns store values/derivatives of basis functions at X=0</font>
<font color=navy>    // * last column stores desired values/derivative at X=0</font>
<font color=navy>    //</font>
    cmatrix.setlength(2, m+1);
    cmatrix(0,0) = 1;
    <b>for</b>(i=1; i&lt;=m-1; i++)
    {
        cmatrix(0,i) = 0;
    }
    cmatrix(0,m) = 0;
    <b>for</b>(i=0; i&lt;=m-1; i++)
    {
        cmatrix(1,i) = 0;
    }
    cmatrix(1,1) = 1;
    cmatrix(1,m) = 1;
    lsfit::lsfitlinearc&lt;Precision&gt;(y, fmatrix, cmatrix, n, m, 2, info, c, rep);
    printf(<font color=blue>&quot;Constrained, both    %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(0)).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(1)).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_lsfit_nonlinear'></a><h3>lsfit_nonlinear example</h3>
<pre>
    <b>int</b> m;
    <b>int</b> n;
    <b>int</b> k;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; c;
    lsfit::lsfitreport&lt;Precision&gt; rep;
    lsfit::lsfitstate&lt;Precision&gt; state;
    <b>int</b> info;
    amp::ampf&lt;Precision&gt; epsf;
    amp::ampf&lt;Precision&gt; epsx;
    <b>int</b> maxits;
    <b>int</b> i;
    <b>int</b> j;
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;


    printf(<font color=blue>&quot;Fitting 0.5(1+cos(x)) on [-pi,+pi] with exp(-alpha*x^2)\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Fitting 0.5(1+cos(x)) on [-pi,+pi] with Gaussian exp(-alpha*x^2):</font>
<font color=navy>    // * without Hessian (gradient only)</font>
<font color=navy>    // * using alpha=1 as initial value</font>
<font color=navy>    // * using 1000 uniformly distributed points to fit to</font>
<font color=navy>    //</font>
<font color=navy>    // Notes:</font>
<font color=navy>    // * N - number of points</font>
<font color=navy>    // * M - dimension of space where points reside</font>
<font color=navy>    // * K - number of parameters being fitted</font>
<font color=navy>    //</font>
    n = 1000;
    m = 1;
    k = 1;
    a = -amp::pi&lt;Precision&gt;();
    b = +amp::pi&lt;Precision&gt;();
    
<font color=navy>    //</font>
<font color=navy>    // Prepare task matrix</font>
<font color=navy>    //</font>
    y.setlength(n);
    x.setlength(n, m);
    c.setlength(k);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i,0) = a+(b-a)*i/(n-1);
        y(i) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>)*(1+amp::cos&lt;Precision&gt;(x(i,0)));
    }
    c(0) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
    epsf = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>);
    epsx = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0001&quot;</font>);
    maxits = 0;
    
<font color=navy>    //</font>
<font color=navy>    // Solve</font>
<font color=navy>    //</font>
    lsfit::lsfitnonlinearfg&lt;Precision&gt;(x, y, c, n, m, k, true, state);
    lsfit::lsfitnonlinearsetcond&lt;Precision&gt;(state, epsf, epsx, maxits);
    <b>while</b>( lsfit::lsfitnonlineariteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needf )
        {
            
<font color=navy>            //</font>
<font color=navy>            // F(x) = Exp(-alpha*x^2)</font>
<font color=navy>            //</font>
            state.f = amp::exp&lt;Precision&gt;(-state.c(0)*amp::sqr&lt;Precision&gt;(state.x(0)));
        }
        <b>if</b>( state.needfg )
        {
            
<font color=navy>            //</font>
<font color=navy>            // F(x)      = Exp(-alpha*x^2)</font>
<font color=navy>            // dF/dAlpha = (-x^2)*Exp(-alpha*x^2)</font>
<font color=navy>            //</font>
            state.f = amp::exp&lt;Precision&gt;(-state.c(0)*amp::sqr&lt;Precision&gt;(state.x(0)));
            state.g(0) = -amp::sqr&lt;Precision&gt;(state.x(0))*state.f;
        }
    }
    lsfit::lsfitnonlinearresults&lt;Precision&gt;(state, info, c, rep);
    printf(<font color=blue>&quot;alpha:   %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(0)).toDouble()));
    printf(<font color=blue>&quot;rms.err: %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()));
    printf(<font color=blue>&quot;max.err: %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()));
    printf(<font color=blue>&quot;Termination type: %0ld\n&quot;</font>,
        <b>long</b>(info));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_lsfit_nonlinear2'></a><h3>lsfit_nonlinear2 example</h3>
<pre>
    <b>int</b> m;
    <b>int</b> n;
    <b>int</b> k;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; c;
    lsfit::lsfitreport&lt;Precision&gt; rep;
    lsfit::lsfitstate&lt;Precision&gt; state;
    <b>int</b> info;
    amp::ampf&lt;Precision&gt; epsf;
    amp::ampf&lt;Precision&gt; epsx;
    <b>int</b> maxits;
    <b>int</b> i;
    <b>int</b> j;
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;


    printf(<font color=blue>&quot;Fitting 1-x^2 on [-1,+1] with cos(alpha*pi*x)+beta\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Fitting 1-x^2 on [-1,+1] with cos(alpha*pi*x)+beta:</font>
<font color=navy>    // * using Hessian</font>
<font color=navy>    // * using alpha=1 and beta=0 as initial values</font>
<font color=navy>    // * using 1000 uniformly distributed points to fit to</font>
<font color=navy>    //</font>
<font color=navy>    // Notes:</font>
<font color=navy>    // * N - number of points</font>
<font color=navy>    // * M - dimension of space where points reside</font>
<font color=navy>    // * K - number of parameters being fitted</font>
<font color=navy>    //</font>
    n = 1000;
    m = 1;
    k = 2;
    a = -1;
    b = +1;
    
<font color=navy>    //</font>
<font color=navy>    // Prepare task matrix</font>
<font color=navy>    //</font>
    y.setlength(n);
    x.setlength(n, m);
    c.setlength(k);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i,0) = a+(b-a)*i/(n-1);
        y(i) = 1-amp::sqr&lt;Precision&gt;(x(i,0));
    }
    c(0) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
    c(1) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>);
    epsf = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>);
    epsx = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0001&quot;</font>);
    maxits = 0;
    
<font color=navy>    //</font>
<font color=navy>    // Solve</font>
<font color=navy>    //</font>
    lsfit::lsfitnonlinearfgh&lt;Precision&gt;(x, y, c, n, m, k, state);
    lsfit::lsfitnonlinearsetcond&lt;Precision&gt;(state, epsf, epsx, maxits);
    <b>while</b>( lsfit::lsfitnonlineariteration&lt;Precision&gt;(state) )
    {
        
<font color=navy>        //</font>
<font color=navy>        // F(x) = Cos(alpha*pi*x)+beta</font>
<font color=navy>        //</font>
        state.f = amp::cos&lt;Precision&gt;(state.c(0)*amp::pi&lt;Precision&gt;()*state.x(0))+state.c(1);
        
<font color=navy>        //</font>
<font color=navy>        // F(x)      = Cos(alpha*pi*x)+beta</font>
<font color=navy>        // dF/dAlpha = -pi*x*Sin(alpha*pi*x)</font>
<font color=navy>        // dF/dBeta  = 1.0</font>
<font color=navy>        //</font>
        <b>if</b>( state.needfg || state.needfgh )
        {
            state.g(0) = -amp::pi&lt;Precision&gt;()*state.x(0)*amp::sin&lt;Precision&gt;(state.c(0)*amp::pi&lt;Precision&gt;()*state.x(0));
            state.g(1) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
        }
        
<font color=navy>        //</font>
<font color=navy>        // F(x)            = Cos(alpha*pi*x)+beta</font>
<font color=navy>        // d2F/dAlpha2     = -(pi*x)^2*Cos(alpha*pi*x)</font>
<font color=navy>        // d2F/dAlphadBeta = 0</font>
<font color=navy>        // d2F/dBeta2     =  0</font>
<font color=navy>        //</font>
        <b>if</b>( state.needfgh )
        {
            state.h(0,0) = -amp::sqr&lt;Precision&gt;(amp::pi&lt;Precision&gt;()*state.x(0))*amp::cos&lt;Precision&gt;(state.c(0)*amp::pi&lt;Precision&gt;()*state.x(0));
            state.h(0,1) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>);
            state.h(1,0) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>);
            state.h(1,1) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>);
        }
    }
    lsfit::lsfitnonlinearresults&lt;Precision&gt;(state, info, c, rep);
    printf(<font color=blue>&quot;alpha:   %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(0)).toDouble()));
    printf(<font color=blue>&quot;beta:    %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(c(1)).toDouble()));
    printf(<font color=blue>&quot;rms.err: %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()));
    printf(<font color=blue>&quot;max.err: %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()));
    printf(<font color=blue>&quot;Termination type: %0ld\n&quot;</font>,
        <b>long</b>(info));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name=unit_matdet></a><h2><code>matdet</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixdet' class=toc>cmatrixdet</a><br>
<a href='#sub_cmatrixludet' class=toc>cmatrixludet</a><br>
<a href='#sub_rmatrixdet' class=toc>rmatrixdet</a><br>
<a href='#sub_rmatrixludet' class=toc>rmatrixludet</a><br>
<a href='#sub_spdmatrixcholeskydet' class=toc>spdmatrixcholeskydet</a><br>
<a href='#sub_spdmatrixdet' class=toc>spdmatrixdet</a><br>
<a name='sub_cmatrixdet'></a><h3><code>cmatrixdet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the determinant of a general matrix

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1]
    N       -   size of matrix A.

Result: determinant of matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::campf&lt;Precision&gt; cmatrixdet(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n);
</div></pre>
<a name='sub_cmatrixludet'></a><h3><code>cmatrixludet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by its LU decomposition.

Input parameters:
    A       -   LU decomposition of the matrix (output of
                RMatrixLU subroutine).
    Pivots  -   table of permutations which were made during
                the LU decomposition.
                Output of RMatrixLU subroutine.
    N       -   size of matrix A.

Result: matrix determinant.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::campf&lt;Precision&gt; cmatrixludet(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n);
</div></pre>
<a name='sub_rmatrixdet'></a><h3><code>rmatrixdet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Calculation of the determinant of a general matrix

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1]
    N       -   size of matrix A.

Result: determinant of matrix A.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixdet(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n);
</div></pre>
<a name='sub_rmatrixludet'></a><h3><code>rmatrixludet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by its LU decomposition.

Input parameters:
    A       -   LU decomposition of the matrix (output of
                RMatrixLU subroutine).
    Pivots  -   table of permutations which were made during
                the LU decomposition.
                Output of RMatrixLU subroutine.
    N       -   size of matrix A.

Result: matrix determinant.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixludet(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n);
</div></pre>
<a name='sub_spdmatrixcholeskydet'></a><h3><code>spdmatrixcholeskydet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by the Cholesky decomposition.

Input parameters:
    A   -   Cholesky decomposition,
            output of SMatrixCholesky subroutine.
    N   -   size of matrix A.

As the determinant is equal to the product of squares of diagonal elements,
its not necessary to specify which triangle - lower or upper - the matrix
is stored in.

Result:
    matrix determinant.

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spdmatrixcholeskydet(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name='sub_spdmatrixdet'></a><h3><code>spdmatrixdet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the symmetric positive definite matrix.

Input parameters:
    A       -   matrix. Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   if IsUpper = True, then the symmetric matrix A is given by
                its upper triangle, and the lower triangle isnt used by
                subroutine. Similarly, if IsUpper = False, then A is given
                by its lower triangle.

Result:
    determinant of matrix A.
    If matrix A is not positive definite, then subroutine returns -1.

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spdmatrixdet(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name=unit_matgen></a><h2><code>matgen</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixrndcond' class=toc>cmatrixrndcond</a><br>
<a href='#sub_cmatrixrndorthogonal' class=toc>cmatrixrndorthogonal</a><br>
<a href='#sub_cmatrixrndorthogonalfromtheleft' class=toc>cmatrixrndorthogonalfromtheleft</a><br>
<a href='#sub_cmatrixrndorthogonalfromtheright' class=toc>cmatrixrndorthogonalfromtheright</a><br>
<a href='#sub_hmatrixrndcond' class=toc>hmatrixrndcond</a><br>
<a href='#sub_hmatrixrndmultiply' class=toc>hmatrixrndmultiply</a><br>
<a href='#sub_hpdmatrixrndcond' class=toc>hpdmatrixrndcond</a><br>
<a href='#sub_rmatrixrndcond' class=toc>rmatrixrndcond</a><br>
<a href='#sub_rmatrixrndorthogonal' class=toc>rmatrixrndorthogonal</a><br>
<a href='#sub_rmatrixrndorthogonalfromtheleft' class=toc>rmatrixrndorthogonalfromtheleft</a><br>
<a href='#sub_rmatrixrndorthogonalfromtheright' class=toc>rmatrixrndorthogonalfromtheright</a><br>
<a href='#sub_smatrixrndcond' class=toc>smatrixrndcond</a><br>
<a href='#sub_smatrixrndmultiply' class=toc>smatrixrndmultiply</a><br>
<a href='#sub_spdmatrixrndcond' class=toc>spdmatrixrndcond</a><br>
<a name='sub_cmatrixrndcond'></a><h3><code>cmatrixrndcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN complex matrix with given condition number C and
norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixrndcond(<b>int</b> n,
    amp::ampf&lt;Precision&gt; c,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_cmatrixrndorthogonal'></a><h3><code>cmatrixrndorthogonal</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of a random Haar distributed orthogonal complex matrix

INPUT PARAMETERS:
    N   -   matrix size, N&gt;=1

OUTPUT PARAMETERS:
    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixrndorthogonal(<b>int</b> n,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_cmatrixrndorthogonalfromtheleft'></a><h3><code>cmatrixrndorthogonalfromtheleft</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN complex matrix by MxM random Haar distributed
complex orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   Q*A, where Q is random MxM orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixrndorthogonalfromtheleft(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n);
</div></pre>
<a name='sub_cmatrixrndorthogonalfromtheright'></a><h3><code>cmatrixrndorthogonalfromtheright</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN complex matrix by NxN random Haar distributed
complex orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixrndorthogonalfromtheright(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n);
</div></pre>
<a name='sub_hmatrixrndcond'></a><h3><code>hmatrixrndcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN Hermitian matrix with given condition number  and
norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hmatrixrndcond(<b>int</b> n,
    amp::ampf&lt;Precision&gt; c,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_hmatrixrndmultiply'></a><h3><code>hmatrixrndmultiply</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Hermitian multiplication of NxN matrix by random Haar distributed
complex orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..N-1, 0..N-1]
    N   -   matrix size

OUTPUT PARAMETERS:
    A   -   Q^H*A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hmatrixrndmultiply(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name='sub_hpdmatrixrndcond'></a><h3><code>hpdmatrixrndcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN Hermitian positive definite matrix with given
condition number and norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random HPD matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixrndcond(<b>int</b> n,
    amp::ampf&lt;Precision&gt; c,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_rmatrixrndcond'></a><h3><code>rmatrixrndcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN matrix with given condition number and norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixrndcond(<b>int</b> n,
    amp::ampf&lt;Precision&gt; c,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_rmatrixrndorthogonal'></a><h3><code>rmatrixrndorthogonal</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of a random uniformly distributed (Haar) orthogonal matrix

INPUT PARAMETERS:
    N   -   matrix size, N&gt;=1
    
OUTPUT PARAMETERS:
    A   -   orthogonal NxN matrix, array[0..N-1,0..N-1]

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixrndorthogonal(<b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_rmatrixrndorthogonalfromtheleft'></a><h3><code>rmatrixrndorthogonalfromtheleft</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN matrix by MxM random Haar distributed orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   Q*A, where Q is random MxM orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixrndorthogonalfromtheleft(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n);
</div></pre>
<a name='sub_rmatrixrndorthogonalfromtheright'></a><h3><code>rmatrixrndorthogonalfromtheright</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication of MxN matrix by NxN random Haar distributed orthogonal matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..M-1, 0..N-1]
    M, N-   matrix size

OUTPUT PARAMETERS:
    A   -   A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixrndorthogonalfromtheright(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n);
</div></pre>
<a name='sub_smatrixrndcond'></a><h3><code>smatrixrndcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN symmetric matrix with given condition number  and
norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> smatrixrndcond(<b>int</b> n,
    amp::ampf&lt;Precision&gt; c,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name='sub_smatrixrndmultiply'></a><h3><code>smatrixrndmultiply</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Symmetric multiplication of NxN matrix by random Haar distributed
orthogonal  matrix

INPUT PARAMETERS:
    A   -   matrix, array[0..N-1, 0..N-1]
    N   -   matrix size

OUTPUT PARAMETERS:
    A   -   Q'*A*Q, where Q is random NxN orthogonal matrix

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> smatrixrndmultiply(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n);
</div></pre>
<a name='sub_spdmatrixrndcond'></a><h3><code>spdmatrixrndcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Generation of random NxN symmetric positive definite matrix with given
condition number and norm2(A)=1

INPUT PARAMETERS:
    N   -   matrix size
    C   -   condition number (in 2-norm)

OUTPUT PARAMETERS:
    A   -   random SPD matrix with norm2(A)=1 and cond(A)=C

  -- ALGLIB routine --
     04.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixrndcond(<b>int</b> n,
    amp::ampf&lt;Precision&gt; c,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a);
</div></pre>
<a name=unit_matinv></a><h2><code>matinv</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixinverse' class=toc>cmatrixinverse</a><br>
<a href='#sub_cmatrixluinverse' class=toc>cmatrixluinverse</a><br>
<a href='#sub_cmatrixtrinverse' class=toc>cmatrixtrinverse</a><br>
<a href='#sub_hpdmatrixcholeskyinverse' class=toc>hpdmatrixcholeskyinverse</a><br>
<a href='#sub_hpdmatrixinverse' class=toc>hpdmatrixinverse</a><br>
<a href='#sub_rmatrixinverse' class=toc>rmatrixinverse</a><br>
<a href='#sub_rmatrixluinverse' class=toc>rmatrixluinverse</a><br>
<a href='#sub_rmatrixtrinverse' class=toc>rmatrixtrinverse</a><br>
<a href='#sub_spdmatrixcholeskyinverse' class=toc>spdmatrixcholeskyinverse</a><br>
<a href='#sub_spdmatrixinverse' class=toc>spdmatrixinverse</a><br>
<a name='sub_cmatrixinverse'></a><h3><code>cmatrixinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a general matrix.

Input parameters:
    A   -   matrix, array[0..N-1,0..N-1].
    N   -   size of A.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixinverse(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_cmatrixluinverse'></a><h3><code>cmatrixluinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a matrix given by its LU decomposition.

INPUT PARAMETERS:
    A       -   LU decomposition of the matrix (output of CMatrixLU subroutine).
    Pivots  -   table of permutations which were made during the LU decomposition
                (the output of CMatrixLU subroutine).
    N       -   size of matrix A.

OUTPUT PARAMETERS:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     05.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixluinverse(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_cmatrixtrinverse'></a><h3><code>cmatrixtrinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix inverse (complex)

The subroutine inverts the following types of matrices:
    * upper triangular
    * upper triangular with unit diagonal
    * lower triangular
    * lower triangular with unit diagonal

In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
also be upper (lower) triangular, and after the end of the algorithm,  the
inverse matrix replaces the source matrix. The elements  below (above) the
main diagonal are not changed by the algorithm.

If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
diagonal, and the diagonal elements are not passed to the algorithm.

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1].
    N       -   size of A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Output parameters:
    Info    -   same as for RMatrixLUInverse
    Rep     -   same as for RMatrixLUInverse
    A       -   same as for RMatrixLUInverse.

  -- ALGLIB --
     Copyright 05.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixtrinverse(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isunit,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_hpdmatrixcholeskyinverse'></a><h3><code>hpdmatrixcholeskyinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a Hermitian positive definite matrix which is given
by Cholesky decomposition.

Input parameters:
    A       -   Cholesky decomposition of the matrix to be inverted:
                A=U*U or A = L*L'.
                Output of  HPDMatrixCholesky subroutine.
    N       -   size of matrix A.
    IsUpper    storage format.
                If IsUpper = True, then matrix A is given as A = U'*U
                (matrix contains upper triangle).
                Similarly, if IsUpper = False, then A = L*L'.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixcholeskyinverse(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_hpdmatrixinverse'></a><h3><code>hpdmatrixinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a Hermitian positive definite matrix.

Given an upper or lower triangle of a Hermitian positive definite matrix,
the algorithm generates matrix A^-1 and saves the upper or lower triangle
depending on the input.

Input parameters:
    A       -   matrix to be inverted (upper or lower triangle).
                Array with elements [0..N-1,0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.
                If IsUpper = True, then the upper triangle of matrix A is
                given, otherwise the lower triangle is given.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hpdmatrixinverse(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_rmatrixinverse'></a><h3><code>rmatrixinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a general matrix.

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

Result:
    True, if the matrix is not singular.
    False, if the matrix is singular.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_rmatrixluinverse'></a><h3><code>rmatrixluinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a matrix given by its LU decomposition.

INPUT PARAMETERS:
    A       -   LU decomposition of the matrix (output of RMatrixLU subroutine).
    Pivots  -   table of permutations which were made during the LU decomposition
                (the output of RMatrixLU subroutine).
    N       -   size of matrix A.

OUTPUT PARAMETERS:
    Info    -   return code:
                * -3    A is singular, or VERY close to singular.
                        it is filled by zeros in such cases.
                * -1    N&lt;=0 was passed, or incorrect Pivots was passed
                *  1    task is solved (but matrix A may be ill-conditioned,
                        check R1/RInf parameters for condition numbers).
    Rep     -   solver report, see below for more info
    A       -   inverse of matrix A.
                Array whose indexes range within [0..N-1, 0..N-1].

SOLVER REPORT

Subroutine sets following fields of the Rep structure:
* R1        reciprocal of condition number: 1/cond(A), 1-norm.
* RInf      reciprocal of condition number: 1/cond(A), inf-norm.

  -- ALGLIB routine --
     05.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixluinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_rmatrixtrinverse'></a><h3><code>rmatrixtrinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix inverse (real)

The subroutine inverts the following types of matrices:
    * upper triangular
    * upper triangular with unit diagonal
    * lower triangular
    * lower triangular with unit diagonal

In case of an upper (lower) triangular matrix,  the  inverse  matrix  will
also be upper (lower) triangular, and after the end of the algorithm,  the
inverse matrix replaces the source matrix. The elements  below (above) the
main diagonal are not changed by the algorithm.

If  the matrix  has a unit diagonal, the inverse matrix also  has  a  unit
diagonal, and the diagonal elements are not passed to the algorithm.

Input parameters:
    A       -   matrix, array[0..N-1, 0..N-1].
    N       -   size of A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Output parameters:
    Info    -   same as for RMatrixLUInverse
    Rep     -   same as for RMatrixLUInverse
    A       -   same as for RMatrixLUInverse.

  -- ALGLIB --
     Copyright 05.02.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixtrinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isunit,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_spdmatrixcholeskyinverse'></a><h3><code>spdmatrixcholeskyinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a symmetric positive definite matrix which is given
by Cholesky decomposition.

Input parameters:
    A       -   Cholesky decomposition of the matrix to be inverted:
                A=U*U or A = L*L'.
                Output of  SPDMatrixCholesky subroutine.
    N       -   size of matrix A.
    IsUpper    storage format.
                If IsUpper = True, then matrix A is given as A = U'*U
                (matrix contains upper triangle).
                Similarly, if IsUpper = False, then A = L*L'.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixcholeskyinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name='sub_spdmatrixinverse'></a><h3><code>spdmatrixinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a symmetric positive definite matrix.

Given an upper or lower triangle of a symmetric positive definite matrix,
the algorithm generates matrix A^-1 and saves the upper or lower triangle
depending on the input.

Input parameters:
    A       -   matrix to be inverted (upper or lower triangle).
                Array with elements [0..N-1,0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.
                If IsUpper = True, then the upper triangle of matrix A is
                given, otherwise the lower triangle is given.

Output parameters:
    Info    -   return code, same as in RMatrixLUInverse
    Rep     -   solver report, same as in RMatrixLUInverse
    A       -   inverse of matrix A, same as in RMatrixLUInverse

  -- ALGLIB routine --
     10.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spdmatrixinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>int</b>&amp; info,
    matinvreport&lt;Precision&gt;&amp; rep);
</div></pre>
<a name=unit_minasa></a><h2><code>minasa</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_minasacreate' class=toc>minasacreate</a><br>
<a href='#sub_minasaiteration' class=toc>minasaiteration</a><br>
<a href='#sub_minasaresults' class=toc>minasaresults</a><br>
<a href='#sub_minasasetalgorithm' class=toc>minasasetalgorithm</a><br>
<a href='#sub_minasasetcond' class=toc>minasasetcond</a><br>
<a href='#sub_minasasetstpmax' class=toc>minasasetstpmax</a><br>
<a href='#sub_minasasetxrep' class=toc>minasasetxrep</a><br>
<h3>Examples</h3>
<a href='#example_minasa_1' class=toc>minasa_1</a><br>
<a href='#example_minasa_2' class=toc>minasa_2</a><br>
<a name='sub_minasacreate'></a><h3><code>minasacreate</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
              NONLINEAR BOUND CONSTRAINED OPTIMIZATION USING
                               MODIFIED
                   WILLIAM W. HAGER AND HONGCHAO ZHANG
                         ACTIVE SET ALGORITHM

The  subroutine  minimizes  function  F(x)  of  N  arguments  with   bound
constraints: BndL[i] &lt;= x[i] &lt;= BndU[i]

This method is  globally  convergent  as  long  as  grad(f)  is  Lipschitz
continuous on a level set: L = { x : f(x)&lt;=f(x0) }.

INPUT PARAMETERS:
    N       -   problem dimension. N&gt;0
    X       -   initial solution approximation, array[0..N-1].
    BndL    -   lower bounds, array[0..N-1].
                all elements MUST be specified,  i.e.  all  variables  are
                bounded. However, if some (all) variables  are  unbounded,
                you may specify very small number as bound: -1000,  -1.0E6
                or -1.0E300, or something like that.
    BndU    -   upper bounds, array[0..N-1].
                all elements MUST be specified,  i.e.  all  variables  are
                bounded. However, if some (all) variables  are  unbounded,
                you may specify very large number as bound: +1000,  +1.0E6
                or +1.0E300, or something like that.
    EpsG    -   positive number which  defines  a  precision  of  search.  The
                subroutine finishes its work if the condition ||G|| &lt; EpsG  is
                satisfied, where ||.|| means Euclidian norm, G - gradient, X -
                current approximation.
    EpsF    -   positive number which  defines  a  precision  of  search.  The
                subroutine finishes its work if on iteration  number  k+1  the
                condition |F(k+1)-F(k)| &lt;= EpsF*max{|F(k)|, |F(k+1)|, 1}    is
                satisfied.
    EpsX    -   positive number which  defines  a  precision  of  search.  The
                subroutine finishes its work if on iteration number k+1    the
                condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the number of
                iterations is unlimited.

OUTPUT PARAMETERS:
    State - structure used for reverse communication.

This function  initializes  State   structure  with  default  optimization
parameters (stopping conditions, step size, etc.).  Use  MinASASet??????()
functions to tune optimization parameters.

After   all   optimization   parameters   are   tuned,   you   should  use
MinASAIteration() function to advance algorithm iterations.

NOTES:

1. you may tune stopping conditions with MinASASetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinASASetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 25.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minasacreate(<b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; bndl,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; bndu,
    minasastate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_1' class=nav>minasa_1</a>&nbsp;&nbsp;<a href='#example_minasa_2' class=nav>minasa_2</a>&nbsp;&nbsp;</p>
<a name='sub_minasaiteration'></a><h3><code>minasaiteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One ASA iteration

Called after initialization with MinASACreate.
See HTML documentation for examples.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinASACreate.
RESULT:
* if function returned False, iterative proces has converged.
  Use MinLBFGSResults() to obtain optimization results.
* if subroutine returned True, then, depending on structure fields, we
  have one of the following situations


=== FUNC/GRAD REQUEST ===
State.NeedFG is True =&gt; function value/gradient are needed.
Caller should calculate function value State.F and gradient
State.G[0..N-1] at State.X[0..N-1] and call MinLBFGSIteration() again.

=== NEW INTERATION IS REPORTED ===
State.XUpdated is True =&gt; one more iteration was made.
State.X contains current position, State.F contains function value at X.
You can read info from these fields, but never modify  them  because  they
contain the only copy of optimization algorithm state.

One and only one of these fields (NeedFG, XUpdated) is true on return. New
iterations are reported only when reports  are  explicitly  turned  on  by
MinLBFGSSetXRep() function, so if you never called it, you can expect that
NeedFG is always True.


  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> minasaiteration(minasastate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_1' class=nav>minasa_1</a>&nbsp;&nbsp;<a href='#example_minasa_2' class=nav>minasa_2</a>&nbsp;&nbsp;</p>
<a name='sub_minasaresults'></a><h3><code>minasaresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conjugate gradient results

Called after MinASA returned False.

INPUT PARAMETERS:
    State   -   algorithm state (used by MinASAIteration).

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -2    rounding errors prevent further improvement.
                            X contains best point found.
                    * -1    incorrect parameters were specified
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
                * Rep.IterationsCount contains iterations count
                * NFEV countains number of function calculations
                * ActiveConstraints contains number of active constraints

  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minasaresults(<b>const</b> minasastate&lt;Precision&gt;&amp; state,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minasareport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minasa_1' class=nav>minasa_1</a>&nbsp;&nbsp;<a href='#example_minasa_2' class=nav>minasa_2</a>&nbsp;&nbsp;</p>
<a name='sub_minasasetalgorithm'></a><h3><code>minasasetalgorithm</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets optimization algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinASACreate()
    UAType  -   algorithm type:
                * -1    automatic selection of the best algorithm
                * 0     DY (Dai and Yuan) algorithm
                * 1     Hybrid DY-HS algorithm

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minasasetalgorithm(minasastate&lt;Precision&gt;&amp; state,
    <b>int</b> algotype);
</div></pre>
<a name='sub_minasasetcond'></a><h3><code>minasasetcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for the ASA optimization algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinASACreate()
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
                G - gradient.
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minasasetcond(minasastate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; epsg,
    amp::ampf&lt;Precision&gt; epsf,
    amp::ampf&lt;Precision&gt; epsx,
    <b>int</b> maxits);
</div></pre>
<a name='sub_minasasetstpmax'></a><h3><code>minasasetstpmax</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinCGCreate()
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minasasetstpmax(minasastate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; stpmax);
</div></pre>
<a name='sub_minasasetxrep'></a><h3><code>minasasetxrep</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinASACreate()
    NeedXRep-   whether iteration reports are needed or not

Usually  algorithm  returns from  MinASAIteration()  only  when  it  needs
function/gradient. However, with this function we can let  it  stop  after
each  iteration  (one  iteration  may  include   more  than  one  function
evaluation), which is indicated by XUpdated field.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minasasetxrep(minasastate&lt;Precision&gt;&amp; state,
    <b>bool</b> needxrep);
</div></pre>
<a name='example_minasa_1'></a><h3>minasa_1 example</h3>
<pre>
    <b>int</b> n;
    <b>int</b> i;
    minasa::minasastate&lt;Precision&gt; state;
    minasa::minasareport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; bndl;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; bndu;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;
    amp::ampf&lt;Precision&gt; z;


    
<font color=navy>    //</font>
<font color=navy>    // Function being minimized:</font>
<font color=navy>    //     F = x+2y+3z subject to 0&lt;=x&lt;=1, 0&lt;=y&lt;=1, 0&lt;=z&lt;=1.</font>
<font color=navy>    //</font>
    n = 3;
    s.setlength(n);
    bndl.setlength(n);
    bndu.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        s(i) = 1;
        bndl(i) = 0;
        bndu(i) = 1;
    }
    minasa::minasacreate&lt;Precision&gt;(n, s, bndl, bndu, state);
    minasa::minasasetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.00001&quot;</font>), 0);
    minasa::minasasetxrep&lt;Precision&gt;(state, true);
    printf(<font color=blue>&quot;\n\nF = x+2y+3z subject to 0&lt;=x&lt;=1, 0&lt;=y&lt;=1, 0&lt;=z&lt;=1\n&quot;</font>);
    printf(<font color=blue>&quot;OPTIMIZATION STARTED\n&quot;</font>);
    <b>while</b>( minasa::minasaiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needfg )
        {
            x = state.x(0);
            y = state.x(1);
            z = state.x(2);
            state.f = x+2*y+3*z;
            state.g(0) = 1;
            state.g(1) = 2;
            state.g(2) = 3;
        }
        <b>if</b>( state.xupdated )
        {
            printf(<font color=blue>&quot;    F(%4.2lf,%4.2lf,%4.2lf)=%0.3lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(0)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(1)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(2)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.f).toDouble()));
        }
    }
    printf(<font color=blue>&quot;OPTIMIZATION STOPPED\n&quot;</font>);
    minasa::minasaresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (should be 0.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (should be 0.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));
    printf(<font color=blue>&quot;Z = %4.2lf (should be 0.00)\n\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(2)).toDouble()));

</pre><a name='example_minasa_2'></a><h3>minasa_2 example</h3>
<pre>
    <b>int</b> n;
    <b>int</b> i;
    minasa::minasastate&lt;Precision&gt; state;
    minasa::minasareport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; bndl;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; bndu;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;
    amp::ampf&lt;Precision&gt; z;


    
<font color=navy>    //</font>
<font color=navy>    // Function being minimized:</font>
<font color=navy>    //     F = x+4y+9z subject to 0&lt;=x&lt;=1, 0&lt;=y&lt;=1, 0&lt;=z&lt;=1.</font>
<font color=navy>    //</font>
<font color=navy>    // Take a look at MinASASetStpMax() - it restricts step length by</font>
<font color=navy>    // a small value, so we can see the current point traveling through</font>
<font color=navy>    // a feasible set, sticking to its bounds.</font>
<font color=navy>    //</font>
    n = 3;
    s.setlength(n);
    bndl.setlength(n);
    bndu.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        s(i) = 1;
        bndl(i) = 0;
        bndu(i) = 1;
    }
    minasa::minasacreate&lt;Precision&gt;(n, s, bndl, bndu, state);
    minasa::minasasetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.00001&quot;</font>), 0);
    minasa::minasasetxrep&lt;Precision&gt;(state, true);
    minasa::minasasetstpmax&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.2&quot;</font>));
    printf(<font color=blue>&quot;\n\nF = x+4y+9z subject to 0&lt;=x&lt;=1, 0&lt;=y&lt;=1, 0&lt;=z&lt;=1\n&quot;</font>);
    printf(<font color=blue>&quot;OPTIMIZATION STARTED\n&quot;</font>);
    <b>while</b>( minasa::minasaiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needfg )
        {
            x = state.x(0);
            y = state.x(1);
            z = state.x(2);
            state.f = x+4*y+9*z;
            state.g(0) = 1;
            state.g(1) = 4;
            state.g(2) = 9;
        }
        <b>if</b>( state.xupdated )
        {
            printf(<font color=blue>&quot;    F(%4.2lf, %4.2lf, %4.2lf) = %0.3lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(0)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(1)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(2)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.f).toDouble()));
        }
    }
    printf(<font color=blue>&quot;OPTIMIZATION STOPPED\n&quot;</font>);
    minasa::minasaresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (should be 0.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (should be 0.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));
    printf(<font color=blue>&quot;Z = %4.2lf (should be 0.00)\n\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(2)).toDouble()));

</pre><a name=unit_mincg></a><h2><code>mincg</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_mincgcreate' class=toc>mincgcreate</a><br>
<a href='#sub_mincgiteration' class=toc>mincgiteration</a><br>
<a href='#sub_mincgresults' class=toc>mincgresults</a><br>
<a href='#sub_mincgsetcgtype' class=toc>mincgsetcgtype</a><br>
<a href='#sub_mincgsetcond' class=toc>mincgsetcond</a><br>
<a href='#sub_mincgsetstpmax' class=toc>mincgsetstpmax</a><br>
<a href='#sub_mincgsetxrep' class=toc>mincgsetxrep</a><br>
<h3>Examples</h3>
<a href='#example_mincg_1' class=toc>mincg_1</a><br>
<a href='#example_mincg_2' class=toc>mincg_2</a><br>
<a name='sub_mincgcreate'></a><h3><code>mincgcreate</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
        NONLINEAR CONJUGATE GRADIENT METHOD

The subroutine minimizes function F(x) of N arguments by using one of  the
nonlinear conjugate gradient methods.

These CG methods are globally convergent (even on non-convex functions) as
long as grad(f) is Lipschitz continuous in  a  some  neighborhood  of  the
L = { x : f(x)&lt;=f(x0) }.

INPUT PARAMETERS:
    N       -   problem dimension. N&gt;0
    X       -   initial solution approximation, array[0..N-1].
    EpsG    -   positive number which  defines  a  precision  of  search.  The
                subroutine finishes its work if the condition ||G|| &lt; EpsG  is
                satisfied, where ||.|| means Euclidian norm, G - gradient, X -
                current approximation.
    EpsF    -   positive number which  defines  a  precision  of  search.  The
                subroutine finishes its work if on iteration  number  k+1  the
                condition |F(k+1)-F(k)| &lt;= EpsF*max{|F(k)|, |F(k+1)|, 1}    is
                satisfied.
    EpsX    -   positive number which  defines  a  precision  of  search.  The
                subroutine finishes its work if on iteration number k+1    the
                condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the number of
                iterations is unlimited.

OUTPUT PARAMETERS:
    State - structure used for reverse communication.

See also MinCGIteration, MinCGResults

NOTE:

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 25.03.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> mincgcreate(<b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    mincgstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_2' class=nav>mincg_2</a>&nbsp;&nbsp;<a href='#example_mincg_1' class=nav>mincg_1</a>&nbsp;&nbsp;</p>
<a name='sub_mincgiteration'></a><h3><code>mincgiteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One conjugate gradient iteration

Called after initialization with MinCG.
See HTML documentation for examples.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinCG.

RESULT:
* if function returned False, iterative proces has converged.
  Use MinLBFGSResults() to obtain optimization results.
* if subroutine returned True, then, depending on structure fields, we
  have one of the following situations


=== FUNC/GRAD REQUEST ===
State.NeedFG is True =&gt; function value/gradient are needed.
Caller should calculate function value State.F and gradient
State.G[0..N-1] at State.X[0..N-1] and call MinLBFGSIteration() again.

=== NEW INTERATION IS REPORTED ===
State.XUpdated is True =&gt; one more iteration was made.
State.X contains current position, State.F contains function value at X.
You can read info from these fields, but never modify  them  because  they
contain the only copy of optimization algorithm state.

One and only one of these fields (NeedFG, XUpdated) is true on return. New
iterations are reported only when reports  are  explicitly  turned  on  by
MinLBFGSSetXRep() function, so if you never called it, you can expect that
NeedFG is always True.


  -- ALGLIB --
     Copyright 20.04.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> mincgiteration(mincgstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_2' class=nav>mincg_2</a>&nbsp;&nbsp;<a href='#example_mincg_1' class=nav>mincg_1</a>&nbsp;&nbsp;</p>
<a name='sub_mincgresults'></a><h3><code>mincgresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Conjugate gradient results

Called after MinCG returned False.

INPUT PARAMETERS:
    State   -   algorithm state (used by MinCGIteration).

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -2    rounding errors prevent further improvement.
                            X contains best point found.
                    * -1    incorrect parameters were specified
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
                * Rep.IterationsCount contains iterations count
                * NFEV countains number of function calculations

  -- ALGLIB --
     Copyright 20.04.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> mincgresults(<b>const</b> mincgstate&lt;Precision&gt;&amp; state,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    mincgreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_mincg_2' class=nav>mincg_2</a>&nbsp;&nbsp;<a href='#example_mincg_1' class=nav>mincg_1</a>&nbsp;&nbsp;</p>
<a name='sub_mincgsetcgtype'></a><h3><code>mincgsetcgtype</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets CG algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinCGCreate()
    CGType  -   algorithm type:
                * -1    automatic selection of the best algorithm
                * 0     DY (Dai and Yuan) algorithm
                * 1     Hybrid DY-HS algorithm

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> mincgsetcgtype(mincgstate&lt;Precision&gt;&amp; state,
    <b>int</b> cgtype);
</div></pre>
<a name='sub_mincgsetcond'></a><h3><code>mincgsetcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for CG optimization algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinCGCreate()
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
                G - gradient.
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> mincgsetcond(mincgstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; epsg,
    amp::ampf&lt;Precision&gt; epsf,
    amp::ampf&lt;Precision&gt; epsx,
    <b>int</b> maxits);
</div></pre>
<a name='sub_mincgsetstpmax'></a><h3><code>mincgsetstpmax</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinCGCreate()
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> mincgsetstpmax(mincgstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; stpmax);
</div></pre>
<a name='sub_mincgsetxrep'></a><h3><code>mincgsetxrep</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinCGCreate()
    NeedXRep-   whether iteration reports are needed or not

Usually  algorithm  returns  from  MinCGIteration()  only  when  it  needs
function/gradient. However, with this function we can let  it  stop  after
each  iteration  (one  iteration  may  include   more  than  one  function
evaluation), which is indicated by XUpdated field.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> mincgsetxrep(mincgstate&lt;Precision&gt;&amp; state,
    <b>bool</b> needxrep);
</div></pre>
<a name='example_mincg_1'></a><h3>mincg_1 example</h3>
<pre>
    <b>int</b> n;
    mincg::mincgstate&lt;Precision&gt; state;
    mincg::mincgreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = (x-1)^4 + (y-x)^2</font>
<font color=navy>    // N = 2 - task dimension.</font>
<font color=navy>    //</font>
    n = 2;
    s.setlength(2);
    s(0) = 10;
    s(1) = 11;
    mincg::mincgcreate&lt;Precision&gt;(n, s, state);
    mincg::mincgsetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.00001&quot;</font>), 0);
    mincg::mincgsetxrep&lt;Precision&gt;(state, true);
    printf(<font color=blue>&quot;\n\nF = (x-1)^4 + (y-x)^2\n&quot;</font>);
    printf(<font color=blue>&quot;OPTIMIZATION STARTED\n&quot;</font>);
    <b>while</b>( mincg::mincgiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needfg )
        {
            x = state.x(0);
            y = state.x(1);
            state.f = amp::sqr&lt;Precision&gt;(amp::sqr&lt;Precision&gt;(x-1))+amp::sqr&lt;Precision&gt;(y-x);
            state.g(0) = 4*amp::sqr&lt;Precision&gt;(x-1)*(x-1)+2*(x-y);
            state.g(1) = 2*(y-x);
        }
        <b>if</b>( state.xupdated )
        {
            printf(<font color=blue>&quot;    F(%8.5lf,%8.5lf)=%0.5lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(0)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(1)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.f).toDouble()));
        }
    }
    printf(<font color=blue>&quot;OPTIMIZATION STOPPED\n&quot;</font>);
    mincg::mincgresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (should be 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (should be 1.00)\n\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));

</pre><a name='example_mincg_2'></a><h3>mincg_2 example</h3>
<pre>
    <b>int</b> n;
    mincg::mincgstate&lt;Precision&gt; state;
    mincg::mincgreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = exp(x-1) + exp(1-x) + (y-x)^2</font>
<font color=navy>    // N = 2 - task dimension.</font>
<font color=navy>    //</font>
<font color=navy>    // Take a look at MinCGSetStpMax() call - it prevents us</font>
<font color=navy>    // from overflow (which may be result of too large step).</font>
<font color=navy>    // Try to comment it and see what will happen.</font>
<font color=navy>    //</font>
    n = 2;
    s.setlength(2);
    s(0) = 10;
    s(1) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    mincg::mincgcreate&lt;Precision&gt;(n, s, state);
    mincg::mincgsetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0001&quot;</font>), 0);
    mincg::mincgsetxrep&lt;Precision&gt;(state, true);
    mincg::mincgsetstpmax&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>));
    printf(<font color=blue>&quot;\n\nF = exp(x-1) + exp(1-x) + (y-x)^2\n&quot;</font>);
    printf(<font color=blue>&quot;OPTIMIZATION STARTED\n&quot;</font>);
    <b>while</b>( mincg::mincgiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needfg )
        {
            x = state.x(0);
            y = state.x(1);
            state.f = amp::exp&lt;Precision&gt;(x-1)+amp::exp&lt;Precision&gt;(1-x)+amp::sqr&lt;Precision&gt;(y-x);
            state.g(0) = amp::exp&lt;Precision&gt;(x-1)-amp::exp&lt;Precision&gt;(1-x)+2*(x-y);
            state.g(1) = 2*(y-x);
        }
        <b>if</b>( state.xupdated )
        {
            printf(<font color=blue>&quot;    F(%8.5lf,%8.5lf)=%0.5lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(0)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(1)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.f).toDouble()));
        }
    }
    printf(<font color=blue>&quot;OPTIMIZATION STOPPED\n&quot;</font>);
    mincg::mincgresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (should be 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (should be 1.00)\n\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));

</pre><a name=unit_minlbfgs></a><h2><code>minlbfgs</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_minlbfgscreate' class=toc>minlbfgscreate</a><br>
<a href='#sub_minlbfgscreatex' class=toc>minlbfgscreatex</a><br>
<a href='#sub_minlbfgsiteration' class=toc>minlbfgsiteration</a><br>
<a href='#sub_minlbfgsresults' class=toc>minlbfgsresults</a><br>
<a href='#sub_minlbfgssetcond' class=toc>minlbfgssetcond</a><br>
<a href='#sub_minlbfgssetstpmax' class=toc>minlbfgssetstpmax</a><br>
<a href='#sub_minlbfgssetxrep' class=toc>minlbfgssetxrep</a><br>
<h3>Examples</h3>
<a href='#example_minlbfgs_1' class=toc>minlbfgs_1</a><br>
<a href='#example_minlbfgs_2' class=toc>minlbfgs_2</a><br>
<a name='sub_minlbfgscreate'></a><h3><code>minlbfgscreate</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
        LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION

The subroutine minimizes function F(x) of N arguments by  using  a  quasi-
Newton method (LBFGS scheme) which is optimized to use  a  minimum  amount
of memory.

The subroutine generates the approximation of an inverse Hessian matrix by
using information about the last M steps of the algorithm  (instead of N).
It lessens a required amount of memory from a value  of  order  N^2  to  a
value of order 2*N*M.

INPUT PARAMETERS:
    N       -   problem dimension. N&gt;0
    M       -   number of corrections in the BFGS scheme of Hessian
                approximation update. Recommended value:  3&lt;=M&lt;=7. The smaller
                value causes worse convergence, the bigger will  not  cause  a
                considerably better convergence, but will cause a fall in  the
                performance. M&lt;=N.
    X       -   initial solution approximation, array[0..N-1].

OUTPUT PARAMETERS:
    State   -   structure used for reverse communication.
    
This function  initializes  State   structure  with  default  optimization
parameters (stopping conditions, step size, etc.). Use MinLBFGSSet??????()
functions to tune optimization parameters.

After   all   optimization   parameters   are   tuned,   you   should  use
MinLBFGSIteration() function to advance algorithm iterations.

NOTES:

1. you may tune stopping conditions with MinLBFGSSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLBFGSSetStpMax() function to bound algorithm's  steps.  However,
   L-BFGS rarely needs such a tuning.


  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlbfgscreate(<b>int</b> n,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minlbfgsstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_1' class=nav>minlbfgs_1</a>&nbsp;&nbsp;<a href='#example_minlbfgs_2' class=nav>minlbfgs_2</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgscreatex'></a><h3><code>minlbfgscreatex</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Extended subroutine for internal use only.

Accepts additional parameters:

    Flags - additional settings:
            * Flags = 0     means no additional settings
            * Flags = 1     &quot;do not allocate memory&quot;. used when solving
                            a many subsequent tasks with  same N/M  values.
                            First  call MUST  be without this flag bit set,
                            subsequent  calls   of   MinLBFGS   with   same
                            MinLBFGSState structure can set Flags to 1.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlbfgscreatex(<b>int</b> n,
    <b>int</b> m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> flags,
    minlbfgsstate&lt;Precision&gt;&amp; state);
</div></pre>
<a name='sub_minlbfgsiteration'></a><h3><code>minlbfgsiteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
L-BFGS iterations

Called after initialization with MinLBFGSCreate() function.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinLBFGSCreate()

RESULT:
* if function returned False, iterative proces has converged.
  Use MinLBFGSResults() to obtain optimization results.
* if subroutine returned True, then, depending on structure fields, we
  have one of the following situations


=== FUNC/GRAD REQUEST ===
State.NeedFG is True =&gt; function value/gradient are needed.
Caller should calculate function value State.F and gradient
State.G[0..N-1] at State.X[0..N-1] and call MinLBFGSIteration() again.

=== NEW INTERATION IS REPORTED ===
State.XUpdated is True =&gt; one more iteration was made.
State.X contains current position, State.F contains function value at X.
You can read info from these fields, but never modify  them  because  they
contain the only copy of optimization algorithm state.


One and only one of these fields (NeedFG, XUpdated) is true on return. New
iterations are reported only when reports  are  explicitly  turned  on  by
MinLBFGSSetXRep() function, so if you never called it, you can expect that
NeedFG is always True.


  -- ALGLIB --
     Copyright 20.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> minlbfgsiteration(minlbfgsstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_1' class=nav>minlbfgs_1</a>&nbsp;&nbsp;<a href='#example_minlbfgs_2' class=nav>minlbfgs_2</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgsresults'></a><h3><code>minlbfgsresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
L-BFGS algorithm results

Called after MinLBFGSIteration() returned False.

INPUT PARAMETERS:
    State   -   algorithm state (used by MinLBFGSIteration).

OUTPUT PARAMETERS:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -2    rounding errors prevent further improvement.
                            X contains best point found.
                    * -1    incorrect parameters were specified
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient norm is no more than EpsG
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
                * Rep.IterationsCount contains iterations count
                * NFEV countains number of function calculations

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlbfgsresults(<b>const</b> minlbfgsstate&lt;Precision&gt;&amp; state,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minlbfgsreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlbfgs_1' class=nav>minlbfgs_1</a>&nbsp;&nbsp;<a href='#example_minlbfgs_2' class=nav>minlbfgs_2</a>&nbsp;&nbsp;</p>
<a name='sub_minlbfgssetcond'></a><h3><code>minlbfgssetcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for L-BFGS optimization algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinLBFGSCreate()
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
                G - gradient.
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations is unlimited.

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlbfgssetcond(minlbfgsstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; epsg,
    amp::ampf&lt;Precision&gt; epsf,
    amp::ampf&lt;Precision&gt; epsx,
    <b>int</b> maxits);
</div></pre>
<a name='sub_minlbfgssetstpmax'></a><h3><code>minlbfgssetstpmax</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinLBFGSCreate()
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlbfgssetstpmax(minlbfgsstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; stpmax);
</div></pre>
<a name='sub_minlbfgssetxrep'></a><h3><code>minlbfgssetxrep</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinLBFGSCreate()
    NeedXRep-   whether iteration reports are needed or not

Usually algorithm returns  from  MinLBFGSIteration()  only when  it  needs
function/gradient/ (which is indicated by NeedFG field. However, with this
function we can let it  stop  after  each  iteration  (one  iteration  may
include more than one function evaluation), which is indicated by XUpdated
field.


  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlbfgssetxrep(minlbfgsstate&lt;Precision&gt;&amp; state,
    <b>bool</b> needxrep);
</div></pre>
<a name='example_minlbfgs_1'></a><h3>minlbfgs_1 example</h3>
<pre>
    <b>int</b> n;
    <b>int</b> m;
    minlbfgs::minlbfgsstate&lt;Precision&gt; state;
    minlbfgs::minlbfgsreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = exp(x-1) + exp(1-x) + (y-x)^2</font>
<font color=navy>    // N = 2 - task dimension</font>
<font color=navy>    // M = 1 - build tank-1 model</font>
<font color=navy>    //</font>
    n = 2;
    m = 1;
    s.setlength(2);
    s(0) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    s(1) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    minlbfgs::minlbfgscreate&lt;Precision&gt;(n, m, s, state);
    minlbfgs::minlbfgssetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0001&quot;</font>), 0);
    <b>while</b>( minlbfgs::minlbfgsiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needfg )
        {
            x = state.x(0);
            y = state.x(1);
            state.f = amp::exp&lt;Precision&gt;(x-1)+amp::exp&lt;Precision&gt;(1-x)+amp::sqr&lt;Precision&gt;(y-x);
            state.g(0) = amp::exp&lt;Precision&gt;(x-1)-amp::exp&lt;Precision&gt;(1-x)+2*(x-y);
            state.g(1) = 2*(y-x);
        }
    }
    minlbfgs::minlbfgsresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;\n\nF = exp(x-1) + exp(1-x) + (y-x)^2\n&quot;</font>);
    printf(<font color=blue>&quot;X = %4.2lf (should be 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (should be 1.00)\n\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));

</pre><a name='example_minlbfgs_2'></a><h3>minlbfgs_2 example</h3>
<pre>
    <b>int</b> n;
    <b>int</b> m;
    minlbfgs::minlbfgsstate&lt;Precision&gt; state;
    minlbfgs::minlbfgsreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = exp(x-1) + exp(1-x) + (y-x)^2</font>
<font color=navy>    // N = 2 - task dimension</font>
<font color=navy>    // M = 1 - build tank-1 model</font>
<font color=navy>    //</font>
    n = 2;
    m = 1;
    s.setlength(2);
    s(0) = 10;
    s(1) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    minlbfgs::minlbfgscreate&lt;Precision&gt;(n, m, s, state);
    minlbfgs::minlbfgssetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0001&quot;</font>), 0);
    minlbfgs::minlbfgssetxrep&lt;Precision&gt;(state, true);
    printf(<font color=blue>&quot;\n\nF = exp(x-1) + exp(1-x) + (y-x)^2\n&quot;</font>);
    printf(<font color=blue>&quot;OPTIMIZATION STARTED\n&quot;</font>);
    <b>while</b>( minlbfgs::minlbfgsiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needfg )
        {
            x = state.x(0);
            y = state.x(1);
            state.f = amp::exp&lt;Precision&gt;(x-1)+amp::exp&lt;Precision&gt;(1-x)+amp::sqr&lt;Precision&gt;(y-x);
            state.g(0) = amp::exp&lt;Precision&gt;(x-1)-amp::exp&lt;Precision&gt;(1-x)+2*(x-y);
            state.g(1) = 2*(y-x);
        }
        <b>if</b>( state.xupdated )
        {
            printf(<font color=blue>&quot;    F(%8.5lf,%8.5lf)=%0.5lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(0)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.x(1)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(state.f).toDouble()));
        }
    }
    printf(<font color=blue>&quot;OPTIMIZATION STOPPED\n&quot;</font>);
    minlbfgs::minlbfgsresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (should be 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (should be 1.00)\n\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));

</pre><a name=unit_minlm></a><h2><code>minlm</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_minlmcreatefgh' class=toc>minlmcreatefgh</a><br>
<a href='#sub_minlmcreatefgj' class=toc>minlmcreatefgj</a><br>
<a href='#sub_minlmcreatefj' class=toc>minlmcreatefj</a><br>
<a href='#sub_minlmiteration' class=toc>minlmiteration</a><br>
<a href='#sub_minlmresults' class=toc>minlmresults</a><br>
<a href='#sub_minlmsetcond' class=toc>minlmsetcond</a><br>
<a href='#sub_minlmsetstpmax' class=toc>minlmsetstpmax</a><br>
<a href='#sub_minlmsetxrep' class=toc>minlmsetxrep</a><br>
<h3>Examples</h3>
<a href='#example_minlm_fgh' class=toc>minlm_fgh</a><br>
<a href='#example_minlm_fgj' class=toc>minlm_fgj</a><br>
<a href='#example_minlm_fj' class=toc>minlm_fj</a><br>
<a href='#example_minlm_fj2' class=toc>minlm_fj2</a><br>
<a name='sub_minlmcreatefgh'></a><h3><code>minlmcreatefgh</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
    LEVENBERG-MARQUARDT-LIKE METHOD FOR NON-LINEAR OPTIMIZATION

Optimization using function gradient and Hessian.  Algorithm -  Levenberg-
Marquardt   modification   with   L-BFGS   pre-optimization  and  internal
pre-conditioned L-BFGS optimization after each Levenberg-Marquardt step.

Function F has general form (not &quot;sum-of-squares&quot;):

    F = F(x[0], ..., x[n-1])

EXAMPLE

See HTML-documentation.

INPUT PARAMETERS:
    N       -   dimension, N&gt;1
    X       -   initial solution, array[0..N-1]

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state between subsequent
                calls of MinLMIteration. Used for reverse communication.
                This structure should be passed to MinLMIteration subroutine.

See also MinLMIteration, MinLMResults.

NOTES:

1. you may tune stopping conditions with MinLMSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLMSetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmcreatefgh(<b>const</b> <b>int</b>&amp; n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minlmstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_fgh' class=nav>minlm_fgh</a>&nbsp;&nbsp;</p>
<a name='sub_minlmcreatefgj'></a><h3><code>minlmcreatefgj</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
    LEVENBERG-MARQUARDT-LIKE METHOD FOR NON-LINEAR OPTIMIZATION

Optimization using function gradient and Jacobian.  Algorithm -  Levenberg-
Marquardt   modification   with   L-BFGS   pre-optimization  and  internal
pre-conditioned L-BFGS optimization after each Levenberg-Marquardt step.

Function F is represented as sum of squares:

    F = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])

EXAMPLE

See HTML-documentation.

INPUT PARAMETERS:
    N       -   dimension, N&gt;1
    M       -   number of functions f[i]
    X       -   initial solution, array[0..N-1]

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state between subsequent
                calls of MinLMIteration. Used for reverse communication.
                This structure should be passed to MinLMIteration subroutine.

See also MinLMIteration, MinLMResults.

NOTES:

1. you may tune stopping conditions with MinLMSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLMSetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmcreatefgj(<b>const</b> <b>int</b>&amp; n,
    <b>const</b> <b>int</b>&amp; m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minlmstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_fgj' class=nav>minlm_fgj</a>&nbsp;&nbsp;</p>
<a name='sub_minlmcreatefj'></a><h3><code>minlmcreatefj</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
    CLASSIC LEVENBERG-MARQUARDT METHOD FOR NON-LINEAR OPTIMIZATION

Optimization using Jacobi matrix. Algorithm  -  classic Levenberg-Marquardt
method.

Function F is represented as sum of squares:

    F = f[0]^2(x[0],...,x[n-1]) + ... + f[m-1]^2(x[0],...,x[n-1])

EXAMPLE

See HTML-documentation.

INPUT PARAMETERS:
    N       -   dimension, N&gt;1
    M       -   number of functions f[i]
    X       -   initial solution, array[0..N-1]

OUTPUT PARAMETERS:
    State   -   structure which stores algorithm state between subsequent
                calls of MinLMIteration. Used for reverse communication.
                This structure should be passed to MinLMIteration subroutine.

See also MinLMIteration, MinLMResults.

NOTES:

1. you may tune stopping conditions with MinLMSetCond() function
2. if target function contains exp() or other fast growing functions,  and
   optimization algorithm makes too large steps which leads  to  overflow,
   use MinLMSetStpMax() function to bound algorithm's steps.

  -- ALGLIB --
     Copyright 30.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmcreatefj(<b>const</b> <b>int</b>&amp; n,
    <b>const</b> <b>int</b>&amp; m,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minlmstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_fj' class=nav>minlm_fj</a>&nbsp;&nbsp;<a href='#example_minlm_fj2' class=nav>minlm_fj2</a>&nbsp;&nbsp;</p>
<a name='sub_minlmiteration'></a><h3><code>minlmiteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One Levenberg-Marquardt iteration.

Called after inialization of State structure with MinLMXXX subroutine.
See HTML docs for examples.

Input parameters:
    State   -   structure which stores algorithm state between subsequent
                calls and which is used for reverse communication. Must be
                initialized with MinLMXXX call first.

If subroutine returned False, iterative algorithm has converged.

If subroutine returned True, then:
* if State.NeedF=True,      -   function value F at State.X[0..N-1]
                                is required
* if State.NeedFG=True      -   function value F and gradient G
                                are required
* if State.NeedFiJ=True     -   function vector f[i] and Jacobi matrix J
                                are required
* if State.NeedFGH=True     -   function value F, gradient G and Hesian H
                                are required
* if State.XUpdated=True    -   algorithm reports about new iteration,
                                State.X contains current point,
                                State.F contains function value.

One and only one of this fields can be set at time.

Results are stored:
* function value            -   in MinLMState.F
* gradient                  -   in MinLMState.G[0..N-1]
* Jacobi matrix             -   in MinLMState.J[0..M-1,0..N-1]
* Hessian                   -   in MinLMState.H[0..N-1,0..N-1]

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> minlmiteration(minlmstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_fgh' class=nav>minlm_fgh</a>&nbsp;&nbsp;<a href='#example_minlm_fgj' class=nav>minlm_fgj</a>&nbsp;&nbsp;<a href='#example_minlm_fj' class=nav>minlm_fj</a>&nbsp;&nbsp;<a href='#example_minlm_fj2' class=nav>minlm_fj2</a>&nbsp;&nbsp;</p>
<a name='sub_minlmresults'></a><h3><code>minlmresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Levenberg-Marquardt algorithm results

Called after MinLMIteration returned False.

Input parameters:
    State   -   algorithm state (used by MinLMIteration).

Output parameters:
    X       -   array[0..N-1], solution
    Rep     -   optimization report:
                * Rep.TerminationType completetion code:
                    * -1    incorrect parameters were specified
                    *  1    relative function improvement is no more than
                            EpsF.
                    *  2    relative step is no more than EpsX.
                    *  4    gradient is no more than EpsG.
                    *  5    MaxIts steps was taken
                    *  7    stopping conditions are too stringent,
                            further improvement is impossible
                * Rep.IterationsCount contains iterations count
                * Rep.NFunc     - number of function calculations
                * Rep.NJac      - number of Jacobi matrix calculations
                * Rep.NGrad     - number of gradient calculations
                * Rep.NHess     - number of Hessian calculations
                * Rep.NCholesky - number of Cholesky decomposition calculations

  -- ALGLIB --
     Copyright 10.03.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmresults(<b>const</b> minlmstate&lt;Precision&gt;&amp; state,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    minlmreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_minlm_fgh' class=nav>minlm_fgh</a>&nbsp;&nbsp;<a href='#example_minlm_fgj' class=nav>minlm_fgj</a>&nbsp;&nbsp;<a href='#example_minlm_fj' class=nav>minlm_fj</a>&nbsp;&nbsp;<a href='#example_minlm_fj2' class=nav>minlm_fj2</a>&nbsp;&nbsp;</p>
<a name='sub_minlmsetcond'></a><h3><code>minlmsetcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets stopping conditions for Levenberg-Marquardt optimization
algorithm.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be initialized
                with MinLMCreate???()
    EpsG    -   &gt;=0
                The  subroutine  finishes  its  work   if   the  condition
                ||G||&lt;EpsG is satisfied, where ||.|| means Euclidian norm,
                G - gradient.
    EpsF    -   &gt;=0
                The  subroutine  finishes  its work if on k+1-th iteration
                the  condition  |F(k+1)-F(k)|&lt;=EpsF*max{|F(k)|,|F(k+1)|,1}
                is satisfied.
    EpsX    -   &gt;=0
                The subroutine finishes its work if  on  k+1-th  iteration
                the condition |X(k+1)-X(k)| &lt;= EpsX is fulfilled.
    MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                iterations   is    unlimited.   Only   Levenberg-Marquardt
                iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
                counted  because their cost is very low copared to that of
                LM).

Passing EpsG=0, EpsF=0, EpsX=0 and MaxIts=0 (simultaneously) will lead to
automatic stopping criterion selection (small EpsX).

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmsetcond(minlmstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; epsg,
    amp::ampf&lt;Precision&gt; epsf,
    amp::ampf&lt;Precision&gt; epsx,
    <b>int</b> maxits);
</div></pre>
<a name='sub_minlmsetstpmax'></a><h3><code>minlmsetstpmax</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function sets maximum step length

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinCGCreate???()
    StpMax  -   maximum step length, &gt;=0. Set StpMax to 0.0,  if you don't
                want to limit step length.

Use this subroutine when you optimize target function which contains exp()
or  other  fast  growing  functions,  and optimization algorithm makes too
large  steps  which  leads  to overflow. This function allows us to reject
steps  that  are  too  large  (and  therefore  expose  us  to the possible
overflow) without actually calculating function value at the x+stp*d.

NOTE: non-zero StpMax leads to moderate  performance  degradation  because
intermediate  step  of  preconditioned L-BFGS optimization is incompatible
with limits on step size.

  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmsetstpmax(minlmstate&lt;Precision&gt;&amp; state,
    amp::ampf&lt;Precision&gt; stpmax);
</div></pre>
<a name='sub_minlmsetxrep'></a><h3><code>minlmsetxrep</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function turns on/off reporting.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between calls and
                which is used for reverse communication. Must be
                initialized with MinLMCreate???()
    NeedXRep-   whether iteration reports are needed or not

Usually  algorithm  returns  from  MinLMIteration()  only  when  it  needs
function/gradient/Hessian. However, with this function we can let it  stop
after  each  iteration  (one iteration may include  more than one function
evaluation), which is indicated by XUpdated field.

Both Levenberg-Marquardt and L-BFGS iterations are reported.


  -- ALGLIB --
     Copyright 02.04.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> minlmsetxrep(minlmstate&lt;Precision&gt;&amp; state,
    <b>bool</b> needxrep);
</div></pre>
<a name='example_minlm_fgh'></a><h3>minlm_fgh example</h3>
<pre>
    minlm::minlmstate&lt;Precision&gt; state;
    minlm::minlmreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Example of solving simple task using FGH scheme.</font>
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = (x-2*y)^2 + (x-2)^2 + (y-1)^2</font>
<font color=navy>    // exact solution is (2,1).</font>
<font color=navy>    //</font>
    s.setlength(2);
    s(0) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    s(1) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    minlm::minlmcreatefgh&lt;Precision&gt;(2, s, state);
    minlm::minlmsetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.001&quot;</font>), 0);
    <b>while</b>( minlm::minlmiteration&lt;Precision&gt;(state) )
    {
        x = state.x(0);
        y = state.x(1);
        <b>if</b>( state.needf )
        {
            state.f = amp::sqr&lt;Precision&gt;(x-2*y)+amp::sqr&lt;Precision&gt;(x-2)+amp::sqr&lt;Precision&gt;(y-1);
        }
        <b>if</b>( state.needfg )
        {
            state.f = amp::sqr&lt;Precision&gt;(x-2*y)+amp::sqr&lt;Precision&gt;(x-2)+amp::sqr&lt;Precision&gt;(y-1);
            state.g(0) = 2*(x-2*y)+2*(x-2)+0;
            state.g(1) = -4*(x-2*y)+0+2*(y-1);
        }
        <b>if</b>( state.needfgh )
        {
            state.f = amp::sqr&lt;Precision&gt;(x-2*y)+amp::sqr&lt;Precision&gt;(x-2)+amp::sqr&lt;Precision&gt;(y-1);
            state.g(0) = 2*(x-2*y)+2*(x-2)+0;
            state.g(1) = -4*(x-2*y)+0+2*(y-1);
            state.h(0,0) = 4;
            state.h(1,0) = -4;
            state.h(0,1) = -4;
            state.h(1,1) = 10;
        }
    }
    minlm::minlmresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (correct value - 2.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (correct value - 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));
    printf(<font color=blue>&quot;TerminationType = %0ld (should be 2 - stopping when step is small enough)\n&quot;</font>,
        <b>long</b>(rep.terminationtype));
    printf(<font color=blue>&quot;NFunc = %0ld\n&quot;</font>,
        <b>long</b>(rep.nfunc));
    printf(<font color=blue>&quot;NJac  = %0ld\n&quot;</font>,
        <b>long</b>(rep.njac));
    printf(<font color=blue>&quot;NGrad = %0ld\n&quot;</font>,
        <b>long</b>(rep.ngrad));
    printf(<font color=blue>&quot;NHess = %0ld\n&quot;</font>,
        <b>long</b>(rep.nhess));

</pre><a name='example_minlm_fgj'></a><h3>minlm_fgj example</h3>
<pre>
    minlm::minlmstate&lt;Precision&gt; state;
    minlm::minlmreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Example of solving simple task using FGJ scheme.</font>
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = (x-2*y)^2 + (x-2)^2 + (y-1)^2</font>
<font color=navy>    // exact solution is (2,1).</font>
<font color=navy>    //</font>
    s.setlength(2);
    s(0) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    s(1) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    minlm::minlmcreatefgj&lt;Precision&gt;(2, 3, s, state);
    minlm::minlmsetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.001&quot;</font>), 0);
    <b>while</b>( minlm::minlmiteration&lt;Precision&gt;(state) )
    {
        x = state.x(0);
        y = state.x(1);
        <b>if</b>( state.needf )
        {
            state.f = amp::sqr&lt;Precision&gt;(x-2*y)+amp::sqr&lt;Precision&gt;(x-2)+amp::sqr&lt;Precision&gt;(y-1);
        }
        <b>if</b>( state.needfg )
        {
            state.f = amp::sqr&lt;Precision&gt;(x-2*y)+amp::sqr&lt;Precision&gt;(x-2)+amp::sqr&lt;Precision&gt;(y-1);
            state.g(0) = 2*(x-2*y)+2*(x-2)+0;
            state.g(1) = -4*(x-2*y)+0+2*(y-1);
        }
        <b>if</b>( state.needfij )
        {
            state.fi(0) = x-2*y;
            state.fi(1) = x-2;
            state.fi(2) = y-1;
            state.j(0,0) = 1;
            state.j(0,1) = -2;
            state.j(1,0) = 1;
            state.j(1,1) = 0;
            state.j(2,0) = 0;
            state.j(2,1) = 1;
        }
    }
    minlm::minlmresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (correct value - 2.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (correct value - 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));
    printf(<font color=blue>&quot;TerminationType = %0ld (should be 2 - stopping when step is small enough)\n&quot;</font>,
        <b>long</b>(rep.terminationtype));
    printf(<font color=blue>&quot;NFunc = %0ld\n&quot;</font>,
        <b>long</b>(rep.nfunc));
    printf(<font color=blue>&quot;NJac  = %0ld\n&quot;</font>,
        <b>long</b>(rep.njac));
    printf(<font color=blue>&quot;NGrad = %0ld\n&quot;</font>,
        <b>long</b>(rep.ngrad));
    printf(<font color=blue>&quot;NHess = %0ld\n&quot;</font>,
        <b>long</b>(rep.nhess));

</pre><a name='example_minlm_fj'></a><h3>minlm_fj example</h3>
<pre>
    minlm::minlmstate&lt;Precision&gt; state;
    minlm::minlmreport&lt;Precision&gt; rep;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    amp::ampf&lt;Precision&gt; x;
    amp::ampf&lt;Precision&gt; y;


    
<font color=navy>    //</font>
<font color=navy>    // Example of solving simple task using FJ scheme.</font>
<font color=navy>    //</font>
<font color=navy>    // Function minimized:</font>
<font color=navy>    //     F = (x-2*y)^2 + (x-2)^2 + (y-1)^2</font>
<font color=navy>    // exact solution is (2,1).</font>
<font color=navy>    //</font>
    s.setlength(2);
    s(0) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    s(1) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    minlm::minlmcreatefj&lt;Precision&gt;(2, 3, s, state);
    minlm::minlmsetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.001&quot;</font>), 0);
    <b>while</b>( minlm::minlmiteration&lt;Precision&gt;(state) )
    {
        x = state.x(0);
        y = state.x(1);
        <b>if</b>( state.needf )
        {
            state.f = amp::sqr&lt;Precision&gt;(x-2*y)+amp::sqr&lt;Precision&gt;(x-2)+amp::sqr&lt;Precision&gt;(y-1);
        }
        <b>if</b>( state.needfij )
        {
            state.fi(0) = x-2*y;
            state.fi(1) = x-2;
            state.fi(2) = y-1;
            state.j(0,0) = 1;
            state.j(0,1) = -2;
            state.j(1,0) = 1;
            state.j(1,1) = 0;
            state.j(2,0) = 0;
            state.j(2,1) = 1;
        }
    }
    minlm::minlmresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;X = %4.2lf (correct value - 2.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;Y = %4.2lf (correct value - 1.00)\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));
    printf(<font color=blue>&quot;TerminationType = %0ld (should be 2 - stopping when step is small enough)\n&quot;</font>,
        <b>long</b>(rep.terminationtype));
    printf(<font color=blue>&quot;NFunc = %0ld\n&quot;</font>,
        <b>long</b>(rep.nfunc));
    printf(<font color=blue>&quot;NJac  = %0ld\n&quot;</font>,
        <b>long</b>(rep.njac));
    printf(<font color=blue>&quot;NGrad = %0ld\n&quot;</font>,
        <b>long</b>(rep.ngrad));
    printf(<font color=blue>&quot;NHess = %0ld\n&quot;</font>,
        <b>long</b>(rep.nhess));

</pre><a name='example_minlm_fj2'></a><h3>minlm_fj2 example</h3>
<pre>
    minlm::minlmstate&lt;Precision&gt; state;
    minlm::minlmreport&lt;Precision&gt; rep;
    <b>int</b> i;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; s;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    amp::ampf&lt;Precision&gt; fi;
    <b>int</b> n;
    <b>int</b> m;


    
<font color=navy>    //</font>
<font color=navy>    // Example of solving polynomial approximation task using FJ scheme.</font>
<font color=navy>    //</font>
<font color=navy>    // Data points:</font>
<font color=navy>    //     xi are random numbers from [-1,+1],</font>
<font color=navy>    //</font>
<font color=navy>    // Function being fitted:</font>
<font color=navy>    //     yi = exp(xi) - sin(xi) - x^3/3</font>
<font color=navy>    //</font>
<font color=navy>    // Function being minimized:</font>
<font color=navy>    //     F(a,b,c) =</font>
<font color=navy>    //         (a + b*x0 + c*x0^2 - y0)^2 +</font>
<font color=navy>    //         (a + b*x1 + c*x1^2 - y1)^2 + ...</font>
<font color=navy>    //</font>
    n = 3;
    s.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        s(i) = amp::ampf&lt;Precision&gt;::getRandom()-amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>);
    }
    m = 100;
    x.setlength(m);
    y.setlength(m);
    <b>for</b>(i=0; i&lt;=m-1; i++)
    {
        x(i) = amp::ampf&lt;Precision&gt;(2*i)/(amp::ampf&lt;Precision&gt;(m-1))-1;
        y(i) = amp::exp&lt;Precision&gt;(x(i))-amp::sin&lt;Precision&gt;(x(i))-x(i)*x(i)*x(i)/3;
    }
    
<font color=navy>    //</font>
<font color=navy>    // Now S stores starting point, X and Y store points being fitted.</font>
<font color=navy>    //</font>
    minlm::minlmcreatefj&lt;Precision&gt;(n, m, s, state);
    minlm::minlmsetcond&lt;Precision&gt;(state, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.001&quot;</font>), 0);
    <b>while</b>( minlm::minlmiteration&lt;Precision&gt;(state) )
    {
        <b>if</b>( state.needf )
        {
            state.f = 0;
        }
        <b>for</b>(i=0; i&lt;=m-1; i++)
        {
            
<font color=navy>            //</font>
<font color=navy>            // &quot;a&quot; is stored in State.X[0]</font>
<font color=navy>            // &quot;b&quot; - State.X[1]</font>
<font color=navy>            // &quot;c&quot; - State.X[2]</font>
<font color=navy>            //</font>
            fi = state.x(0)+state.x(1)*x(i)+state.x(2)*amp::sqr&lt;Precision&gt;(x(i))-y(i);
            <b>if</b>( state.needf )
            {
                
<font color=navy>                //</font>
<font color=navy>                // F is equal to sum of fi squared.</font>
<font color=navy>                //</font>
                state.f = state.f+amp::sqr&lt;Precision&gt;(fi);
            }
            <b>if</b>( state.needfij )
            {
                
<font color=navy>                //</font>
<font color=navy>                // Fi</font>
<font color=navy>                //</font>
                state.fi(i) = fi;
                
<font color=navy>                //</font>
<font color=navy>                // dFi/da</font>
<font color=navy>                //</font>
                state.j(i,0) = 1;
                
<font color=navy>                //</font>
<font color=navy>                // dFi/db</font>
<font color=navy>                //</font>
                state.j(i,1) = x(i);
                
<font color=navy>                //</font>
<font color=navy>                // dFi/dc</font>
<font color=navy>                //</font>
                state.j(i,2) = amp::sqr&lt;Precision&gt;(x(i));
            }
        }
    }
    minlm::minlmresults&lt;Precision&gt;(state, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // output results</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;A = %4.2lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(0)).toDouble()));
    printf(<font color=blue>&quot;B = %4.2lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(1)).toDouble()));
    printf(<font color=blue>&quot;C = %4.2lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(s(2)).toDouble()));
    printf(<font color=blue>&quot;TerminationType = %0ld (should be 2 - stopping when step is small enough)\n&quot;</font>,
        <b>long</b>(rep.terminationtype));

</pre><a name=unit_odesolver></a><h2><code>odesolver</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_odesolveriteration' class=toc>odesolveriteration</a><br>
<a href='#sub_odesolverresults' class=toc>odesolverresults</a><br>
<a href='#sub_odesolverrkck' class=toc>odesolverrkck</a><br>
<h3>Examples</h3>
<a href='#example_ode_example1' class=toc>ode_example1</a><br>
<a href='#example_ode_example2' class=toc>ode_example2</a><br>
<a name='sub_odesolveriteration'></a><h3><code>odesolveriteration</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
One iteration of ODE solver.

Called after inialization of State structure with OdeSolverXXX subroutine.
See HTML docs for examples.

INPUT PARAMETERS:
    State   -   structure which stores algorithm state between subsequent
                calls and which is used for reverse communication. Must be
                initialized with OdeSolverXXX() call first.

If subroutine returned False, algorithm have finished its work.
If subroutine returned True, then user should:
* calculate F(State.X, State.Y)
* store it in State.DY
Here State.X is real, State.Y and State.DY are arrays[0..N-1] of reals.

  -- ALGLIB --
     Copyright 01.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> odesolveriteration(odesolverstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ode_example1' class=nav>ode_example1</a>&nbsp;&nbsp;<a href='#example_ode_example2' class=nav>ode_example2</a>&nbsp;&nbsp;</p>
<a name='sub_odesolverresults'></a><h3><code>odesolverresults</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
ODE solver results

Called after OdeSolverIteration returned False.

INPUT PARAMETERS:
    State   -   algorithm state (used by OdeSolverIteration).

OUTPUT PARAMETERS:
    M       -   number of tabulated values, M&gt;=1
    XTbl    -   array[0..M-1], values of X
    YTbl    -   array[0..M-1,0..N-1], values of Y in X[i]
    Rep     -   solver report:
                * Rep.TerminationType completetion code:
                    * -2    X is not ordered  by  ascending/descending  or
                            there are non-distinct X[],  i.e.  X[i]=X[i+1]
                    * -1    incorrect parameters were specified
                    *  1    task has been solved
                * Rep.NFEV contains number of function calculations

  -- ALGLIB --
     Copyright 01.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> odesolverresults(<b>const</b> odesolverstate&lt;Precision&gt;&amp; state,
    <b>int</b>&amp; m,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xtbl,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; ytbl,
    odesolverreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ode_example1' class=nav>ode_example1</a>&nbsp;&nbsp;<a href='#example_ode_example2' class=nav>ode_example2</a>&nbsp;&nbsp;</p>
<a name='sub_odesolverrkck'></a><h3><code>odesolverrkck</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cash-Karp adaptive ODE solver.

This subroutine solves ODE  Y'=f(Y,x)  with  initial  conditions  Y(xs)=Ys
(here Y may be single variable or vector of N variables).

INPUT PARAMETERS:
    Y       -   initial conditions, array[0..N-1].
                contains values of Y[] at X[0]
    N       -   system size
    X       -   points at which Y should be tabulated, array[0..M-1]
                integrations starts at X[0], ends at X[M-1],  intermediate
                values at X[i] are returned too.
                SHOULD BE ORDERED BY ASCENDING OR BY DESCENDING!!!!
    M       -   number of intermediate points + first point + last point:
                * M&gt;2 means that you need both Y(X[M-1]) and M-2 values at
                  intermediate points
                * M=2 means that you want just to integrate from  X[0]  to
                  X[1] and don't interested in intermediate values.
                * M=1 means that you don't want to integrate :)
                  it is degenerate case, but it will be handled correctly.
                * M&lt;1 means error
    Eps     -   tolerance (absolute/relative error on each  step  will  be
                less than Eps). When passing:
                * Eps&gt;0, it means desired ABSOLUTE error
                * Eps&lt;0, it means desired RELATIVE error.  Relative errors
                  are calculated with respect to maximum values of  Y seen
                  so far. Be careful to use this criterion  when  starting
                  from Y[] that are close to zero.
    H       -   initial  step  lenth,  it  will  be adjusted automatically
                after the first  step.  If  H=0,  step  will  be  selected
                automatically  (usualy  it  will  be  equal  to  0.001  of
                min(x[i]-x[j])).

OUTPUT PARAMETERS
    State   -   structure which stores algorithm state between  subsequent
                calls of OdeSolverIteration. Used for reverse communication.
                This structure should be passed  to the OdeSolverIteration
                subroutine.

SEE ALSO
    AutoGKSmoothW, AutoGKSingular, AutoGKIteration, AutoGKResults.


  -- ALGLIB --
     Copyright 01.09.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> odesolverrkck(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>int</b> m,
    amp::ampf&lt;Precision&gt; eps,
    amp::ampf&lt;Precision&gt; h,
    odesolverstate&lt;Precision&gt;&amp; state);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ode_example1' class=nav>ode_example1</a>&nbsp;&nbsp;<a href='#example_ode_example2' class=nav>ode_example2</a>&nbsp;&nbsp;</p>
<a name='example_ode_example1'></a><h3>ode_example1 example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; ytbl;
    amp::ampf&lt;Precision&gt; eps;
    amp::ampf&lt;Precision&gt; h;
    <b>int</b> m;
    <b>int</b> i;
    odesolver::odesolverstate&lt;Precision&gt; state;
    odesolver::odesolverreport&lt;Precision&gt; rep;


    
<font color=navy>    //</font>
<font color=navy>    // ODESolver unit is used to solve simple ODE:</font>
<font color=navy>    // y' = y, y(0) = 1.</font>
<font color=navy>    //</font>
<font color=navy>    // Its solution is well known in academic circles :)</font>
<font color=navy>    //</font>
<font color=navy>    // No intermediate values are calculated,</font>
<font color=navy>    // just starting and final points.</font>
<font color=navy>    //</font>
    y.setlength(1);
    y(0) = 1;
    x.setlength(2);
    x(0) = 0;
    x(1) = 1;
    eps = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0E-4&quot;</font>);
    h = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.01&quot;</font>);
    odesolver::odesolverrkck&lt;Precision&gt;(y, 1, x, 2, eps, h, state);
    <b>while</b>( odesolver::odesolveriteration&lt;Precision&gt;(state) )
    {
        state.dy(0) = state.y(0);
    }
    odesolver::odesolverresults&lt;Precision&gt;(state, m, x, ytbl, rep);
    printf(<font color=blue>&quot;    X  Y(X)\n&quot;</font>);
    <b>for</b>(i=0; i&lt;=m-1; i++)
    {
        printf(<font color=blue>&quot;%5.3lf %5.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(x(i)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(ytbl(i,0)).toDouble()));
    }

</pre><a name='example_ode_example2'></a><h3>ode_example2 example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; ytbl;
    amp::ampf&lt;Precision&gt; eps;
    amp::ampf&lt;Precision&gt; h;
    <b>int</b> m;
    <b>int</b> i;
    odesolver::odesolverstate&lt;Precision&gt; state;
    odesolver::odesolverreport&lt;Precision&gt; rep;


    
<font color=navy>    //</font>
<font color=navy>    // ODESolver unit is used to solve simple ODE:</font>
<font color=navy>    // y'' = -y, y(0) = 0, y'(0)=1.</font>
<font color=navy>    //</font>
<font color=navy>    // This ODE may be written as first-order system:</font>
<font color=navy>    // y' =  z</font>
<font color=navy>    // z' = -y</font>
<font color=navy>    //</font>
<font color=navy>    // Its solution is well known in academic circles :)</font>
<font color=navy>    //</font>
<font color=navy>    // Three intermediate values are calculated,</font>
<font color=navy>    // plus starting and final points.</font>
<font color=navy>    //</font>
    y.setlength(2);
    y(0) = 0;
    y(1) = 1;
    x.setlength(5);
    x(0) = amp::pi&lt;Precision&gt;()*0/4;
    x(1) = amp::pi&lt;Precision&gt;()*1/4;
    x(2) = amp::pi&lt;Precision&gt;()*2/4;
    x(3) = amp::pi&lt;Precision&gt;()*3/4;
    x(4) = amp::pi&lt;Precision&gt;()*4/4;
    eps = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0E-8&quot;</font>);
    h = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.01&quot;</font>);
    odesolver::odesolverrkck&lt;Precision&gt;(y, 2, x, 5, eps, h, state);
    <b>while</b>( odesolver::odesolveriteration&lt;Precision&gt;(state) )
    {
        state.dy(0) = state.y(1);
        state.dy(1) = -state.y(0);
    }
    odesolver::odesolverresults&lt;Precision&gt;(state, m, x, ytbl, rep);
    printf(<font color=blue>&quot;     X   Y(X)     Error\n&quot;</font>);
    <b>for</b>(i=0; i&lt;=m-1; i++)
    {
        printf(<font color=blue>&quot;%6.3lf %6.3lf  %8.1le\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(x(i)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(ytbl(i,0)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::abs&lt;Precision&gt;(ytbl(i,0)-amp::sin&lt;Precision&gt;(x(i)))).toDouble()));
    }

</pre><a name=unit_ortfac></a><h2><code>ortfac</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixlq' class=toc>cmatrixlq</a><br>
<a href='#sub_cmatrixlqunpackl' class=toc>cmatrixlqunpackl</a><br>
<a href='#sub_cmatrixlqunpackq' class=toc>cmatrixlqunpackq</a><br>
<a href='#sub_cmatrixqr' class=toc>cmatrixqr</a><br>
<a href='#sub_cmatrixqrunpackq' class=toc>cmatrixqrunpackq</a><br>
<a href='#sub_cmatrixqrunpackr' class=toc>cmatrixqrunpackr</a><br>
<a href='#sub_hmatrixtd' class=toc>hmatrixtd</a><br>
<a href='#sub_hmatrixtdunpackq' class=toc>hmatrixtdunpackq</a><br>
<a href='#sub_rmatrixbd' class=toc>rmatrixbd</a><br>
<a href='#sub_rmatrixbdmultiplybyp' class=toc>rmatrixbdmultiplybyp</a><br>
<a href='#sub_rmatrixbdmultiplybyq' class=toc>rmatrixbdmultiplybyq</a><br>
<a href='#sub_rmatrixbdunpackdiagonals' class=toc>rmatrixbdunpackdiagonals</a><br>
<a href='#sub_rmatrixbdunpackpt' class=toc>rmatrixbdunpackpt</a><br>
<a href='#sub_rmatrixbdunpackq' class=toc>rmatrixbdunpackq</a><br>
<a href='#sub_rmatrixhessenberg' class=toc>rmatrixhessenberg</a><br>
<a href='#sub_rmatrixhessenbergunpackh' class=toc>rmatrixhessenbergunpackh</a><br>
<a href='#sub_rmatrixhessenbergunpackq' class=toc>rmatrixhessenbergunpackq</a><br>
<a href='#sub_rmatrixlq' class=toc>rmatrixlq</a><br>
<a href='#sub_rmatrixlqunpackl' class=toc>rmatrixlqunpackl</a><br>
<a href='#sub_rmatrixlqunpackq' class=toc>rmatrixlqunpackq</a><br>
<a href='#sub_rmatrixqr' class=toc>rmatrixqr</a><br>
<a href='#sub_rmatrixqrunpackq' class=toc>rmatrixqrunpackq</a><br>
<a href='#sub_rmatrixqrunpackr' class=toc>rmatrixqrunpackr</a><br>
<a href='#sub_smatrixtd' class=toc>smatrixtd</a><br>
<a href='#sub_smatrixtdunpackq' class=toc>smatrixtdunpackq</a><br>
<a name='sub_cmatrixlq'></a><h3><code>cmatrixlq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LQ decomposition of a rectangular complex matrix of size MxN

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices Q and L in compact form
    Tau -   array of scalar factors which are used to form matrix Q. Array
            whose indexes range within [0.. Min(M,N)-1]

Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
MxM, L - lower triangular (or lower trapezoid) matrix of size MxN.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlq(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; tau);
</div></pre>
<a name='sub_cmatrixlqunpackl'></a><h3><code>cmatrixlqunpackl</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix L from the LQ decomposition of a matrix A

Input parameters:
    A       -   matrices Q and L in compact form.
                Output of CMatrixLQ subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    L       -   matrix L, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlqunpackl(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; l);
</div></pre>
<a name='sub_cmatrixlqunpackq'></a><h3><code>cmatrixlqunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from LQ decomposition of a complex matrix A.

Input parameters:
    A           -   matrices Q and R in compact form.
                    Output of CMatrixLQ subroutine .
    M           -   number of rows in matrix A. M&gt;=0.
    N           -   number of columns in matrix A. N&gt;=0.
    Tau         -   scalar factors which are used to form Q.
                    Output of CMatrixLQ subroutine .
    QRows       -   required number of rows in matrix Q. N&gt;=QColumns&gt;=0.

Output parameters:
    Q           -   first QRows rows of matrix Q.
                    Array whose index ranges within [0..QRows-1, 0..N-1].
                    If QRows=0, array isn't changed.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlqunpackq(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; tau,
    <b>int</b> qrows,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_cmatrixqr'></a><h3><code>cmatrixqr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
QR decomposition of a rectangular complex matrix of size MxN

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1]
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices Q and R in compact form
    Tau -   array of scalar factors which are used to form matrix Q. Array
            whose indexes range within [0.. Min(M,N)-1]

Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
MxM, R - upper triangular (or upper trapezoid) matrix of size MxN.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixqr(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; tau);
</div></pre>
<a name='sub_cmatrixqrunpackq'></a><h3><code>cmatrixqrunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from QR decomposition of a complex matrix A.

Input parameters:
    A           -   matrices Q and R in compact form.
                    Output of CMatrixQR subroutine .
    M           -   number of rows in matrix A. M&gt;=0.
    N           -   number of columns in matrix A. N&gt;=0.
    Tau         -   scalar factors which are used to form Q.
                    Output of CMatrixQR subroutine .
    QColumns    -   required number of columns in matrix Q. M&gt;=QColumns&gt;=0.

Output parameters:
    Q           -   first QColumns columns of matrix Q.
                    Array whose index ranges within [0..M-1, 0..QColumns-1].
                    If QColumns=0, array isn't changed.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixqrunpackq(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; tau,
    <b>int</b> qcolumns,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_cmatrixqrunpackr'></a><h3><code>cmatrixqrunpackr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix R from the QR decomposition of a matrix A

Input parameters:
    A       -   matrices Q and R in compact form.
                Output of CMatrixQR subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    R       -   matrix R, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixqrunpackr(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_hmatrixtd'></a><h3><code>hmatrixtd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a Hermitian matrix which is given  by  its  higher  or  lower
triangular part to a real  tridiagonal  matrix  using  unitary  similarity
transformation: Q'*A*Q = T.

Input parameters:
    A       -   matrix to be transformed
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format. If IsUpper = True, then matrix A is  given
                by its upper triangle, and the lower triangle is not  used
                and not modified by the algorithm, and vice versa
                if IsUpper = False.

Output parameters:
    A       -   matrices T and Q in  compact form (see lower)
    Tau     -   array of factors which are forming matrices H(i)
                array with elements [0..N-2].
    D       -   main diagonal of real symmetric matrix T.
                array with elements [0..N-1].
    E       -   secondary diagonal of real symmetric matrix T.
                array with elements [0..N-2].


  If IsUpper=True, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(n-2) . . . H(2) H(0).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a complex scalar, and v is a complex vector with
  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
  A(0:i-1,i+1), and tau in TAU(i).

  If IsUpper=False, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(0) H(2) . . . H(n-2).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a complex scalar, and v is a complex vector with
  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
  and tau in TAU(i).

  The contents of A on exit are illustrated by the following examples
  with n = 5:

  if UPLO = 'U':                       if UPLO = 'L':

    (  d   e   v1  v2  v3 )              (  d                  )
    (      d   e   v2  v3 )              (  e   d              )
    (          d   e   v3 )              (  v0  e   d          )
    (              d   e  )              (  v0  v1  e   d      )
    (                  d  )              (  v0  v1  v2  e   d  )

where d and e denote diagonal and off-diagonal elements of T, and vi
denotes an element of the vector defining H(i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1992
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hmatrixtd(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; tau,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; e);
</div></pre>
<a name='sub_hmatrixtdunpackq'></a><h3><code>hmatrixtdunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces a Hermitian matrix to a real  tridiagonal
form.

Input parameters:
    A       -   the result of a HMatrixTD subroutine
    N       -   size of matrix A.
    IsUpper -   storage format (a parameter of HMatrixTD subroutine)
    Tau     -   the result of a HMatrixTD subroutine

Output parameters:
    Q       -   transformation matrix.
                array with elements [0..N-1, 0..N-1].

  -- ALGLIB --
     Copyright 2005-2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> hmatrixtdunpackq(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> <b>int</b>&amp; n,
    <b>const</b> <b>bool</b>&amp; isupper,
    <b>const</b> ap::template_1d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; tau,
    ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_rmatrixbd'></a><h3><code>rmatrixbd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a rectangular matrix to  bidiagonal form

The algorithm reduces the rectangular matrix A to  bidiagonal form by
orthogonal transformations P and Q: A = Q*B*P.

Input parameters:
    A       -   source matrix. array[0..M-1, 0..N-1]
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.

Output parameters:
    A       -   matrices Q, B, P in compact form (see below).
    TauQ    -   scalar factors which are used to form matrix Q.
    TauP    -   scalar factors which are used to form matrix P.

The main diagonal and one of the  secondary  diagonals  of  matrix  A  are
replaced with bidiagonal  matrix  B.  Other  elements  contain  elementary
reflections which form MxM matrix Q and NxN matrix P, respectively.

If M&gt;=N, B is the upper  bidiagonal  MxN  matrix  and  is  stored  in  the
corresponding  elements  of  matrix  A.  Matrix  Q  is  represented  as  a
product   of   elementary   reflections   Q = H(0)*H(1)*...*H(n-1),  where
H(i) = 1-tau*v*v'. Here tau is a scalar which is stored  in  TauQ[i],  and
vector v has the following  structure:  v(0:i-1)=0, v(i)=1, v(i+1:m-1)  is
stored   in   elements   A(i+1:m-1,i).   Matrix   P  is  as  follows:  P =
G(0)*G(1)*...*G(n-2), where G(i) = 1 - tau*u*u'. Tau is stored in TauP[i],
u(0:i)=0, u(i+1)=1, u(i+2:n-1) is stored in elements A(i,i+2:n-1).

If M&lt;N, B is the  lower  bidiagonal  MxN  matrix  and  is  stored  in  the
corresponding   elements  of  matrix  A.  Q = H(0)*H(1)*...*H(m-2),  where
H(i) = 1 - tau*v*v', tau is stored in TauQ, v(0:i)=0, v(i+1)=1, v(i+2:m-1)
is    stored    in   elements   A(i+2:m-1,i).    P = G(0)*G(1)*...*G(m-1),
G(i) = 1-tau*u*u', tau is stored in  TauP,  u(0:i-1)=0, u(i)=1, u(i+1:n-1)
is stored in A(i,i+1:n-1).

EXAMPLE:

m=6, n=5 (m &gt; n):               m=5, n=6 (m &lt; n):

(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
(  v1  v2  v3  v4  v5 )

Here vi and ui are vectors which form H(i) and G(i), and d and e -
are the diagonal and off-diagonal elements of matrix B.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994.
     Sergey Bochkanov, ALGLIB project, translation from FORTRAN to
     pseudocode, 2007-2010.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixbd(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tauq,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; taup);
</div></pre>
<a name='sub_rmatrixbdmultiplybyp'></a><h3><code>rmatrixbdmultiplybyp</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication by matrix P which reduces matrix A to  bidiagonal form.

The algorithm allows pre- or post-multiply by P or P'.

Input parameters:
    QP          -   matrices Q and P in compact form.
                    Output of RMatrixBD subroutine.
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    TAUP        -   scalar factors which are used to form P.
                    Output of RMatrixBD subroutine.
    Z           -   multiplied matrix.
                    Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
                    ZRows=N, otherwise ZRows can be arbitrary.
    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
                    ZColumns=N, otherwise ZColumns can be arbitrary.
    FromTheRight -  pre- or post-multiply.
    DoTranspose -   multiply by P or P'.

Output parameters:
    Z - product of Z and P.
                Array whose indexes range within [0..ZRows-1,0..ZColumns-1].
                If ZRows=0 or ZColumns=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixbdmultiplybyp(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; qp,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; taup,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z,
    <b>int</b> zrows,
    <b>int</b> zcolumns,
    <b>bool</b> fromtheright,
    <b>bool</b> dotranspose);
</div></pre>
<a name='sub_rmatrixbdmultiplybyq'></a><h3><code>rmatrixbdmultiplybyq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Multiplication by matrix Q which reduces matrix A to  bidiagonal form.

The algorithm allows pre- or post-multiply by Q or Q'.

Input parameters:
    QP          -   matrices Q and P in compact form.
                    Output of ToBidiagonal subroutine.
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    TAUQ        -   scalar factors which are used to form Q.
                    Output of ToBidiagonal subroutine.
    Z           -   multiplied matrix.
                    array[0..ZRows-1,0..ZColumns-1]
    ZRows       -   number of rows in matrix Z. If FromTheRight=False,
                    ZRows=M, otherwise ZRows can be arbitrary.
    ZColumns    -   number of columns in matrix Z. If FromTheRight=True,
                    ZColumns=M, otherwise ZColumns can be arbitrary.
    FromTheRight -  pre- or post-multiply.
    DoTranspose -   multiply by Q or Q'.

Output parameters:
    Z           -   product of Z and Q.
                    Array[0..ZRows-1,0..ZColumns-1]
                    If ZRows=0 or ZColumns=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixbdmultiplybyq(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; qp,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tauq,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z,
    <b>int</b> zrows,
    <b>int</b> zcolumns,
    <b>bool</b> fromtheright,
    <b>bool</b> dotranspose);
</div></pre>
<a name='sub_rmatrixbdunpackdiagonals'></a><h3><code>rmatrixbdunpackdiagonals</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of the main and secondary diagonals of bidiagonal decomposition
of matrix A.

Input parameters:
    B   -   output of RMatrixBD subroutine.
    M   -   number of rows in matrix B.
    N   -   number of columns in matrix B.

Output parameters:
    IsUpper -   True, if the matrix is upper bidiagonal.
                otherwise IsUpper is False.
    D       -   the main diagonal.
                Array whose index ranges within [0..Min(M,N)-1].
    E       -   the secondary diagonal (upper or lower, depending on
                the value of IsUpper).
                Array index ranges within [0..Min(M,N)-1], the last
                element is not used.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixbdunpackdiagonals(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> m,
    <b>int</b> n,
    <b>bool</b>&amp; isupper,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; e);
</div></pre>
<a name='sub_rmatrixbdunpackpt'></a><h3><code>rmatrixbdunpackpt</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix P which reduces matrix A to bidiagonal form.
The subroutine returns transposed matrix P.

Input parameters:
    QP      -   matrices Q and P in compact form.
                Output of ToBidiagonal subroutine.
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.
    TAUP    -   scalar factors which are used to form P.
                Output of ToBidiagonal subroutine.
    PTRows  -   required number of rows of matrix P^T. N &gt;= PTRows &gt;= 0.

Output parameters:
    PT      -   first PTRows columns of matrix P^T
                Array[0..PTRows-1, 0..N-1]
                If PTRows=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixbdunpackpt(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; qp,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; taup,
    <b>int</b> ptrows,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; pt);
</div></pre>
<a name='sub_rmatrixbdunpackq'></a><h3><code>rmatrixbdunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces a matrix to bidiagonal form.

Input parameters:
    QP          -   matrices Q and P in compact form.
                    Output of ToBidiagonal subroutine.
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    TAUQ        -   scalar factors which are used to form Q.
                    Output of ToBidiagonal subroutine.
    QColumns    -   required number of columns in matrix Q.
                    M&gt;=QColumns&gt;=0.

Output parameters:
    Q           -   first QColumns columns of matrix Q.
                    Array[0..M-1, 0..QColumns-1]
                    If QColumns=0, the array is not modified.

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixbdunpackq(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; qp,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tauq,
    <b>int</b> qcolumns,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_rmatrixhessenberg'></a><h3><code>rmatrixhessenberg</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a square matrix to  upper Hessenberg form: Q'*A*Q = H,
where Q is an orthogonal matrix, H - Hessenberg matrix.

Input parameters:
    A       -   matrix A with elements [0..N-1, 0..N-1]
    N       -   size of matrix A.

Output parameters:
    A       -   matrices Q and P in  compact form (see below).
    Tau     -   array of scalar factors which are used to form matrix Q.
                Array whose index ranges within [0..N-2]

Matrix H is located on the main diagonal, on the lower secondary  diagonal
and above the main diagonal of matrix A. The elements which are used to
form matrix Q are situated in array Tau and below the lower secondary
diagonal of matrix A as follows:

Matrix Q is represented as a product of elementary reflections

Q = H(0)*H(2)*...*H(n-2),

where each H(i) is given by

H(i) = 1 - tau * v * (v^T)

where tau is a scalar stored in Tau[I]; v - is a real vector,
so that v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) stored in A(i+2:n-1,i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1992
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixhessenberg(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau);
</div></pre>
<a name='sub_rmatrixhessenbergunpackh'></a><h3><code>rmatrixhessenbergunpackh</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix H (the result of matrix A reduction to upper Hessenberg form)

Input parameters:
    A   -   output of RMatrixHessenberg subroutine.
    N   -   size of matrix A.

Output parameters:
    H   -   matrix H. Array whose indexes range within [0..N-1, 0..N-1].

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixhessenbergunpackh(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; h);
</div></pre>
<a name='sub_rmatrixhessenbergunpackq'></a><h3><code>rmatrixhessenbergunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces matrix A to upper Hessenberg form

Input parameters:
    A   -   output of RMatrixHessenberg subroutine.
    N   -   size of matrix A.
    Tau -   scalar factors which are used to form Q.
            Output of RMatrixHessenberg subroutine.

Output parameters:
    Q   -   matrix Q.
            Array whose indexes range within [0..N-1, 0..N-1].

  -- ALGLIB --
     2005-2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixhessenbergunpackq(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_rmatrixlq'></a><h3><code>rmatrixlq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LQ decomposition of a rectangular matrix of size MxN

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices L and Q in compact form (see below)
    Tau -   array of scalar factors which are used to form
            matrix Q. Array whose index ranges within [0..Min(M,N)-1].

Matrix A is represented as A = LQ, where Q is an orthogonal matrix of size
MxM, L - lower triangular (or lower trapezoid) matrix of size M x N.

The elements of matrix L are located on and below  the  main  diagonal  of
matrix A. The elements which are located in Tau array and above  the  main
diagonal of matrix A are used to form matrix Q as follows:

Matrix Q is represented as a product of elementary reflections

Q = H(k-1)*H(k-2)*...*H(1)*H(0),

where k = min(m,n), and each H(i) is of the form

H(i) = 1 - tau * v * (v^T)

where tau is a scalar stored in Tau[I]; v - real vector, so that v(0:i-1)=0,
v(i) = 1, v(i+1:n-1) stored in A(i,i+1:n-1).

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlq(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau);
</div></pre>
<a name='sub_rmatrixlqunpackl'></a><h3><code>rmatrixlqunpackl</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix L from the LQ decomposition of a matrix A

Input parameters:
    A       -   matrices Q and L in compact form.
                Output of RMatrixLQ subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    L       -   matrix L, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlqunpackl(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; l);
</div></pre>
<a name='sub_rmatrixlqunpackq'></a><h3><code>rmatrixlqunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from the LQ decomposition of a matrix A

Input parameters:
    A       -   matrices L and Q in compact form.
                Output of RMatrixLQ subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.
    Tau     -   scalar factors which are used to form Q.
                Output of the RMatrixLQ subroutine.
    QRows   -   required number of rows in matrix Q. N&gt;=QRows&gt;=0.

Output parameters:
    Q       -   first QRows rows of matrix Q. Array whose indexes range
                within [0..QRows-1, 0..N-1]. If QRows=0, the array remains
                unchanged.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlqunpackq(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau,
    <b>int</b> qrows,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_rmatrixqr'></a><h3><code>rmatrixqr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
QR decomposition of a rectangular matrix of size MxN

Input parameters:
    A   -   matrix A whose indexes range within [0..M-1, 0..N-1].
    M   -   number of rows in matrix A.
    N   -   number of columns in matrix A.

Output parameters:
    A   -   matrices Q and R in compact form (see below).
    Tau -   array of scalar factors which are used to form
            matrix Q. Array whose index ranges within [0.. Min(M-1,N-1)].

Matrix A is represented as A = QR, where Q is an orthogonal matrix of size
MxM, R - upper triangular (or upper trapezoid) matrix of size M x N.

The elements of matrix R are located on and above the main diagonal of
matrix A. The elements which are located in Tau array and below the main
diagonal of matrix A are used to form matrix Q as follows:

Matrix Q is represented as a product of elementary reflections

Q = H(0)*H(2)*...*H(k-1),

where k = min(m,n), and each H(i) is in the form

H(i) = 1 - tau * v * (v^T)

where tau is a scalar stored in Tau[I]; v - real vector,
so that v(0:i-1) = 0, v(i) = 1, v(i+1:m-1) stored in A(i+1:m-1,i).

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixqr(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau);
</div></pre>
<a name='sub_rmatrixqrunpackq'></a><h3><code>rmatrixqrunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Partial unpacking of matrix Q from the QR decomposition of a matrix A

Input parameters:
    A       -   matrices Q and R in compact form.
                Output of RMatrixQR subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.
    Tau     -   scalar factors which are used to form Q.
                Output of the RMatrixQR subroutine.
    QColumns -  required number of columns of matrix Q. M&gt;=QColumns&gt;=0.

Output parameters:
    Q       -   first QColumns columns of matrix Q.
                Array whose indexes range within [0..M-1, 0..QColumns-1].
                If QColumns=0, the array remains unchanged.

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixqrunpackq(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau,
    <b>int</b> qcolumns,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name='sub_rmatrixqrunpackr'></a><h3><code>rmatrixqrunpackr</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking of matrix R from the QR decomposition of a matrix A

Input parameters:
    A       -   matrices Q and R in compact form.
                Output of RMatrixQR subroutine.
    M       -   number of rows in given matrix A. M&gt;=0.
    N       -   number of columns in given matrix A. N&gt;=0.

Output parameters:
    R       -   matrix R, array[0..M-1, 0..N-1].

  -- ALGLIB routine --
     17.02.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixqrunpackr(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r);
</div></pre>
<a name='sub_smatrixtd'></a><h3><code>smatrixtd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Reduction of a symmetric matrix which is given by its higher or lower
triangular part to a tridiagonal matrix using orthogonal similarity
transformation: Q'*A*Q=T.

Input parameters:
    A       -   matrix to be transformed
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format. If IsUpper = True, then matrix A is given
                by its upper triangle, and the lower triangle is not used
                and not modified by the algorithm, and vice versa
                if IsUpper = False.

Output parameters:
    A       -   matrices T and Q in  compact form (see lower)
    Tau     -   array of factors which are forming matrices H(i)
                array with elements [0..N-2].
    D       -   main diagonal of symmetric matrix T.
                array with elements [0..N-1].
    E       -   secondary diagonal of symmetric matrix T.
                array with elements [0..N-2].


  If IsUpper=True, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(n-2) . . . H(2) H(0).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a real scalar, and v is a real vector with
  v(i+1:n-1) = 0, v(i) = 1, v(0:i-1) is stored on exit in
  A(0:i-1,i+1), and tau in TAU(i).

  If IsUpper=False, the matrix Q is represented as a product of elementary
  reflectors

     Q = H(0) H(2) . . . H(n-2).

  Each H(i) has the form

     H(i) = I - tau * v * v'

  where tau is a real scalar, and v is a real vector with
  v(0:i) = 0, v(i+1) = 1, v(i+2:n-1) is stored on exit in A(i+2:n-1,i),
  and tau in TAU(i).

  The contents of A on exit are illustrated by the following examples
  with n = 5:

  if UPLO = 'U':                       if UPLO = 'L':

    (  d   e   v1  v2  v3 )              (  d                  )
    (      d   e   v2  v3 )              (  e   d              )
    (          d   e   v3 )              (  v0  e   d          )
    (              d   e  )              (  v0  v1  e   d      )
    (                  d  )              (  v0  v1  v2  e   d  )

  where d and e denote diagonal and off-diagonal elements of T, and vi
  denotes an element of the vector defining H(i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1992
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> smatrixtd(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; e);
</div></pre>
<a name='sub_smatrixtdunpackq'></a><h3><code>smatrixtdunpackq</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unpacking matrix Q which reduces symmetric matrix to a tridiagonal
form.

Input parameters:
    A       -   the result of a SMatrixTD subroutine
    N       -   size of matrix A.
    IsUpper -   storage format (a parameter of SMatrixTD subroutine)
    Tau     -   the result of a SMatrixTD subroutine

Output parameters:
    Q       -   transformation matrix.
                array with elements [0..N-1, 0..N-1].

  -- ALGLIB --
     Copyright 2005-2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> smatrixtdunpackq(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> <b>int</b>&amp; n,
    <b>const</b> <b>bool</b>&amp; isupper,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tau,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; q);
</div></pre>
<a name=unit_polint></a><h2><code>polint</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_polynomialfitreport' class=toc>polynomialfitreport</a><br>
<h3>Functions</h3>
<a href='#sub_polynomialbuild' class=toc>polynomialbuild</a><br>
<a href='#sub_polynomialbuildcheb1' class=toc>polynomialbuildcheb1</a><br>
<a href='#sub_polynomialbuildcheb2' class=toc>polynomialbuildcheb2</a><br>
<a href='#sub_polynomialbuildeqdist' class=toc>polynomialbuildeqdist</a><br>
<a href='#sub_polynomialcalccheb1' class=toc>polynomialcalccheb1</a><br>
<a href='#sub_polynomialcalccheb2' class=toc>polynomialcalccheb2</a><br>
<a href='#sub_polynomialcalceqdist' class=toc>polynomialcalceqdist</a><br>
<a href='#sub_polynomialfit' class=toc>polynomialfit</a><br>
<a href='#sub_polynomialfitwc' class=toc>polynomialfitwc</a><br>
<h3>Examples</h3>
<a href='#example_polint_cheb1' class=toc>polint_cheb1</a><br>
<a href='#example_polint_cheb2' class=toc>polint_cheb2</a><br>
<a href='#example_polint_eqdist' class=toc>polint_eqdist</a><br>
<a href='#example_polint_fit' class=toc>polint_fit</a><br>
<a href='#example_polint_gen' class=toc>polint_gen</a><br>
<a name='struct_polynomialfitreport'></a><h3><code>polynomialfitreport</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Polynomial fitting report:
    TaskRCond       reciprocal of task's condition number
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> polynomialfitreport
{
<b>public</b>:
    amp::ampf&lt;Precision&gt; taskrcond;
    amp::ampf&lt;Precision&gt; rmserror;
    amp::ampf&lt;Precision&gt; avgerror;
    amp::ampf&lt;Precision&gt; avgrelerror;
    amp::ampf&lt;Precision&gt; maxerror;
};
</div></pre>
<a name='sub_polynomialbuild'></a><h3><code>polynomialbuild</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant: generation of the model on the general grid.
This function has O(N^2) complexity.

INPUT PARAMETERS:
    X   -   abscissas, array[0..N-1]
    Y   -   function values, array[0..N-1]
    N   -   number of points, N&gt;=1

OIYTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> polynomialbuild(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    ratint::barycentricinterpolant&lt;Precision&gt;&amp; p);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_gen' class=nav>polint_gen</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildcheb1'></a><h3><code>polynomialbuildcheb1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant on Chebyshev grid (first kind).
This function has O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    Y   -   function values at the nodes, array[0..N-1],
            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
    N   -   number of points, N&gt;=1
            for N=1 a constant model is constructed.

OIYTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 03.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> polynomialbuildcheb1(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    ratint::barycentricinterpolant&lt;Precision&gt;&amp; p);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_cheb1' class=nav>polint_cheb1</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildcheb2'></a><h3><code>polynomialbuildcheb2</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant on Chebyshev grid (second kind).
This function has O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    Y   -   function values at the nodes, array[0..N-1],
            Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
    N   -   number of points, N&gt;=1
            for N=1 a constant model is constructed.

OIYTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 03.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> polynomialbuildcheb2(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    ratint::barycentricinterpolant&lt;Precision&gt;&amp; p);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_cheb2' class=nav>polint_cheb2</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialbuildeqdist'></a><h3><code>polynomialbuildeqdist</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Lagrange intepolant: generation of the model on equidistant grid.
This function has O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    Y   -   function values at the nodes, array[0..N-1]
    N   -   number of points, N&gt;=1
            for N=1 a constant model is constructed.

OIYTPUT PARAMETERS
    P   -   barycentric model which represents Lagrange interpolant
            (see ratint unit info and BarycentricCalc() description for
            more information).

  -- ALGLIB --
     Copyright 03.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> polynomialbuildeqdist(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    ratint::barycentricinterpolant&lt;Precision&gt;&amp; p);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_eqdist' class=nav>polint_eqdist</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialcalccheb1'></a><h3><code>polynomialcalccheb1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fast polynomial interpolation function on Chebyshev points (first kind)
with O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    F   -   function values, array[0..N-1]
    N   -   number of points on Chebyshev grid (first kind),
            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
            for N=1 a constant model is constructed.
    T   -   position where P(x) is calculated

RESULT
    value of the Lagrange interpolant at T

IMPORTANT
    this function provides fast interface which is not overflow-safe
    nor it is very precise.
    the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
    subroutines unless you are pretty sure that your data will not result
    in overflow.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; polynomialcalccheb1(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; f,
    <b>int</b> n,
    amp::ampf&lt;Precision&gt; t);
</div></pre>
<a name='sub_polynomialcalccheb2'></a><h3><code>polynomialcalccheb2</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fast polynomial interpolation function on Chebyshev points (second kind)
with O(N) complexity.

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    F   -   function values, array[0..N-1]
    N   -   number of points on Chebyshev grid (second kind),
            X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
            for N=1 a constant model is constructed.
    T   -   position where P(x) is calculated

RESULT
    value of the Lagrange interpolant at T

IMPORTANT
    this function provides fast interface which is not overflow-safe
    nor it is very precise.
    the best option is to use PolIntBuildCheb2()/BarycentricCalc()
    subroutines unless you are pretty sure that your data will not result
    in overflow.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; polynomialcalccheb2(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; f,
    <b>int</b> n,
    amp::ampf&lt;Precision&gt; t);
</div></pre>
<a name='sub_polynomialcalceqdist'></a><h3><code>polynomialcalceqdist</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Fast equidistant polynomial interpolation function with O(N) complexity

INPUT PARAMETERS:
    A   -   left boundary of [A,B]
    B   -   right boundary of [A,B]
    F   -   function values, array[0..N-1]
    N   -   number of points on equidistant grid, N&gt;=1
            for N=1 a constant model is constructed.
    T   -   position where P(x) is calculated

RESULT
    value of the Lagrange interpolant at T
    
IMPORTANT
    this function provides fast interface which is not overflow-safe
    nor it is very precise.
    the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
    subroutines unless you are pretty sure that your data will not result
    in overflow.

  -- ALGLIB --
     Copyright 02.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; polynomialcalceqdist(amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; f,
    <b>int</b> n,
    amp::ampf&lt;Precision&gt; t);
</div></pre>
<a name='sub_polynomialfit'></a><h3><code>polynomialfit</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting by polynomial.

This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
rich PolynomialFitWC().  See  PolynomialFitWC() for more information about
subroutine parameters (we don't duplicate it here because of length)

  -- ALGLIB PROJECT --
     Copyright 12.10.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> polynomialfit(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b>&amp; info,
    ratint::barycentricinterpolant&lt;Precision&gt;&amp; p,
    polynomialfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_fit' class=nav>polint_fit</a>&nbsp;&nbsp;</p>
<a name='sub_polynomialfitwc'></a><h3><code>polynomialfitwc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted  fitting  by  Chebyshev  polynomial  in  barycentric  form,  with
constraints on function values or first derivatives.

Small regularizing term is used when solving constrained tasks (to improve
stability).

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO:
    PolynomialFit()

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points, N&gt;0.
    XC  -   points where polynomial values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that P(XC[i])=YC[i]
            * DC[i]=1   means that P'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints, 0&lt;=K&lt;M.
            K=0 means no constraints (XC/YC/DC are not used in such cases)
    M   -   number of basis functions (= polynomial_degree + 1), M&gt;=1

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearW() subroutine:
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
                        -1 means another errors in parameters passed
                           (N&lt;=0, for example)
    P   -   interpolant in barycentric form.
    Rep -   report, same format as in LSFitLinearW() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained regression splines:
* even simple constraints can be inconsistent, see  Wikipedia  article  on
  this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints is NOT GUARANTEED.
* in the one special cases, however, we can  guarantee  consistency.  This
  case  is:  M&gt;1  and constraints on the function values (NOT DERIVATIVES)

Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.

  -- ALGLIB PROJECT --
     Copyright 10.12.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> polynomialfitwc(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>int</b> n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; xc,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; yc,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; dc,
    <b>int</b> k,
    <b>int</b> m,
    <b>int</b>&amp; info,
    ratint::barycentricinterpolant&lt;Precision&gt;&amp; p,
    polynomialfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_polint_fit' class=nav>polint_fit</a>&nbsp;&nbsp;</p>
<a name='example_polint_cheb1'></a><h3>polint_cheb1 example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    ratint::barycentricinterpolant&lt;Precision&gt; p;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;
    amp::ampf&lt;Precision&gt; d2v;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Demonstration</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;POLYNOMIAL INTERPOLATION\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi]\n&quot;</font>);
    printf(<font color=blue>&quot;Second degree polynomial is used\n\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create polynomial interpolant</font>
<font color=navy>    //</font>
    n = 3;
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        y(i) = amp::sin&lt;Precision&gt;(amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>)*amp::pi&lt;Precision&gt;()*(amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>)+amp::cos&lt;Precision&gt;(amp::pi&lt;Precision&gt;()*(2*i+1)/(2*n))));
    }
    polint::polynomialbuildcheb1&lt;Precision&gt;(amp::ampf&lt;Precision&gt;(0), amp::pi&lt;Precision&gt;(), y, n, p);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    ratint::barycentricdiff2&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0), v, dv, d2v);
    printf(<font color=blue>&quot;                 P(x)    F(x) \n&quot;</font>);
    printf(<font color=blue>&quot;function       %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(ratint::barycentriccalc&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0))).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;d/dx(0)        %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(1).toDouble()));
    printf(<font color=blue>&quot;d2/dx2(0)      %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(d2v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_polint_cheb2'></a><h3>polint_cheb2 example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    ratint::barycentricinterpolant&lt;Precision&gt; p;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;
    amp::ampf&lt;Precision&gt; d2v;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Demonstration</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;POLYNOMIAL INTERPOLATION\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi]\n&quot;</font>);
    printf(<font color=blue>&quot;Second degree polynomial is used\n\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create polynomial interpolant</font>
<font color=navy>    //</font>
    n = 3;
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        y(i) = amp::sin&lt;Precision&gt;(amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.5&quot;</font>)*amp::pi&lt;Precision&gt;()*(amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>)+amp::cos&lt;Precision&gt;(amp::pi&lt;Precision&gt;()*i/(n-1))));
    }
    polint::polynomialbuildcheb2&lt;Precision&gt;(amp::ampf&lt;Precision&gt;(0), amp::pi&lt;Precision&gt;(), y, n, p);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    ratint::barycentricdiff2&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0), v, dv, d2v);
    printf(<font color=blue>&quot;                 P(x)    F(x) \n&quot;</font>);
    printf(<font color=blue>&quot;function       %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(ratint::barycentriccalc&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0))).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;d/dx(0)        %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(1).toDouble()));
    printf(<font color=blue>&quot;d2/dx2(0)      %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(d2v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_polint_eqdist'></a><h3>polint_eqdist example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    ratint::barycentricinterpolant&lt;Precision&gt; p;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;
    amp::ampf&lt;Precision&gt; d2v;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Demonstration</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;POLYNOMIAL INTERPOLATION\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi]\n&quot;</font>);
    printf(<font color=blue>&quot;Second degree polynomial is used\n\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create polynomial interpolant</font>
<font color=navy>    //</font>
    n = 3;
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        y(i) = amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;()*i/(n-1));
    }
    polint::polynomialbuildeqdist&lt;Precision&gt;(amp::ampf&lt;Precision&gt;(0), amp::pi&lt;Precision&gt;(), y, n, p);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    ratint::barycentricdiff2&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0), v, dv, d2v);
    printf(<font color=blue>&quot;                 P(x)    F(x) \n&quot;</font>);
    printf(<font color=blue>&quot;function       %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(ratint::barycentriccalc&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0))).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;d/dx(0)        %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(1).toDouble()));
    printf(<font color=blue>&quot;d2/dx2(0)      %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(d2v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_polint_fit'></a><h3>polint_fit example</h3>
<pre>
    <b>int</b> m;
    <b>int</b> n;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; w;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; xc;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; yc;
    ap::template_1d_array&lt; <b>int</b> &gt; dc;
    polint::polynomialfitreport&lt;Precision&gt; rep;
    <b>int</b> info;
    ratint::barycentricinterpolant&lt;Precision&gt; p;
    <b>int</b> i;
    <b>int</b> j;
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;


    printf(<font color=blue>&quot;\n\nFitting exp(2*x) at [-1,+1] by polinomial\n\n&quot;</font>);
    printf(<font color=blue>&quot;Fit type             rms.err max.err    p(0)   dp(0)\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Prepare points</font>
<font color=navy>    //</font>
    m = 5;
    a = -1;
    b = +1;
    n = 1000;
    x.setlength(n);
    y.setlength(n);
    w.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = a+(b-a)*i/(n-1);
        y(i) = amp::exp&lt;Precision&gt;(2*x(i));
        w(i) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
    }
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5th degree polynomial</font>
<font color=navy>    // c) without constraints</font>
<font color=navy>    //</font>
    polint::polynomialfit&lt;Precision&gt;(x, y, n, m, info, p, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Unconstrained        %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()));
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5th degree polynomial</font>
<font color=navy>    // c) constrained: p(0)=1</font>
<font color=navy>    //</font>
    xc.setlength(1);
    yc.setlength(1);
    dc.setlength(1);
    xc(0) = 0;
    yc(0) = 1;
    dc(0) = 0;
    polint::polynomialfitwc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 1, m, info, p, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Constrained, p(0)=1  %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()));
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5th degree polynomial</font>
<font color=navy>    // c) constrained: dp(0)=2</font>
<font color=navy>    //</font>
    xc.setlength(1);
    yc.setlength(1);
    dc.setlength(1);
    xc(0) = 0;
    yc(0) = 2;
    dc(0) = 1;
    polint::polynomialfitwc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 1, m, info, p, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Constrained, dp(0)=2 %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()));
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5th degree polynomial</font>
<font color=navy>    // c) constrained: p(0)=1, dp(0)=2</font>
<font color=navy>    //</font>
    xc.setlength(2);
    yc.setlength(2);
    dc.setlength(2);
    xc(0) = 0;
    yc(0) = 1;
    dc(0) = 0;
    xc(1) = 0;
    yc(1) = 2;
    dc(1) = 1;
    polint::polynomialfitwc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 2, m, info, p, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Constrained, both    %7.4lf %7.4lf %7.4lf %7.4lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_polint_gen'></a><h3>polint_gen example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    ratint::barycentricinterpolant&lt;Precision&gt; p;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;
    amp::ampf&lt;Precision&gt; d2v;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Demonstration</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;POLYNOMIAL INTERPOLATION\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi]\n&quot;</font>);
    printf(<font color=blue>&quot;Second degree polynomial is used\n\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create polynomial interpolant</font>
<font color=navy>    //</font>
    n = 3;
    x.setlength(n);
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
    }
    polint::polynomialbuild&lt;Precision&gt;(x, y, n, p);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    ratint::barycentricdiff2&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0), v, dv, d2v);
    printf(<font color=blue>&quot;                 P(x)    F(x) \n&quot;</font>);
    printf(<font color=blue>&quot;function       %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(ratint::barycentriccalc&lt;Precision&gt;(p, amp::ampf&lt;Precision&gt;(0))).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;d/dx(0)        %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(1).toDouble()));
    printf(<font color=blue>&quot;d2/dx2(0)      %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(d2v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name=unit_pspline></a><h2><code>pspline</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_pspline2interpolant' class=toc>pspline2interpolant</a><br>
<a href='#struct_pspline3interpolant' class=toc>pspline3interpolant</a><br>
<h3>Functions</h3>
<a href='#sub_pspline2arclength' class=toc>pspline2arclength</a><br>
<a href='#sub_pspline2build' class=toc>pspline2build</a><br>
<a href='#sub_pspline2buildperiodic' class=toc>pspline2buildperiodic</a><br>
<a href='#sub_pspline2calc' class=toc>pspline2calc</a><br>
<a href='#sub_pspline2diff' class=toc>pspline2diff</a><br>
<a href='#sub_pspline2diff2' class=toc>pspline2diff2</a><br>
<a href='#sub_pspline2parametervalues' class=toc>pspline2parametervalues</a><br>
<a href='#sub_pspline2tangent' class=toc>pspline2tangent</a><br>
<a href='#sub_pspline3arclength' class=toc>pspline3arclength</a><br>
<a href='#sub_pspline3build' class=toc>pspline3build</a><br>
<a href='#sub_pspline3buildperiodic' class=toc>pspline3buildperiodic</a><br>
<a href='#sub_pspline3calc' class=toc>pspline3calc</a><br>
<a href='#sub_pspline3diff' class=toc>pspline3diff</a><br>
<a href='#sub_pspline3diff2' class=toc>pspline3diff2</a><br>
<a href='#sub_pspline3parametervalues' class=toc>pspline3parametervalues</a><br>
<a href='#sub_pspline3tangent' class=toc>pspline3tangent</a><br>
<a name='struct_pspline2interpolant'></a><h3><code>pspline2interpolant</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Parametric spline inteprolant: 2-dimensional curve.

You should not try to access its members directly - use PSpline2XXXXXXXX()
functions instead.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> pspline2interpolant
{
<b>public</b>:
    <b>int</b> n;
    <b>bool</b> periodic;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; p;
    spline1d::spline1dinterpolant&lt;Precision&gt; x;
    spline1d::spline1dinterpolant&lt;Precision&gt; y;
};
</div></pre>
<a name='struct_pspline3interpolant'></a><h3><code>pspline3interpolant</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Parametric spline inteprolant: 3-dimensional curve.

You should not try to access its members directly - use PSpline3XXXXXXXX()
functions instead.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> pspline3interpolant
{
<b>public</b>:
    <b>int</b> n;
    <b>bool</b> periodic;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; p;
    spline1d::spline1dinterpolant&lt;Precision&gt; x;
    spline1d::spline1dinterpolant&lt;Precision&gt; y;
    spline1d::spline1dinterpolant&lt;Precision&gt; z;
};
</div></pre>
<a name='sub_pspline2arclength'></a><h3><code>pspline2arclength</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  arc length, i.e. length of  curve  between  t=a
and t=b.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    A,B -   parameter values corresponding to arc ends:
            * B&gt;A will result in positive length returned
            * B&lt;A will result in negative length returned

RESULT:
    length of arc starting at T=A and ending at T=B.


  -- ALGLIB PROJECT --
     Copyright 30.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; pspline2arclength(<b>const</b> pspline2interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b);
</div></pre>
<a name='sub_pspline2build'></a><h3><code>pspline2build</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  builds  non-periodic 2-dimensional parametric spline  which
starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).

INPUT PARAMETERS:
    XY  -   points, array[0..N-1,0..1].
            XY[I,0:1] corresponds to the Ith point.
            Order of points is important!
    N   -   points count, N&gt;=5 for Akima splines, N&gt;=2 for other types  of
            splines.
    ST  -   spline type:
            * 0     Akima spline
            * 1     parabolically terminated Catmull-Rom spline (Tension=0)
            * 2     parabolically terminated cubic spline
    PT  -   parameterization type:
            * 0     uniform
            * 1     chord length
            * 2     centripetal

OUTPUT PARAMETERS:
    P   -   parametric spline interpolant


NOTES:
* this function  assumes  that  there all consequent points  are distinct.
  I.e. (x0,y0)&lt;&gt;(x1,y1),  (x1,y1)&lt;&gt;(x2,y2),  (x2,y2)&lt;&gt;(x3,y3)  and  so on.
  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
  =(x2,y2).

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2build(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; xy,
    <b>int</b> n,
    <b>int</b> st,
    <b>int</b> pt,
    pspline2interpolant&lt;Precision&gt;&amp; p);
</div></pre>
<a name='sub_pspline2buildperiodic'></a><h3><code>pspline2buildperiodic</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  builds  periodic  2-dimensional  parametric  spline  which
starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
back to (X[0],Y[0]).

INPUT PARAMETERS:
    XY  -   points, array[0..N-1,0..1].
            XY[I,0:1] corresponds to the Ith point.
            XY[N-1,0:1] must be different from XY[0,0:1].
            Order of points is important!
    N   -   points count, N&gt;=3 for other types of splines.
    ST  -   spline type:
            * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
            * 2     cubic spline with cyclic boundary conditions
    PT  -   parameterization type:
            * 0     uniform
            * 1     chord length
            * 2     centripetal

OUTPUT PARAMETERS:
    P   -   parametric spline interpolant


NOTES:
* this function  assumes  that there all consequent points  are  distinct.
  I.e. (x0,y0)&lt;&gt;(x1,y1), (x1,y1)&lt;&gt;(x2,y2),  (x2,y2)&lt;&gt;(x3,y3)  and  so  on.
  However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
  =(x2,y2).
* last point of sequence is NOT equal to the first  point.  You  shouldn't
  make curve &quot;explicitly periodic&quot; by making them equal.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2buildperiodic(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; xy,
    <b>int</b> n,
    <b>int</b> st,
    <b>int</b> pt,
    pspline2interpolant&lt;Precision&gt;&amp; p);
</div></pre>
<a name='sub_pspline2calc'></a><h3><code>pspline2calc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  the value of the parametric spline for a  given
value of parameter T

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-position
    Y   -   Y-position


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2calc(<b>const</b> pspline2interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; y);
</div></pre>
<a name='sub_pspline2diff'></a><h3><code>pspline2diff</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates derivative, i.e. it returns (dX/dT,dY/dT).

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   X-derivative
    Y   -   Y-value
    DY  -   Y-derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2diff(<b>const</b> pspline2interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; dx,
    amp::ampf&lt;Precision&gt;&amp; y,
    amp::ampf&lt;Precision&gt;&amp; dy);
</div></pre>
<a name='sub_pspline2diff2'></a><h3><code>pspline2diff2</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates first and second derivative with respect to T.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   derivative
    D2X -   second derivative
    Y   -   Y-value
    DY  -   derivative
    D2Y -   second derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2diff2(<b>const</b> pspline2interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; dx,
    amp::ampf&lt;Precision&gt;&amp; d2x,
    amp::ampf&lt;Precision&gt;&amp; y,
    amp::ampf&lt;Precision&gt;&amp; dy,
    amp::ampf&lt;Precision&gt;&amp; d2y);
</div></pre>
<a name='sub_pspline2parametervalues'></a><h3><code>pspline2parametervalues</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns vector of parameter values correspoding to points.

I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
have
    (X[0],Y[0]) = PSpline2Calc(P,U[0]),
    (X[1],Y[1]) = PSpline2Calc(P,U[1]),
    (X[2],Y[2]) = PSpline2Calc(P,U[2]),
    ...

INPUT PARAMETERS:
    P   -   parametric spline interpolant

OUTPUT PARAMETERS:
    N   -   array size
    T   -   array[0..N-1]


NOTES:
* for non-periodic splines U[0]=0, U[0]&lt;U[1]&lt;...&lt;U[N-1], U[N-1]=1
* for periodic splines     U[0]=0, U[0]&lt;U[1]&lt;...&lt;U[N-1], U[N-1]&lt;1

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2parametervalues(<b>const</b> pspline2interpolant&lt;Precision&gt;&amp; p,
    <b>int</b>&amp; n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; t);
</div></pre>
<a name='sub_pspline2tangent'></a><h3><code>pspline2tangent</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  tangent vector for a given value of parameter T

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X    -   X-component of tangent vector (normalized)
    Y    -   Y-component of tangent vector (normalized)
    
NOTE:
    X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline2tangent(<b>const</b> pspline2interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; y);
</div></pre>
<a name='sub_pspline3arclength'></a><h3><code>pspline3arclength</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  arc length, i.e. length of  curve  between  t=a
and t=b.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    A,B -   parameter values corresponding to arc ends:
            * B&gt;A will result in positive length returned
            * B&lt;A will result in negative length returned

RESULT:
    length of arc starting at T=A and ending at T=B.


  -- ALGLIB PROJECT --
     Copyright 30.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; pspline3arclength(<b>const</b> pspline3interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b);
</div></pre>
<a name='sub_pspline3build'></a><h3><code>pspline3build</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  builds  non-periodic 3-dimensional parametric spline  which
starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).

Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
description here.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3build(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; xy,
    <b>int</b> n,
    <b>int</b> st,
    <b>int</b> pt,
    pspline3interpolant&lt;Precision&gt;&amp; p);
</div></pre>
<a name='sub_pspline3buildperiodic'></a><h3><code>pspline3buildperiodic</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  function  builds  periodic  3-dimensional  parametric  spline  which
starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
and then back to (X[0],Y[0],Z[0]).

Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
description here.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3buildperiodic(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; xy,
    <b>int</b> n,
    <b>int</b> st,
    <b>int</b> pt,
    pspline3interpolant&lt;Precision&gt;&amp; p);
</div></pre>
<a name='sub_pspline3calc'></a><h3><code>pspline3calc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  the value of the parametric spline for a  given
value of parameter T.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-position
    Y   -   Y-position
    Z   -   Z-position


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3calc(<b>const</b> pspline3interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; y,
    amp::ampf&lt;Precision&gt;&amp; z);
</div></pre>
<a name='sub_pspline3diff'></a><h3><code>pspline3diff</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   X-derivative
    Y   -   Y-value
    DY  -   Y-derivative
    Z   -   Z-value
    DZ  -   Z-derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3diff(<b>const</b> pspline3interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; dx,
    amp::ampf&lt;Precision&gt;&amp; y,
    amp::ampf&lt;Precision&gt;&amp; dy,
    amp::ampf&lt;Precision&gt;&amp; z,
    amp::ampf&lt;Precision&gt;&amp; dz);
</div></pre>
<a name='sub_pspline3diff2'></a><h3><code>pspline3diff2</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function calculates first and second derivative with respect to T.

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X   -   X-value
    DX  -   derivative
    D2X -   second derivative
    Y   -   Y-value
    DY  -   derivative
    D2Y -   second derivative
    Z   -   Z-value
    DZ  -   derivative
    D2Z -   second derivative


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3diff2(<b>const</b> pspline3interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; dx,
    amp::ampf&lt;Precision&gt;&amp; d2x,
    amp::ampf&lt;Precision&gt;&amp; y,
    amp::ampf&lt;Precision&gt;&amp; dy,
    amp::ampf&lt;Precision&gt;&amp; d2y,
    amp::ampf&lt;Precision&gt;&amp; z,
    amp::ampf&lt;Precision&gt;&amp; dz,
    amp::ampf&lt;Precision&gt;&amp; d2z);
</div></pre>
<a name='sub_pspline3parametervalues'></a><h3><code>pspline3parametervalues</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function returns vector of parameter values correspoding to points.

Same as PSpline2ParameterValues(), but for 3D.

  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3parametervalues(<b>const</b> pspline3interpolant&lt;Precision&gt;&amp; p,
    <b>int</b>&amp; n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; t);
</div></pre>
<a name='sub_pspline3tangent'></a><h3><code>pspline3tangent</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This function  calculates  tangent vector for a given value of parameter T

INPUT PARAMETERS:
    P   -   parametric spline interpolant
    T   -   point:
            * T in [0,1] corresponds to interval spanned by points
            * for non-periodic splines T&lt;0 (or T&gt;1) correspond to parts of
              the curve before the first (after the last) point
            * for periodic splines T&lt;0 (or T&gt;1) are projected  into  [0,1]
              by making T=T-floor(T).

OUTPUT PARAMETERS:
    X    -   X-component of tangent vector (normalized)
    Y    -   Y-component of tangent vector (normalized)
    Z    -   Z-component of tangent vector (normalized)

NOTE:
    X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.


  -- ALGLIB PROJECT --
     Copyright 28.05.2010 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> pspline3tangent(<b>const</b> pspline3interpolant&lt;Precision&gt;&amp; p,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; x,
    amp::ampf&lt;Precision&gt;&amp; y,
    amp::ampf&lt;Precision&gt;&amp; z);
</div></pre>
<a name=unit_ratint></a><h2><code>ratint</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_barycentricfitreport' class=toc>barycentricfitreport</a><br>
<a href='#struct_barycentricinterpolant' class=toc>barycentricinterpolant</a><br>
<h3>Functions</h3>
<a href='#sub_barycentricbuildfloaterhormann' class=toc>barycentricbuildfloaterhormann</a><br>
<a href='#sub_barycentricbuildxyw' class=toc>barycentricbuildxyw</a><br>
<a href='#sub_barycentriccalc' class=toc>barycentriccalc</a><br>
<a href='#sub_barycentriccopy' class=toc>barycentriccopy</a><br>
<a href='#sub_barycentricdiff1' class=toc>barycentricdiff1</a><br>
<a href='#sub_barycentricdiff2' class=toc>barycentricdiff2</a><br>
<a href='#sub_barycentricfitfloaterhormann' class=toc>barycentricfitfloaterhormann</a><br>
<a href='#sub_barycentricfitfloaterhormannwc' class=toc>barycentricfitfloaterhormannwc</a><br>
<a href='#sub_barycentriclintransx' class=toc>barycentriclintransx</a><br>
<a href='#sub_barycentriclintransy' class=toc>barycentriclintransy</a><br>
<a href='#sub_barycentricserialize' class=toc>barycentricserialize</a><br>
<a href='#sub_barycentricunpack' class=toc>barycentricunpack</a><br>
<a href='#sub_barycentricunserialize' class=toc>barycentricunserialize</a><br>
<h3>Examples</h3>
<a href='#example_ratint_fit' class=toc>ratint_fit</a><br>
<a name='struct_barycentricfitreport'></a><h3><code>barycentricfitreport</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Barycentric fitting report:
    TaskRCond       reciprocal of task's condition number
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> barycentricfitreport
{
<b>public</b>:
    amp::ampf&lt;Precision&gt; taskrcond;
    <b>int</b> dbest;
    amp::ampf&lt;Precision&gt; rmserror;
    amp::ampf&lt;Precision&gt; avgerror;
    amp::ampf&lt;Precision&gt; avgrelerror;
    amp::ampf&lt;Precision&gt; maxerror;
};
</div></pre>
<a name='struct_barycentricinterpolant'></a><h3><code>barycentricinterpolant</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Barycentric interpolant.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> barycentricinterpolant
{
<b>public</b>:
    <b>int</b> n;
    amp::ampf&lt;Precision&gt; sy;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; w;
};
</div></pre>
<a name='sub_barycentricbuildfloaterhormann'></a><h3><code>barycentricbuildfloaterhormann</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational interpolant without poles

The subroutine constructs the rational interpolating function without real
poles  (see  'Barycentric rational interpolation with no  poles  and  high
rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
information on this subject).

Input parameters:
    X   -   interpolation nodes, array[0..N-1].
    Y   -   function values, array[0..N-1].
    N   -   number of nodes, N&gt;0.
    D   -   order of the interpolation scheme, 0 &lt;= D &lt;= N-1.
            D&lt;0 will cause an error.
            D&gt;=N it will be replaced with D=N-1.
            if you don't know what D to choose, use small value about 3-5.

Output parameters:
    B   -   barycentric interpolant.

Note:
    this algorithm always succeeds and calculates the weights  with  close
    to machine precision.

  -- ALGLIB PROJECT --
     Copyright 17.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricbuildfloaterhormann(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    <b>int</b> d,
    barycentricinterpolant&lt;Precision&gt;&amp; b);
</div></pre>
<a name='sub_barycentricbuildxyw'></a><h3><code>barycentricbuildxyw</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational interpolant from X/Y/W arrays

F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

INPUT PARAMETERS:
    X   -   interpolation nodes, array[0..N-1]
    F   -   function values, array[0..N-1]
    W   -   barycentric weights, array[0..N-1]
    N   -   nodes count, N&gt;0

OUTPUT PARAMETERS:
    B   -   barycentric interpolant built from (X, Y, W)

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricbuildxyw(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>int</b> n,
    barycentricinterpolant&lt;Precision&gt;&amp; b);
</div></pre>
<a name='sub_barycentriccalc'></a><h3><code>barycentriccalc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational interpolation using barycentric formula

F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

Input parameters:
    B   -   barycentric interpolant built with one of model building
            subroutines.
    T   -   interpolation point

Result:
    barycentric interpolant F(t)

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; barycentriccalc(<b>const</b> barycentricinterpolant&lt;Precision&gt;&amp; b,
    amp::ampf&lt;Precision&gt; t);
</div></pre>
<a name='sub_barycentriccopy'></a><h3><code>barycentriccopy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Copying of the barycentric interpolant

INPUT PARAMETERS:
    B   -   barycentric interpolant

OUTPUT PARAMETERS:
    B2  -   copy(B1)

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentriccopy(<b>const</b> barycentricinterpolant&lt;Precision&gt;&amp; b,
    barycentricinterpolant&lt;Precision&gt;&amp; b2);
</div></pre>
<a name='sub_barycentricdiff1'></a><h3><code>barycentricdiff1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Differentiation of barycentric interpolant: first derivative.

Algorithm used in this subroutine is very robust and should not fail until
provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
or greater will overflow).

INPUT PARAMETERS:
    B   -   barycentric interpolant built with one of model building
            subroutines.
    T   -   interpolation point

OUTPUT PARAMETERS:
    F   -   barycentric interpolant at T
    DF  -   first derivative
    
NOTE


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricdiff1(<b>const</b> barycentricinterpolant&lt;Precision&gt;&amp; b,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; f,
    amp::ampf&lt;Precision&gt;&amp; df);
</div></pre>
<a name='sub_barycentricdiff2'></a><h3><code>barycentricdiff2</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Differentiation of barycentric interpolant: first/second derivatives.

INPUT PARAMETERS:
    B   -   barycentric interpolant built with one of model building
            subroutines.
    T   -   interpolation point

OUTPUT PARAMETERS:
    F   -   barycentric interpolant at T
    DF  -   first derivative
    D2F -   second derivative

NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
BarycentricDiff1() subroutine in such cases.


  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricdiff2(<b>const</b> barycentricinterpolant&lt;Precision&gt;&amp; b,
    amp::ampf&lt;Precision&gt; t,
    amp::ampf&lt;Precision&gt;&amp; f,
    amp::ampf&lt;Precision&gt;&amp; df,
    amp::ampf&lt;Precision&gt;&amp; d2f);
</div></pre>
<a name='sub_barycentricfitfloaterhormann'></a><h3><code>barycentricfitfloaterhormann</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Rational least squares fitting, without weights and constraints.

See BarycentricFitFloaterHormannWC() for more information.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricfitfloaterhormann(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b>&amp; info,
    barycentricinterpolant&lt;Precision&gt;&amp; b,
    barycentricfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ratint_fit' class=nav>ratint_fit</a>&nbsp;&nbsp;</p>
<a name='sub_barycentricfitfloaterhormannwc'></a><h3><code>barycentricfitfloaterhormannwc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weghted rational least  squares  fitting  using  Floater-Hormann  rational
functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
individual weights.

Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
functions. Different values of D are tried, optimal D (least WEIGHTED root
mean square error) is chosen.  Task  is  linear,  so  linear least squares
solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
(mostly dominated by the least squares solver).

SEE ALSO
* BarycentricFitFloaterHormann(), &quot;lightweight&quot; fitting without invididual
  weights and constraints.

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points, N&gt;0.
    XC  -   points where function values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that S(XC[i])=YC[i]
            * DC[i]=1   means that S'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints, 0&lt;=K&lt;M.
            K=0 means no constraints (XC/YC/DC are not used in such cases)
    M   -   number of basis functions ( = number_of_nodes), M&gt;=2.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
                        -1 means another errors in parameters passed
                           (N&lt;=0, for example)
    B   -   barycentric interpolant.
    Rep -   report, same format as in LSFitLinearWC() subroutine.
            Following fields are set:
            * DBest         best value of the D parameter
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained barycentric interpolants:
* excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
  functions aren't as flexible as splines (although they are very smooth).
* the more evenly constraints are spread across [min(x),max(x)],  the more
  chances that they will be consistent
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints IS NOT GUARANTEED.
* in the several special cases, however, we CAN guarantee consistency.
* one of this cases is constraints on the function  VALUES at the interval
  boundaries. Note that consustency of the  constraints  on  the  function
  DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
  which are more flexible).
* another  special  case  is ONE constraint on the function value (OR, but
  not AND, derivative) anywhere in the interval

Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricfitfloaterhormannwc(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xc,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; yc,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; dc,
    <b>int</b> k,
    <b>int</b> m,
    <b>int</b>&amp; info,
    barycentricinterpolant&lt;Precision&gt;&amp; b,
    barycentricfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_ratint_fit' class=nav>ratint_fit</a>&nbsp;&nbsp;</p>
<a name='sub_barycentriclintransx'></a><h3><code>barycentriclintransx</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the argument.

INPUT PARAMETERS:
    B       -   rational interpolant in barycentric form
    CA, CB  -   transformation coefficients: x = CA*t + CB

OUTPUT PARAMETERS:
    B       -   transformed interpolant with X replaced by T

  -- ALGLIB PROJECT --
     Copyright 19.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentriclintransx(barycentricinterpolant&lt;Precision&gt;&amp; b,
    amp::ampf&lt;Precision&gt; ca,
    amp::ampf&lt;Precision&gt; cb);
</div></pre>
<a name='sub_barycentriclintransy'></a><h3><code>barycentriclintransy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This  subroutine   performs   linear  transformation  of  the  barycentric
interpolant.

INPUT PARAMETERS:
    B       -   rational interpolant in barycentric form
    CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB

OUTPUT PARAMETERS:
    B       -   transformed interpolant

  -- ALGLIB PROJECT --
     Copyright 19.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentriclintransy(barycentricinterpolant&lt;Precision&gt;&amp; b,
    amp::ampf&lt;Precision&gt; ca,
    amp::ampf&lt;Precision&gt; cb);
</div></pre>
<a name='sub_barycentricserialize'></a><h3><code>barycentricserialize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Serialization of the barycentric interpolant

INPUT PARAMETERS:
    B   -   barycentric interpolant

OUTPUT PARAMETERS:
    RA      -   array of real numbers which contains interpolant,
                array[0..RLen-1]
    RLen    -   RA lenght

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricserialize(<b>const</b> barycentricinterpolant&lt;Precision&gt;&amp; b,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; ra,
    <b>int</b>&amp; ralen);
</div></pre>
<a name='sub_barycentricunpack'></a><h3><code>barycentricunpack</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Extracts X/Y/W arrays from rational interpolant

INPUT PARAMETERS:
    B   -   barycentric interpolant

OUTPUT PARAMETERS:
    N   -   nodes count, N&gt;0
    X   -   interpolation nodes, array[0..N-1]
    F   -   function values, array[0..N-1]
    W   -   barycentric weights, array[0..N-1]

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricunpack(<b>const</b> barycentricinterpolant&lt;Precision&gt;&amp; b,
    <b>int</b>&amp; n,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w);
</div></pre>
<a name='sub_barycentricunserialize'></a><h3><code>barycentricunserialize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unserialization of the barycentric interpolant

INPUT PARAMETERS:
    RA  -   array of real numbers which contains interpolant,

OUTPUT PARAMETERS:
    B   -   barycentric interpolant

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> barycentricunserialize(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; ra,
    barycentricinterpolant&lt;Precision&gt;&amp; b);
</div></pre>
<a name='example_ratint_fit'></a><h3>ratint_fit example</h3>
<pre>
    <b>int</b> m;
    <b>int</b> n;
    <b>int</b> d;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; w;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; xc;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; yc;
    ap::template_1d_array&lt; <b>int</b> &gt; dc;
    ratint::barycentricfitreport&lt;Precision&gt; rep;
    <b>int</b> info;
    ratint::barycentricinterpolant&lt;Precision&gt; r;
    <b>int</b> i;
    <b>int</b> j;
    amp::ampf&lt;Precision&gt; a;
    amp::ampf&lt;Precision&gt; b;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;


    printf(<font color=blue>&quot;\n\nFitting exp(2*x) at [-1,+1] by:\n1. constrained/unconstrained Floater-Hormann functions\n&quot;</font>);
    printf(<font color=blue>&quot;\n&quot;</font>);
    printf(<font color=blue>&quot;Fit type                rms.err max.err    p(0)   dp(0)  DBest\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Prepare points</font>
<font color=navy>    //</font>
    m = 5;
    a = -1;
    b = +1;
    n = 10000;
    x.setlength(n);
    y.setlength(n);
    w.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = a+(b-a)*i/(n-1);
        y(i) = amp::exp&lt;Precision&gt;(2*x(i));
        w(i) = amp::ampf&lt;Precision&gt;(<font color=blue>&quot;1.0&quot;</font>);
    }
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5 Floater-Hormann functions</font>
<font color=navy>    // c) without constraints</font>
<font color=navy>    //</font>
    ratint::barycentricfitfloaterhormann&lt;Precision&gt;(x, y, n, m, info, r, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(r, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Unconstrained FH        %7.4lf %7.4lf %7.4lf %7.4lf      %0ld\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>long</b>(rep.dbest));
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5 Floater-Hormann functions</font>
<font color=navy>    // c) constrained: p(0)=1</font>
<font color=navy>    //</font>
    xc.setlength(1);
    yc.setlength(1);
    dc.setlength(1);
    xc(0) = 0;
    yc(0) = 1;
    dc(0) = 0;
    ratint::barycentricfitfloaterhormannwc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 1, m, info, r, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(r, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Constrained FH, p(0)=1  %7.4lf %7.4lf %7.4lf %7.4lf      %0ld\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>long</b>(rep.dbest));
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5 Floater-Hormann functions</font>
<font color=navy>    // c) constrained: dp(0)=2</font>
<font color=navy>    //</font>
    xc.setlength(1);
    yc.setlength(1);
    dc.setlength(1);
    xc(0) = 0;
    yc(0) = 2;
    dc(0) = 1;
    ratint::barycentricfitfloaterhormannwc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 1, m, info, r, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(r, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Constrained FH, dp(0)=2 %7.4lf %7.4lf %7.4lf %7.4lf      %0ld\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>long</b>(rep.dbest));
    
<font color=navy>    //</font>
<font color=navy>    // Fitting:</font>
<font color=navy>    // a) f(x)=exp(2*x) at [-1,+1]</font>
<font color=navy>    // b) by 5 Floater-Hormann functions</font>
<font color=navy>    // c) constrained: p(0)=1, dp(0)=2</font>
<font color=navy>    //</font>
    xc.setlength(2);
    yc.setlength(2);
    dc.setlength(2);
    xc(0) = 0;
    yc(0) = 1;
    dc(0) = 0;
    xc(1) = 0;
    yc(1) = 2;
    dc(1) = 1;
    ratint::barycentricfitfloaterhormannwc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 2, m, info, r, rep);
    ratint::barycentricdiff1&lt;Precision&gt;(r, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), v, dv);
    printf(<font color=blue>&quot;Constrained FH, both    %7.4lf %7.4lf %7.4lf %7.4lf      %0ld\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>long</b>(rep.dbest));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name=unit_rcond></a><h2><code>rcond</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixlurcond1' class=toc>cmatrixlurcond1</a><br>
<a href='#sub_cmatrixlurcondinf' class=toc>cmatrixlurcondinf</a><br>
<a href='#sub_cmatrixrcond1' class=toc>cmatrixrcond1</a><br>
<a href='#sub_cmatrixrcondinf' class=toc>cmatrixrcondinf</a><br>
<a href='#sub_cmatrixtrrcond1' class=toc>cmatrixtrrcond1</a><br>
<a href='#sub_cmatrixtrrcondinf' class=toc>cmatrixtrrcondinf</a><br>
<a href='#sub_hpdmatrixcholeskyrcond' class=toc>hpdmatrixcholeskyrcond</a><br>
<a href='#sub_hpdmatrixrcond' class=toc>hpdmatrixrcond</a><br>
<a href='#sub_rcondthreshold' class=toc>rcondthreshold</a><br>
<a href='#sub_rmatrixlurcond1' class=toc>rmatrixlurcond1</a><br>
<a href='#sub_rmatrixlurcondinf' class=toc>rmatrixlurcondinf</a><br>
<a href='#sub_rmatrixrcond1' class=toc>rmatrixrcond1</a><br>
<a href='#sub_rmatrixrcondinf' class=toc>rmatrixrcondinf</a><br>
<a href='#sub_rmatrixtrrcond1' class=toc>rmatrixtrrcond1</a><br>
<a href='#sub_rmatrixtrrcondinf' class=toc>rmatrixtrrcondinf</a><br>
<a href='#sub_spdmatrixcholeskyrcond' class=toc>spdmatrixcholeskyrcond</a><br>
<a href='#sub_spdmatrixrcond' class=toc>spdmatrixrcond</a><br>
<h3>Examples</h3>
<a href='#example_rcond_1' class=toc>rcond_1</a><br>
<a name='sub_cmatrixlurcond1'></a><h3><code>cmatrixlurcond1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA         -   LU decomposition of a matrix in compact form. Output of
                    the CMatrixLU subroutine.
    N           -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; cmatrixlurcond1(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; lua,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixlurcondinf'></a><h3><code>cmatrixlurcondinf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition
(infinity norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA     -   LU decomposition of a matrix in compact form. Output of
                the CMatrixLU subroutine.
    N       -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; cmatrixlurcondinf(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; lua,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixrcond1'></a><h3><code>cmatrixrcond1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; cmatrixrcond1(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixrcondinf'></a><h3><code>cmatrixrcondinf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; cmatrixrcondinf(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_cmatrixtrrcond1'></a><h3><code>cmatrixtrrcond1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A       -   matrix. Array[0..N-1, 0..N-1].
    N       -   size of A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; cmatrixtrrcond1(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isunit);
</div></pre>
<a name='sub_cmatrixtrrcondinf'></a><h3><code>cmatrixtrrcondinf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; cmatrixtrrcondinf(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isunit);
</div></pre>
<a name='sub_hpdmatrixcholeskyrcond'></a><h3><code>hpdmatrixcholeskyrcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a Hermitian positive definite matrix given by
Cholesky decomposition.

The algorithm calculates a lower bound of the condition number. In this
case, the algorithm does not return a lower bound of the condition number,
but an inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    CD  - Cholesky decomposition of matrix A,
          output of SMatrixCholesky subroutine.
    N   - size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; hpdmatrixcholeskyrcond(<b>const</b> ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_hpdmatrixrcond'></a><h3><code>hpdmatrixrcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a Hermitian positive definite matrix.

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm of condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    A       -   Hermitian positive definite matrix which is given by its
                upper or lower triangle depending on the value of
                IsUpper. Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.

Result:
    1/LowerBound(cond(A)), if matrix A is positive definite,
   -1, if matrix A is not positive definite, and its condition number
    could not be found by this algorithm.

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; hpdmatrixrcond(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_rcondthreshold'></a><h3><code>rcondthreshold</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Threshold for rcond: matrices with condition number beyond this  threshold
are considered singular.

Threshold must be far enough from underflow, at least Sqr(Threshold)  must
be greater than underflow.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rcondthreshold();
</div></pre>
<a name='sub_rmatrixlurcond1'></a><h3><code>rmatrixlurcond1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA         -   LU decomposition of a matrix in compact form. Output of
                    the RMatrixLU subroutine.
    N           -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixlurcond1(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; lua,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixlurcondinf'></a><h3><code>rmatrixlurcondinf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of the condition number of a matrix given by its LU decomposition
(infinity norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    LUA     -   LU decomposition of a matrix in compact form. Output of
                the RMatrixLU subroutine.
    N       -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixlurcondinf(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; lua,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixrcond1'></a><h3><code>rmatrixrcond1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixrcond1(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixrcondinf'></a><h3><code>rmatrixrcondinf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixrcondinf(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_rmatrixtrrcond1'></a><h3><code>rmatrixtrrcond1</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a condition number (1-norm)

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A       -   matrix. Array[0..N-1, 0..N-1].
    N       -   size of A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixtrrcond1(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isunit);
</div></pre>
<a name='sub_rmatrixtrrcondinf'></a><h3><code>rmatrixtrrcondinf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Triangular matrix: estimate of a matrix condition number (infinity-norm).

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

Input parameters:
    A   -   matrix. Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of matrix A.
    IsUpper -   True, if the matrix is upper triangular.
    IsUnit  -   True, if the matrix has a unit diagonal.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; rmatrixtrrcondinf(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper,
    <b>bool</b> isunit);
</div></pre>
<a name='sub_spdmatrixcholeskyrcond'></a><h3><code>spdmatrixcholeskyrcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a symmetric positive definite matrix given by
Cholesky decomposition.

The algorithm calculates a lower bound of the condition number. In this
case, the algorithm does not return a lower bound of the condition number,
but an inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    CD  - Cholesky decomposition of matrix A,
          output of SMatrixCholesky subroutine.
    N   - size of matrix A.

Result: 1/LowerBound(cond(A))

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spdmatrixcholeskyrcond(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='sub_spdmatrixrcond'></a><h3><code>spdmatrixrcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a symmetric positive definite matrix.

The algorithm calculates a lower bound of the condition number. In this case,
the algorithm does not return a lower bound of the condition number, but an
inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm of condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    A       -   symmetric positive definite matrix which is given by its
                upper or lower triangle depending on the value of
                IsUpper. Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.

Result:
    1/LowerBound(cond(A)), if matrix A is positive definite,
   -1, if matrix A is not positive definite, and its condition number
    could not be found by this algorithm.

NOTE:
    if k(A) is very large, then matrix is  assumed  degenerate,  k(A)=INF,
    0.0 is returned in such cases.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spdmatrixrcond(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_rcond_1' class=nav>rcond_1</a>&nbsp;&nbsp;</p>
<a name='example_rcond_1'></a><h3>rcond_1 example</h3>
<pre>
    <b>int</b> n;
    <b>int</b> i;
    <b>int</b> j;
    amp::ampf&lt;Precision&gt; c1;
    amp::ampf&lt;Precision&gt; x;
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a;


    printf(<font color=blue>&quot;                 CONDITION NUMBERS\n&quot;</font>);
    printf(<font color=blue>&quot;OF VANDERMONDE AND CHEBYSHEV INTERPOLATION MATRICES\n\n&quot;</font>);
    printf(<font color=blue>&quot;    VANDERMONDE   CHEBYSHEV\n&quot;</font>);
    printf(<font color=blue>&quot;  N      1-norm      1-norm\n&quot;</font>);
    <b>for</b>(n=2; n&lt;=14; n++)
    {
        a.setlength(n, n);
        printf(<font color=blue>&quot;%3ld&quot;</font>,
            <b>long</b>(n));
        
<font color=navy>        //</font>
<font color=navy>        // Vandermone matrix</font>
<font color=navy>        //</font>
        <b>for</b>(i=0; i&lt;=n-1; i++)
        {
            x = amp::ampf&lt;Precision&gt;(2*i)/(amp::ampf&lt;Precision&gt;(n-1))-1;
            a(i,0) = 1;
            <b>for</b>(j=1; j&lt;=n-1; j++)
            {
                a(i,j) = a(i,j-1)*x;
            }
        }
        c1 = 1/rcond::rmatrixrcond1&lt;Precision&gt;(a, n);
        printf(<font color=blue>&quot; %11.1lf&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(c1).toDouble()));
        
<font color=navy>        //</font>
<font color=navy>        // Chebyshev interpolation matrix</font>
<font color=navy>        //</font>
        <b>for</b>(i=0; i&lt;=n-1; i++)
        {
            x = amp::ampf&lt;Precision&gt;(2*i)/(amp::ampf&lt;Precision&gt;(n-1))-1;
            a(i,0) = 1;
            <b>if</b>( n&gt;=2 )
            {
                a(i,1) = x;
            }
            <b>for</b>(j=2; j&lt;=n-1; j++)
            {
                a(i,j) = 2*x*a(i,j-1)-a(i,j-2);
            }
        }
        c1 = 1/rcond::rmatrixrcond1&lt;Precision&gt;(a, n);
        printf(<font color=blue>&quot; %11.1lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(c1).toDouble()));
    }

</pre><a name=unit_schur></a><h2><code>schur</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_rmatrixschur' class=toc>rmatrixschur</a><br>
<a name='sub_rmatrixschur'></a><h3><code>rmatrixschur</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Subroutine performing the Schur decomposition of a general matrix by using
the QR algorithm with multiple shifts.

The source matrix A is represented as S'*A*S = T, where S is an orthogonal
matrix (Schur vectors), T - upper quasi-triangular matrix (with blocks of
sizes 1x1 and 2x2 on the main diagonal).

Input parameters:
    A   -   matrix to be decomposed.
            Array whose indexes range within [0..N-1, 0..N-1].
    N   -   size of A, N&gt;=0.


Output parameters:
    A   -   contains matrix T.
            Array whose indexes range within [0..N-1, 0..N-1].
    S   -   contains Schur vectors.
            Array whose indexes range within [0..N-1, 0..N-1].

Note 1:
    The block structure of matrix T can be easily recognized: since all
    the elements below the blocks are zeros, the elements a[i+1,i] which
    are equal to 0 show the block border.

Note 2:
    The algorithm performance depends on the value of the internal parameter
    NS of the InternalSchurDecomposition subroutine which defines the number
    of shifts in the QR algorithm (similarly to the block width in block-matrix
    algorithms in linear algebra). If you require maximum performance on
    your machine, it is recommended to adjust this parameter manually.

Result:
    True,
        if the algorithm has converged and parameters A and S contain the result.
    False,
        if the algorithm has not converged.

Algorithm implemented on the basis of the DHSEQR subroutine (LAPACK 3.0 library).
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> rmatrixschur(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; s);
</div></pre>
<a name=unit_sdet></a><h2><code>sdet</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_smatrixdet' class=toc>smatrixdet</a><br>
<a href='#sub_smatrixldltdet' class=toc>smatrixldltdet</a><br>
<a name='sub_smatrixdet'></a><h3><code>smatrixdet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the symmetric matrix

Input parameters:
    A       -   matrix. Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   if IsUpper = True, then symmetric matrix A is given by its
                upper triangle, and the lower triangle isnt used by
                subroutine. Similarly, if IsUpper = False, then A is given
                by its lower triangle.

Result:
    determinant of matrix A.

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; smatrixdet(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name='sub_smatrixldltdet'></a><h3><code>smatrixldltdet</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Determinant calculation of the matrix given by LDLT decomposition.

Input parameters:
    A       -   LDLT-decomposition of the matrix,
                output of subroutine SMatrixLDLT.
    Pivots  -   table of permutations which were made during
                LDLT decomposition, output of subroutine SMatrixLDLT.
    N       -   size of matrix A.
    IsUpper -   matrix storage format. The value is equal to the input
                parameter of subroutine SMatrixLDLT.

Result:
    matrix determinant.

  -- ALGLIB --
     Copyright 2005-2008 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; smatrixldltdet(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name=unit_sinverse></a><h2><code>sinverse</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_smatrixinverse' class=toc>smatrixinverse</a><br>
<a href='#sub_smatrixldltinverse' class=toc>smatrixldltinverse</a><br>
<a name='sub_smatrixinverse'></a><h3><code>smatrixinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a symmetric indefinite matrix

Given a lower or upper triangle of matrix A, the algorithm generates
matrix A^-1 and saves the lower or upper triangle depending on the input.

Input parameters:
    A       -   matrix to be inverted (upper or lower triangle).
                Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format. If IsUpper = True, then the upper
                triangle of matrix A is given, otherwise the lower
                triangle is given.

Output parameters:
    A       -   inverse of matrix A.
                Array with elements [0..N-1, 0..N-1].
                If IsUpper = True, then A contains the upper triangle of
                matrix A^-1, and the elements below the main diagonal are
                not used nor changed.
                The same applies if IsUpper = False.

Result:
    True, if the matrix is not singular.
    False, if the matrix is singular and could not be inverted.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     March 31, 1993
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name='sub_smatrixldltinverse'></a><h3><code>smatrixldltinverse</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Inversion of a symmetric indefinite matrix

The algorithm gets an LDLT-decomposition as an input, generates matrix A^-1
and saves the lower or upper triangle of an inverse matrix depending on the
input (U*D*U' or L*D*L').

Input parameters:
    A       -   LDLT-decomposition of the matrix,
                Output of subroutine SMatrixLDLT.
    N       -   size of matrix A.
    IsUpper -   storage format. If IsUpper = True, then the symmetric matrix
                is given as decomposition A = U*D*U' and this decomposition
                is stored in the upper triangle of matrix A and on the main
                diagonal, and the lower triangle of matrix A is not used.
    Pivots  -   a table of permutations, output of subroutine SMatrixLDLT.

Output parameters:
    A       -   inverse of the matrix, whose LDLT-decomposition was stored
                in matrix A as a subroutine input.
                Array with elements [0..N-1, 0..N-1].
                If IsUpper = True, then A contains the upper triangle of
                matrix A^-1, and the elements below the main diagonal are
                not used nor changed. The same applies if IsUpper = False.

Result:
    True, if the matrix is not singular.
    False, if the matrix is singular and could not be inverted.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     March 31, 1993
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixldltinverse(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name=unit_spdgevd></a><h2><code>spdgevd</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_smatrixgevd' class=toc>smatrixgevd</a><br>
<a href='#sub_smatrixgevdreduce' class=toc>smatrixgevdreduce</a><br>
<a name='sub_smatrixgevd'></a><h3><code>smatrixgevd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Algorithm for solving the following generalized symmetric positive-definite
eigenproblem:
    A*x = lambda*B*x (1) or
    A*B*x = lambda*x (2) or
    B*A*x = lambda*x (3).
where A is a symmetric matrix, B - symmetric positive-definite matrix.
The problem is solved by reducing it to an ordinary  symmetric  eigenvalue
problem.

Input parameters:
    A           -   symmetric matrix which is given by its upper or lower
                    triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    N           -   size of matrices A and B.
    IsUpperA    -   storage format of matrix A.
    B           -   symmetric positive-definite matrix which is given by
                    its upper or lower triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    IsUpperB    -   storage format of matrix B.
    ZNeeded     -   if ZNeeded is equal to:
                     * 0, the eigenvectors are not returned;
                     * 1, the eigenvectors are returned.
    ProblemType -   if ProblemType is equal to:
                     * 1, the following problem is solved: A*x = lambda*B*x;
                     * 2, the following problem is solved: A*B*x = lambda*x;
                     * 3, the following problem is solved: B*A*x = lambda*x.

Output parameters:
    D           -   eigenvalues in ascending order.
                    Array whose index ranges within [0..N-1].
    Z           -   if ZNeeded is equal to:
                     * 0, Z hasnt changed;
                     * 1, Z contains eigenvectors.
                    Array whose indexes range within [0..N-1, 0..N-1].
                    The eigenvectors are stored in matrix columns. It should
                    be noted that the eigenvectors in such problems do not
                    form an orthogonal system.

Result:
    True, if the problem was solved successfully.
    False, if the error occurred during the Cholesky decomposition of matrix
    B (the matrix isnt positive-definite) or during the work of the iterative
    algorithm for solving the symmetric eigenproblem.

See also the GeneralizedSymmetricDefiniteEVDReduce subroutine.

  -- ALGLIB --
     Copyright 1.28.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixgevd(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> n,
    <b>bool</b> isuppera,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>bool</b> isupperb,
    <b>int</b> zneeded,
    <b>int</b> problemtype,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; d,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; z);
</div></pre>
<a name='sub_smatrixgevdreduce'></a><h3><code>smatrixgevdreduce</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Algorithm for reduction of the following generalized symmetric positive-
definite eigenvalue problem:
    A*x = lambda*B*x (1) or
    A*B*x = lambda*x (2) or
    B*A*x = lambda*x (3)
to the symmetric eigenvalues problem C*y = lambda*y (eigenvalues of this and
the given problems are the same, and the eigenvectors of the given problem
could be obtained by multiplying the obtained eigenvectors by the
transformation matrix x = R*y).

Here A is a symmetric matrix, B - symmetric positive-definite matrix.

Input parameters:
    A           -   symmetric matrix which is given by its upper or lower
                    triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    N           -   size of matrices A and B.
    IsUpperA    -   storage format of matrix A.
    B           -   symmetric positive-definite matrix which is given by
                    its upper or lower triangular part.
                    Array whose indexes range within [0..N-1, 0..N-1].
    IsUpperB    -   storage format of matrix B.
    ProblemType -   if ProblemType is equal to:
                     * 1, the following problem is solved: A*x = lambda*B*x;
                     * 2, the following problem is solved: A*B*x = lambda*x;
                     * 3, the following problem is solved: B*A*x = lambda*x.

Output parameters:
    A           -   symmetric matrix which is given by its upper or lower
                    triangle depending on IsUpperA. Contains matrix C.
                    Array whose indexes range within [0..N-1, 0..N-1].
    R           -   upper triangular or low triangular transformation matrix
                    which is used to obtain the eigenvectors of a given problem
                    as the product of eigenvectors of C (from the right) and
                    matrix R (from the left). If the matrix is upper
                    triangular, the elements below the main diagonal
                    are equal to 0 (and vice versa). Thus, we can perform
                    the multiplication without taking into account the
                    internal structure (which is an easier though less
                    effective way).
                    Array whose indexes range within [0..N-1, 0..N-1].
    IsUpperR    -   type of matrix R (upper or lower triangular).

Result:
    True, if the problem was reduced successfully.
    False, if the error occurred during the Cholesky decomposition of
        matrix B (the matrix is not positive-definite).

  -- ALGLIB --
     Copyright 1.28.2006 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixgevdreduce(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isuppera,
    <b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>bool</b> isupperb,
    <b>int</b> problemtype,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; r,
    <b>bool</b>&amp; isupperr);
</div></pre>
<a name=unit_spline1d></a><h2><code>spline1d</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_spline1dfitreport' class=toc>spline1dfitreport</a><br>
<a href='#struct_spline1dinterpolant' class=toc>spline1dinterpolant</a><br>
<h3>Functions</h3>
<a href='#sub_spline1dbuildakima' class=toc>spline1dbuildakima</a><br>
<a href='#sub_spline1dbuildcatmullrom' class=toc>spline1dbuildcatmullrom</a><br>
<a href='#sub_spline1dbuildcubic' class=toc>spline1dbuildcubic</a><br>
<a href='#sub_spline1dbuildhermite' class=toc>spline1dbuildhermite</a><br>
<a href='#sub_spline1dbuildlinear' class=toc>spline1dbuildlinear</a><br>
<a href='#sub_spline1dcalc' class=toc>spline1dcalc</a><br>
<a href='#sub_spline1dcopy' class=toc>spline1dcopy</a><br>
<a href='#sub_spline1ddiff' class=toc>spline1ddiff</a><br>
<a href='#sub_spline1dfitcubic' class=toc>spline1dfitcubic</a><br>
<a href='#sub_spline1dfitcubicwc' class=toc>spline1dfitcubicwc</a><br>
<a href='#sub_spline1dfithermite' class=toc>spline1dfithermite</a><br>
<a href='#sub_spline1dfithermitewc' class=toc>spline1dfithermitewc</a><br>
<a href='#sub_spline1dintegrate' class=toc>spline1dintegrate</a><br>
<a href='#sub_spline1dlintransx' class=toc>spline1dlintransx</a><br>
<a href='#sub_spline1dlintransy' class=toc>spline1dlintransy</a><br>
<a href='#sub_spline1dunpack' class=toc>spline1dunpack</a><br>
<h3>Examples</h3>
<a href='#example_spline1d_calc' class=toc>spline1d_calc</a><br>
<a href='#example_spline1d_cubic' class=toc>spline1d_cubic</a><br>
<a href='#example_spline1d_fit' class=toc>spline1d_fit</a><br>
<a href='#example_spline1d_fitc' class=toc>spline1d_fitc</a><br>
<a href='#example_spline1d_hermite' class=toc>spline1d_hermite</a><br>
<a href='#example_spline1d_linear' class=toc>spline1d_linear</a><br>
<a name='struct_spline1dfitreport'></a><h3><code>spline1dfitreport</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Spline fitting report:
    TaskRCond       reciprocal of task's condition number
    RMSError        RMS error
    AvgError        average error
    AvgRelError     average relative error (for non-zero Y[I])
    MaxError        maximum error
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> spline1dfitreport
{
<b>public</b>:
    amp::ampf&lt;Precision&gt; taskrcond;
    amp::ampf&lt;Precision&gt; rmserror;
    amp::ampf&lt;Precision&gt; avgerror;
    amp::ampf&lt;Precision&gt; avgrelerror;
    amp::ampf&lt;Precision&gt; maxerror;
};
</div></pre>
<a name='struct_spline1dinterpolant'></a><h3><code>spline1dinterpolant</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
1-dimensional spline inteprolant
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> spline1dinterpolant
{
<b>public</b>:
    <b>bool</b> periodic;
    <b>int</b> n;
    <b>int</b> k;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; c;
};
</div></pre>
<a name='sub_spline1dbuildakima'></a><h3><code>spline1dbuildakima</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds Akima spline interpolant

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1]
    Y           -   function values, array[0..N-1]
    N           -   points count, N&gt;=5

OUTPUT PARAMETERS:
    C           -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

  -- ALGLIB PROJECT --
     Copyright 24.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dbuildakima(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>int</b> n,
    spline1dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<a name='sub_spline1dbuildcatmullrom'></a><h3><code>spline1dbuildcatmullrom</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds Catmull-Rom spline interpolant.

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1].
    Y           -   function values, array[0..N-1].
    N           -   points count, N&gt;=2
    BoundType   -   boundary condition type:
                    * -1 for periodic boundary condition
                    *  0 for parabolically terminated spline
    Tension     -   tension parameter:
                    * tension=0   corresponds to classic Catmull-Rom spline
                    * 0&lt;tension&lt;1 corresponds to more general form - cardinal spline

OUTPUT PARAMETERS:
    C           -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them to be equal.

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dbuildcatmullrom(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>int</b> n,
    <b>int</b> boundtype,
    amp::ampf&lt;Precision&gt; tension,
    spline1dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<a name='sub_spline1dbuildcubic'></a><h3><code>spline1dbuildcubic</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds cubic spline interpolant.

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1].
    Y           -   function values, array[0..N-1].
    N           -   points count, N&gt;=2
    BoundLType  -   boundary condition type for the left boundary
    BoundL      -   left boundary condition (first or second derivative,
                    depending on the BoundLType)
    BoundRType  -   boundary condition type for the right boundary
    BoundR      -   right boundary condition (first or second derivative,
                    depending on the BoundRType)

OUTPUT PARAMETERS:
    C           -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

SETTING BOUNDARY VALUES:

The BoundLType/BoundRType parameters can have the following values:
    * -1, which corresonds to the periodic (cyclic) boundary conditions.
          In this case:
          * both BoundLType and BoundRType must be equal to -1.
          * BoundL/BoundR are ignored
          * Y[last] is ignored (it is assumed to be equal to Y[first]).
    *  0, which  corresponds  to  the  parabolically   terminated  spline
          (BoundL and/or BoundR are ignored).
    *  1, which corresponds to the first derivative boundary condition
    *  2, which corresponds to the second derivative boundary condition

PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
However, this subroutine doesn't require you to specify equal  values  for
the first and last points - it automatically forces them to be equal.

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dbuildcubic(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>int</b> n,
    <b>int</b> boundltype,
    amp::ampf&lt;Precision&gt; boundl,
    <b>int</b> boundrtype,
    amp::ampf&lt;Precision&gt; boundr,
    spline1dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_calc' class=nav>spline1d_calc</a>&nbsp;&nbsp;<a href='#example_spline1d_cubic' class=nav>spline1d_cubic</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dbuildhermite'></a><h3><code>spline1dbuildhermite</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds Hermite spline interpolant.

INPUT PARAMETERS:
    X           -   spline nodes, array[0..N-1]
    Y           -   function values, array[0..N-1]
    D           -   derivatives, array[0..N-1]
    N           -   points count, N&gt;=2

OUTPUT PARAMETERS:
    C           -   spline interpolant.


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dbuildhermite(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; d,
    <b>int</b> n,
    spline1dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_hermite' class=nav>spline1d_hermite</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dbuildlinear'></a><h3><code>spline1dbuildlinear</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds linear spline interpolant

INPUT PARAMETERS:
    X   -   spline nodes, array[0..N-1]
    Y   -   function values, array[0..N-1]
    N   -   points count, N&gt;=2
    
OUTPUT PARAMETERS:
    C   -   spline interpolant


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

  -- ALGLIB PROJECT --
     Copyright 24.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dbuildlinear(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    <b>int</b> n,
    spline1dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_linear' class=nav>spline1d_linear</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dcalc'></a><h3><code>spline1dcalc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the spline at the given point X.

INPUT PARAMETERS:
    C   -   spline interpolant
    X   -   point

Result:
    S(x)

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spline1dcalc(<b>const</b> spline1dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; x);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_calc' class=nav>spline1d_calc</a>&nbsp;&nbsp;<a href='#example_spline1d_cubic' class=nav>spline1d_cubic</a>&nbsp;&nbsp;<a href='#example_spline1d_hermite' class=nav>spline1d_hermite</a>&nbsp;&nbsp;<a href='#example_spline1d_linear' class=nav>spline1d_linear</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dcopy'></a><h3><code>spline1dcopy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine makes the copy of the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.

Result:
    CC  -   spline copy

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dcopy(<b>const</b> spline1dinterpolant&lt;Precision&gt;&amp; c,
    spline1dinterpolant&lt;Precision&gt;&amp; cc);
</div></pre>
<a name='sub_spline1ddiff'></a><h3><code>spline1ddiff</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine differentiates the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    X   -   point

Result:
    S   -   S(x)
    DS  -   S'(x)
    D2S -   S''(x)

  -- ALGLIB PROJECT --
     Copyright 24.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1ddiff(<b>const</b> spline1dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; x,
    amp::ampf&lt;Precision&gt;&amp; s,
    amp::ampf&lt;Precision&gt;&amp; ds,
    amp::ampf&lt;Precision&gt;&amp; d2s);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_calc' class=nav>spline1d_calc</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfitcubic'></a><h3><code>spline1dfitcubic</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting by cubic spline.

This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
about subroutine parameters (we don't duplicate it here because of length)

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dfitcubic(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b>&amp; info,
    spline1dinterpolant&lt;Precision&gt;&amp; s,
    spline1dfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_fit' class=nav>spline1d_fit</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfitcubicwc'></a><h3><code>spline1dfitcubicwc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted fitting by cubic  spline,  with constraints on function values or
derivatives.

Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
basis functions. Basis functions are cubic splines with continuous  second
derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
regularizing term is used  when  solving  constrained  tasks  (to  improve
stability).

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO
    Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
                                less smooth)
    Spline1DFitCubic()      -   &quot;lightweight&quot; fitting  by  cubic  splines,
                                without invididual weights and constraints

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points, N&gt;0.
    XC  -   points where spline values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that S(XC[i])=YC[i]
            * DC[i]=1   means that S'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints, 0&lt;=K&lt;M.
            K=0 means no constraints (XC/YC/DC are not used in such cases)
    M   -   number of basis functions ( = number_of_nodes+2), M&gt;=4.

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearWC() subroutine.
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
                        -1 means another errors in parameters passed
                           (N&lt;=0, for example)
    S   -   spline interpolant.
    Rep -   report, same format as in LSFitLinearWC() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained regression splines:
* excessive constraints can be inconsistent. Splines are  piecewise  cubic
  functions, and it is easy to create an example, where  large  number  of
  constraints  concentrated  in  small  area will result in inconsistency.
  Just because spline is not flexible enough to satisfy all of  them.  And
  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
  consistent.
* the more evenly constraints are spread across [min(x),max(x)],  the more
  chances that they will be consistent
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints IS NOT GUARANTEED.
* in the several special cases, however, we CAN guarantee consistency.
* one of this cases is constraints  on  the  function  values  AND/OR  its
  derivatives at the interval boundaries.
* another  special  case  is ONE constraint on the function value (OR, but
  not AND, derivative) anywhere in the interval

Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.


  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dfitcubicwc(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xc,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; yc,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; dc,
    <b>int</b> k,
    <b>int</b> m,
    <b>int</b>&amp; info,
    spline1dinterpolant&lt;Precision&gt;&amp; s,
    spline1dfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_fitc' class=nav>spline1d_fitc</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfithermite'></a><h3><code>spline1dfithermite</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Least squares fitting by Hermite spline.

This subroutine is &quot;lightweight&quot; alternative for more complex and feature-
rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
more information about subroutine parameters (we don't duplicate  it  here
because of length).

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dfithermite(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>int</b> n,
    <b>int</b> m,
    <b>int</b>&amp; info,
    spline1dinterpolant&lt;Precision&gt;&amp; s,
    spline1dfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_fit' class=nav>spline1d_fit</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dfithermitewc'></a><h3><code>spline1dfithermitewc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Weighted  fitting  by Hermite spline,  with constraints on function values
or first derivatives.

Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
basis functions. Basis functions are Hermite splines.  Small  regularizing
term is used when solving constrained tasks (to improve stability).

Task is linear, so linear least squares solver is used. Complexity of this
computational scheme is O(N*M^2), mostly dominated by least squares solver

SEE ALSO
    Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
                                more smooth)
    Spline1DFitHermite()    -   &quot;lightweight&quot; Hermite fitting, without
                                invididual weights and constraints

INPUT PARAMETERS:
    X   -   points, array[0..N-1].
    Y   -   function values, array[0..N-1].
    W   -   weights, array[0..N-1]
            Each summand in square  sum  of  approximation deviations from
            given  values  is  multiplied  by  the square of corresponding
            weight. Fill it by 1's if you don't  want  to  solve  weighted
            task.
    N   -   number of points, N&gt;0.
    XC  -   points where spline values/derivatives are constrained,
            array[0..K-1].
    YC  -   values of constraints, array[0..K-1]
    DC  -   array[0..K-1], types of constraints:
            * DC[i]=0   means that S(XC[i])=YC[i]
            * DC[i]=1   means that S'(XC[i])=YC[i]
            SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
    K   -   number of constraints, 0&lt;=K&lt;M.
            K=0 means no constraints (XC/YC/DC are not used in such cases)
    M   -   number of basis functions (= 2 * number of nodes),
            M&gt;=4,
            M IS EVEN!

OUTPUT PARAMETERS:
    Info-   same format as in LSFitLinearW() subroutine:
            * Info&gt;0    task is solved
            * Info&lt;=0   an error occured:
                        -4 means inconvergence of internal SVD
                        -3 means inconsistent constraints
                        -2 means odd M was passed (which is not supported)
                        -1 means another errors in parameters passed
                           (N&lt;=0, for example)
    S   -   spline interpolant.
    Rep -   report, same format as in LSFitLinearW() subroutine.
            Following fields are set:
            * RMSError      rms error on the (X,Y).
            * AvgError      average error on the (X,Y).
            * AvgRelError   average relative error on the non-zero Y
            * MaxError      maximum error
                            NON-WEIGHTED ERRORS ARE CALCULATED

IMPORTANT:
    this subroitine doesn't calculate task's condition number for K&lt;&gt;0.

IMPORTANT:
    this subroitine supports only even M's


ORDER OF POINTS

Subroutine automatically sorts points, so caller may pass unsorted array.

SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

Setting constraints can lead  to undesired  results,  like ill-conditioned
behavior, or inconsistency being detected. From the other side,  it allows
us to improve quality of the fit. Here we summarize  our  experience  with
constrained regression splines:
* excessive constraints can be inconsistent. Splines are  piecewise  cubic
  functions, and it is easy to create an example, where  large  number  of
  constraints  concentrated  in  small  area will result in inconsistency.
  Just because spline is not flexible enough to satisfy all of  them.  And
  same constraints spread across the  [min(x),max(x)]  will  be  perfectly
  consistent.
* the more evenly constraints are spread across [min(x),max(x)],  the more
  chances that they will be consistent
* the  greater  is  M (given  fixed  constraints),  the  more chances that
  constraints will be consistent
* in the general case, consistency of constraints is NOT GUARANTEED.
* in the several special cases, however, we can guarantee consistency.
* one of this cases is  M&gt;=4  and   constraints  on   the  function  value
  (AND/OR its derivative) at the interval boundaries.
* another special case is M&gt;=4  and  ONE  constraint on the function value
  (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]

Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
can't solve your task without them. Anything beyond  special  cases  given
above is not guaranteed and may result in inconsistency.

  -- ALGLIB PROJECT --
     Copyright 18.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dfithermitewc(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; y,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    <b>int</b> n,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; xc,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; yc,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; dc,
    <b>int</b> k,
    <b>int</b> m,
    <b>int</b>&amp; info,
    spline1dinterpolant&lt;Precision&gt;&amp; s,
    spline1dfitreport&lt;Precision&gt;&amp; rep);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_fitc' class=nav>spline1d_fitc</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dintegrate'></a><h3><code>spline1dintegrate</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine integrates the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    X   -   right bound of the integration interval [a, x],
            here 'a' denotes min(x[])
Result:
    integral(S(t)dt,a,x)

  -- ALGLIB PROJECT --
     Copyright 23.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spline1dintegrate(<b>const</b> spline1dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; x);
</div></pre>
<p align=left><span class=inlineheader>Examples:</span>&nbsp;&nbsp;&nbsp;<a href='#example_spline1d_calc' class=nav>spline1d_calc</a>&nbsp;&nbsp;</p>
<a name='sub_spline1dlintransx'></a><h3><code>spline1dlintransx</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline argument.

INPUT PARAMETERS:
    C   -   spline interpolant.
    A, B-   transformation coefficients: x = A*t + B
Result:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dlintransx(spline1dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b);
</div></pre>
<a name='sub_spline1dlintransy'></a><h3><code>spline1dlintransy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline.

INPUT PARAMETERS:
    C   -   spline interpolant.
    A, B-   transformation coefficients: S2(x) = A*S(x) + B
Result:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dlintransy(spline1dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b);
</div></pre>
<a name='sub_spline1dunpack'></a><h3><code>spline1dunpack</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine unpacks the spline into the coefficients table.

INPUT PARAMETERS:
    C   -   spline interpolant.
    X   -   point

Result:
    Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
            For I = 0...N-2:
                Tbl[I,0] = X[i]
                Tbl[I,1] = X[i+1]
                Tbl[I,2] = C0
                Tbl[I,3] = C1
                Tbl[I,4] = C2
                Tbl[I,5] = C3
            On [x[i], x[i+1]] spline is equals to:
                S(x) = C0 + C1*t + C2*t^2 + C3*t^3
                t = x-x[i]

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline1dunpack(<b>const</b> spline1dinterpolant&lt;Precision&gt;&amp; c,
    <b>int</b>&amp; n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tbl);
</div></pre>
<a name='example_spline1d_calc'></a><h3>spline1d_calc example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    spline1d::spline1dinterpolant&lt;Precision&gt; s;
    amp::ampf&lt;Precision&gt; v;
    amp::ampf&lt;Precision&gt; dv;
    amp::ampf&lt;Precision&gt; d2v;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Demonstration of Spline1DCalc(), Spline1DDiff(), Spline1DIntegrate()</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;DEMONSTRATION OF Spline1DCalc(), Spline1DDiff(), Spline1DIntegrate()\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi]\n&quot;</font>);
    printf(<font color=blue>&quot;Natural cubic spline with 3 nodes is used\n\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create spline</font>
<font color=navy>    //</font>
    n = 3;
    x.setlength(n);
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
    }
    spline1d::spline1dbuildcubic&lt;Precision&gt;(x, y, n, 2, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), 2, amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.0&quot;</font>), s);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    spline1d::spline1ddiff&lt;Precision&gt;(s, amp::ampf&lt;Precision&gt;(0), v, dv, d2v);
    printf(<font color=blue>&quot;                 S(x)    F(x) \n&quot;</font>);
    printf(<font color=blue>&quot;function       %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::ampf&lt;Precision&gt;(0))).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;d/dx(0)        %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(dv).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(1).toDouble()));
    printf(<font color=blue>&quot;d2/dx2(0)      %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(d2v).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(0).toDouble()));
    printf(<font color=blue>&quot;integral(0,pi) %6.3lf  %6.3lf \n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dintegrate&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(2).toDouble()));
    printf(<font color=blue>&quot;\n\n&quot;</font>);

</pre><a name='example_spline1d_cubic'></a><h3>spline1d_cubic example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    spline1d::spline1dinterpolant&lt;Precision&gt; s;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Interpolation by natural Cubic spline.</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;INTERPOLATION BY NATURAL CUBIC SPLINE\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi], 3 nodes\n\n&quot;</font>);
    printf(<font color=blue>&quot;     x   F(x)   S(x)  Error\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create spline</font>
<font color=navy>    //</font>
    n = 3;
    x.setlength(n);
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
    }
    spline1d::spline1dbuildcubic&lt;Precision&gt;(x, y, n, 1, amp::ampf&lt;Precision&gt;(+1), 1, amp::ampf&lt;Precision&gt;(-1), s);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    t = 0;
    maxerr = 0;
    <b>while</b>( t&lt;amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.999999&quot;</font>)*amp::pi&lt;Precision&gt;() )
    {
        err = amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t));
        maxerr = amp::maximum&lt;Precision&gt;(err, maxerr);
        printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(err).toDouble()));
        t = amp::minimum&lt;Precision&gt;(amp::pi&lt;Precision&gt;(), t+amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.25&quot;</font>));
    }
    err = amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())-amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;()));
    maxerr = amp::maximum&lt;Precision&gt;(err, maxerr);
    printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::pi&lt;Precision&gt;()).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(err).toDouble()));
    printf(<font color=blue>&quot;max|error| = %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(maxerr).toDouble()));
    printf(<font color=blue>&quot;Try other demos (spline1d_linear, spline1d_hermite) and compare errors...\n\n\n&quot;</font>);

</pre><a name='example_spline1d_fit'></a><h3>spline1d_fit example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    <b>int</b> info;
    spline1d::spline1dinterpolant&lt;Precision&gt; s;
    amp::ampf&lt;Precision&gt; t;
    spline1d::spline1dfitreport&lt;Precision&gt; rep;


    
<font color=navy>    //</font>
<font color=navy>    // Fitting by unconstrained natural cubic spline</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;FITTING BY UNCONSTRAINED NATURAL CUBIC SPLINE\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x)      function being fitted\n&quot;</font>);
    printf(<font color=blue>&quot;[0, pi]          interval\n&quot;</font>);
    printf(<font color=blue>&quot;M=4              number of basis functions to use\n&quot;</font>);
    printf(<font color=blue>&quot;N=100            number of points to fit\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create and fit</font>
<font color=navy>    //</font>
    n = 100;
    x.setlength(n);
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
    }
    spline1d::spline1dfitcubic&lt;Precision&gt;(x, y, n, 4, info, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    <b>if</b>( info&gt;0 )
    {
        printf(<font color=blue>&quot;\nOK, we have finished\n\n&quot;</font>);
        printf(<font color=blue>&quot;     x   F(x)   S(x)  Error\n&quot;</font>);
        t = 0;
        <b>while</b>( t&lt;amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.999999&quot;</font>)*amp::pi&lt;Precision&gt;() )
        {
            printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t))).toDouble()));
            t = amp::minimum&lt;Precision&gt;(amp::pi&lt;Precision&gt;(), t+amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.25&quot;</font>));
        }
        printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t))).toDouble()));
        printf(<font color=blue>&quot;rms error is %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()));
        printf(<font color=blue>&quot;max error is %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()));
    }
    else
    {
        printf(<font color=blue>&quot;\nSomething wrong, Info=%0ld&quot;</font>,
            <b>long</b>(info));
    }

</pre><a name='example_spline1d_fitc'></a><h3>spline1d_fitc example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; w;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; xc;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; yc;
    ap::template_1d_array&lt; <b>int</b> &gt; dc;
    <b>int</b> n;
    <b>int</b> i;
    <b>int</b> info;
    spline1d::spline1dinterpolant&lt;Precision&gt; s;
    amp::ampf&lt;Precision&gt; t;
    spline1d::spline1dfitreport&lt;Precision&gt; rep;


    
<font color=navy>    //</font>
<font color=navy>    // Fitting by constrained Hermite spline</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;FITTING BY CONSTRAINED HERMITE SPLINE\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x)      function being fitted\n&quot;</font>);
    printf(<font color=blue>&quot;[0, pi]          interval\n&quot;</font>);
    printf(<font color=blue>&quot;M=6              number of basis functions to use\n&quot;</font>);
    printf(<font color=blue>&quot;S(0)=0           first constraint\n&quot;</font>);
    printf(<font color=blue>&quot;S(pi)=0          second constraint\n&quot;</font>);
    printf(<font color=blue>&quot;N=100            number of points to fit\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create and fit:</font>
<font color=navy>    // * X  contains points</font>
<font color=navy>    // * Y  contains values</font>
<font color=navy>    // * W  contains weights</font>
<font color=navy>    // * XC contains constraints locations</font>
<font color=navy>    // * YC contains constraints values</font>
<font color=navy>    // * DC contains derivative indexes (0 = constrained function value)</font>
<font color=navy>    //</font>
    n = 100;
    x.setlength(n);
    y.setlength(n);
    w.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
        w(i) = 1;
    }
    xc.setlength(2);
    yc.setlength(2);
    dc.setlength(2);
    xc(0) = 0;
    yc(0) = 0;
    dc(0) = 0;
    xc(0) = amp::pi&lt;Precision&gt;();
    yc(0) = 0;
    dc(0) = 0;
    spline1d::spline1dfithermitewc&lt;Precision&gt;(x, y, w, n, xc, yc, dc, 2, 6, info, s, rep);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    <b>if</b>( info&gt;0 )
    {
        printf(<font color=blue>&quot;\nOK, we have finished\n\n&quot;</font>);
        printf(<font color=blue>&quot;     x   F(x)   S(x)  Error\n&quot;</font>);
        t = 0;
        <b>while</b>( t&lt;amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.999999&quot;</font>)*amp::pi&lt;Precision&gt;() )
        {
            printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n&quot;</font>,
                <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
                <b>double</b>(amp::ampf&lt;Precision&gt;(amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t))).toDouble()));
            t = amp::minimum&lt;Precision&gt;(amp::pi&lt;Precision&gt;(), t+amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.25&quot;</font>));
        }
        printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t))).toDouble()));
        printf(<font color=blue>&quot;rms error is %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(rep.rmserror).toDouble()));
        printf(<font color=blue>&quot;max error is %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(rep.maxerror).toDouble()));
        printf(<font color=blue>&quot;S(0) = S(pi) = 0 (exactly)\n\n&quot;</font>);
    }
    else
    {
        printf(<font color=blue>&quot;\nSomething wrong, Info=%0ld&quot;</font>,
            <b>long</b>(info));
    }

</pre><a name='example_spline1d_hermite'></a><h3>spline1d_hermite example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; d;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    spline1d::spline1dinterpolant&lt;Precision&gt; s;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Interpolation by natural Cubic spline.</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;INTERPOLATION BY HERMITE SPLINE\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi], 3 nodes\n\n&quot;</font>);
    printf(<font color=blue>&quot;     x   F(x)   S(x)  Error\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create spline</font>
<font color=navy>    //</font>
    n = 3;
    x.setlength(n);
    y.setlength(n);
    d.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
        d(i) = amp::cos&lt;Precision&gt;(x(i));
    }
    spline1d::spline1dbuildhermite&lt;Precision&gt;(x, y, d, n, s);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    t = 0;
    maxerr = 0;
    <b>while</b>( t&lt;amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.999999&quot;</font>)*amp::pi&lt;Precision&gt;() )
    {
        err = amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t));
        maxerr = amp::maximum&lt;Precision&gt;(err, maxerr);
        printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(err).toDouble()));
        t = amp::minimum&lt;Precision&gt;(amp::pi&lt;Precision&gt;(), t+amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.25&quot;</font>));
    }
    err = amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())-amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;()));
    maxerr = amp::maximum&lt;Precision&gt;(err, maxerr);
    printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::pi&lt;Precision&gt;()).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(err).toDouble()));
    printf(<font color=blue>&quot;max|error| = %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(maxerr).toDouble()));
    printf(<font color=blue>&quot;Try other demos (spline1d_linear, spline1d_cubic) and compare errors...\n\n\n&quot;</font>);

</pre><a name='example_spline1d_linear'></a><h3>spline1d_linear example</h3>
<pre>
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y;
    <b>int</b> n;
    <b>int</b> i;
    amp::ampf&lt;Precision&gt; t;
    spline1d::spline1dinterpolant&lt;Precision&gt; s;
    amp::ampf&lt;Precision&gt; err;
    amp::ampf&lt;Precision&gt; maxerr;


    
<font color=navy>    //</font>
<font color=navy>    // Interpolation by linear spline.</font>
<font color=navy>    //</font>
    printf(<font color=blue>&quot;INTERPOLATION BY LINEAR SPLINE\n\n&quot;</font>);
    printf(<font color=blue>&quot;F(x)=sin(x), [0, pi], 3 nodes\n\n&quot;</font>);
    printf(<font color=blue>&quot;     x   F(x)   S(x)  Error\n&quot;</font>);
    
<font color=navy>    //</font>
<font color=navy>    // Create spline</font>
<font color=navy>    //</font>
    n = 3;
    x.setlength(n);
    y.setlength(n);
    <b>for</b>(i=0; i&lt;=n-1; i++)
    {
        x(i) = amp::pi&lt;Precision&gt;()*i/(n-1);
        y(i) = amp::sin&lt;Precision&gt;(x(i));
    }
    spline1d::spline1dbuildlinear&lt;Precision&gt;(x, y, n, s);
    
<font color=navy>    //</font>
<font color=navy>    // Output results</font>
<font color=navy>    //</font>
    t = 0;
    maxerr = 0;
    <b>while</b>( t&lt;amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.999999&quot;</font>)*amp::pi&lt;Precision&gt;() )
    {
        err = amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)-amp::sin&lt;Precision&gt;(t));
        maxerr = amp::maximum&lt;Precision&gt;(err, maxerr);
        printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n&quot;</font>,
            <b>double</b>(amp::ampf&lt;Precision&gt;(t).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, t)).toDouble()),
            <b>double</b>(amp::ampf&lt;Precision&gt;(err).toDouble()));
        t = amp::minimum&lt;Precision&gt;(amp::pi&lt;Precision&gt;(), t+amp::ampf&lt;Precision&gt;(<font color=blue>&quot;0.25&quot;</font>));
    }
    err = amp::abs&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())-amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;()));
    maxerr = amp::maximum&lt;Precision&gt;(err, maxerr);
    printf(<font color=blue>&quot;%6.3lf %6.3lf %6.3lf %6.3lf\n\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::pi&lt;Precision&gt;()).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(amp::sin&lt;Precision&gt;(amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(spline1d::spline1dcalc&lt;Precision&gt;(s, amp::pi&lt;Precision&gt;())).toDouble()),
        <b>double</b>(amp::ampf&lt;Precision&gt;(err).toDouble()));
    printf(<font color=blue>&quot;max|error| = %0.3lf\n&quot;</font>,
        <b>double</b>(amp::ampf&lt;Precision&gt;(maxerr).toDouble()));
    printf(<font color=blue>&quot;Try other demos (spline1d_hermite, spline1d_cubic) and compare errors...\n\n\n&quot;</font>);

</pre><a name=unit_spline2d></a><h2><code>spline2d</code> unit</h2>
<h3>Structures</h3>
<a href='#struct_spline2dinterpolant' class=toc>spline2dinterpolant</a><br>
<h3>Functions</h3>
<a href='#sub_spline2dbuildbicubic' class=toc>spline2dbuildbicubic</a><br>
<a href='#sub_spline2dbuildbilinear' class=toc>spline2dbuildbilinear</a><br>
<a href='#sub_spline2dcalc' class=toc>spline2dcalc</a><br>
<a href='#sub_spline2dcopy' class=toc>spline2dcopy</a><br>
<a href='#sub_spline2ddiff' class=toc>spline2ddiff</a><br>
<a href='#sub_spline2dlintransf' class=toc>spline2dlintransf</a><br>
<a href='#sub_spline2dlintransxy' class=toc>spline2dlintransxy</a><br>
<a href='#sub_spline2dresamplebicubic' class=toc>spline2dresamplebicubic</a><br>
<a href='#sub_spline2dresamplebilinear' class=toc>spline2dresamplebilinear</a><br>
<a href='#sub_spline2dserialize' class=toc>spline2dserialize</a><br>
<a href='#sub_spline2dunpack' class=toc>spline2dunpack</a><br>
<a href='#sub_spline2dunserialize' class=toc>spline2dunserialize</a><br>
<a name='struct_spline2dinterpolant'></a><h3><code>spline2dinterpolant</code> structure</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
2-dimensional spline inteprolant
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>class</b> spline2dinterpolant
{
<b>public</b>:
    <b>int</b> k;
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; c;
};
</div></pre>
<a name='sub_spline2dbuildbicubic'></a><h3><code>spline2dbuildbicubic</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds bicubic spline coefficients table.

Input parameters:
    X   -   spline abscissas, array[0..N-1]
    Y   -   spline ordinates, array[0..M-1]
    F   -   function values, array[0..M-1,0..N-1]
    M,N -   grid size, M&gt;=2, N&gt;=2

Output parameters:
    C   -   spline interpolant

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dbuildbicubic(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; f,
    <b>int</b> m,
    <b>int</b> n,
    spline2dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<a name='sub_spline2dbuildbilinear'></a><h3><code>spline2dbuildbilinear</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine builds bilinear spline coefficients table.

Input parameters:
    X   -   spline abscissas, array[0..N-1]
    Y   -   spline ordinates, array[0..M-1]
    F   -   function values, array[0..M-1,0..N-1]
    M,N -   grid size, M&gt;=2, N&gt;=2

Output parameters:
    C   -   spline interpolant

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dbuildbilinear(ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; x,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; y,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; f,
    <b>int</b> m,
    <b>int</b> n,
    spline2dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<a name='sub_spline2dcalc'></a><h3><code>spline2dcalc</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the bilinear or bicubic spline  at
the given point X.

Input parameters:
    C   -   coefficients table.
            Built by BuildBilinearSpline or BuildBicubicSpline.
    X, Y-   point

Result:
    S(x,y)

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; spline2dcalc(<b>const</b> spline2dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; x,
    amp::ampf&lt;Precision&gt; y);
</div></pre>
<a name='sub_spline2dcopy'></a><h3><code>spline2dcopy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine makes the copy of the spline model.

Input parameters:
    C   -   spline interpolant

Output parameters:
    CC  -   spline copy

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dcopy(<b>const</b> spline2dinterpolant&lt;Precision&gt;&amp; c,
    spline2dinterpolant&lt;Precision&gt;&amp; cc);
</div></pre>
<a name='sub_spline2ddiff'></a><h3><code>spline2ddiff</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine calculates the value of the bilinear or bicubic spline  at
the given point X and its derivatives.

Input parameters:
    C   -   spline interpolant.
    X, Y-   point

Output parameters:
    F   -   S(x,y)
    FX  -   dS(x,y)/dX
    FY  -   dS(x,y)/dY
    FXY -   d2S(x,y)/dXdY

  -- ALGLIB PROJECT --
     Copyright 05.07.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2ddiff(<b>const</b> spline2dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; x,
    amp::ampf&lt;Precision&gt; y,
    amp::ampf&lt;Precision&gt;&amp; f,
    amp::ampf&lt;Precision&gt;&amp; fx,
    amp::ampf&lt;Precision&gt;&amp; fy,
    amp::ampf&lt;Precision&gt;&amp; fxy);
</div></pre>
<a name='sub_spline2dlintransf'></a><h3><code>spline2dlintransf</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline.

Input parameters:
    C   -   spline interpolant.
    A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
    
Output parameters:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dlintransf(spline2dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; a,
    amp::ampf&lt;Precision&gt; b);
</div></pre>
<a name='sub_spline2dlintransxy'></a><h3><code>spline2dlintransxy</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine performs linear transformation of the spline argument.

Input parameters:
    C       -   spline interpolant
    AX, BX  -   transformation coefficients: x = A*t + B
    AY, BY  -   transformation coefficients: y = A*u + B
Result:
    C   -   transformed spline

  -- ALGLIB PROJECT --
     Copyright 30.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dlintransxy(spline2dinterpolant&lt;Precision&gt;&amp; c,
    amp::ampf&lt;Precision&gt; ax,
    amp::ampf&lt;Precision&gt; bx,
    amp::ampf&lt;Precision&gt; ay,
    amp::ampf&lt;Precision&gt; by);
</div></pre>
<a name='sub_spline2dresamplebicubic'></a><h3><code>spline2dresamplebicubic</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bicubic spline resampling

Input parameters:
    A           -   function values at the old grid,
                    array[0..OldHeight-1, 0..OldWidth-1]
    OldHeight   -   old grid height, OldHeight&gt;1
    OldWidth    -   old grid width, OldWidth&gt;1
    NewHeight   -   new grid height, NewHeight&gt;1
    NewWidth    -   new grid width, NewWidth&gt;1
    
Output parameters:
    B           -   function values at the new grid,
                    array[0..NewHeight-1, 0..NewWidth-1]

  -- ALGLIB routine --
     15 May, 2007
     Copyright by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dresamplebicubic(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> oldheight,
    <b>int</b> oldwidth,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> newheight,
    <b>int</b> newwidth);
</div></pre>
<a name='sub_spline2dresamplebilinear'></a><h3><code>spline2dresamplebilinear</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Bilinear spline resampling

Input parameters:
    A           -   function values at the old grid,
                    array[0..OldHeight-1, 0..OldWidth-1]
    OldHeight   -   old grid height, OldHeight&gt;1
    OldWidth    -   old grid width, OldWidth&gt;1
    NewHeight   -   new grid height, NewHeight&gt;1
    NewWidth    -   new grid width, NewWidth&gt;1

Output parameters:
    B           -   function values at the new grid,
                    array[0..NewHeight-1, 0..NewWidth-1]

  -- ALGLIB routine --
     09.07.2007
     Copyright by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dresamplebilinear(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> oldheight,
    <b>int</b> oldwidth,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> newheight,
    <b>int</b> newwidth);
</div></pre>
<a name='sub_spline2dserialize'></a><h3><code>spline2dserialize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Serialization of the spline interpolant

INPUT PARAMETERS:
    B   -   spline interpolant

OUTPUT PARAMETERS:
    RA      -   array of real numbers which contains interpolant,
                array[0..RLen-1]
    RLen    -   RA lenght

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dserialize(<b>const</b> spline2dinterpolant&lt;Precision&gt;&amp; c,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; ra,
    <b>int</b>&amp; ralen);
</div></pre>
<a name='sub_spline2dunpack'></a><h3><code>spline2dunpack</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
This subroutine unpacks two-dimensional spline into the coefficients table

Input parameters:
    C   -   spline interpolant.

Result:
    M, N-   grid size (x-axis and y-axis)
    Tbl -   coefficients table, unpacked format,
            [0..(N-1)*(M-1)-1, 0..19].
            For I = 0...M-2, J=0..N-2:
                K =  I*(N-1)+J
                Tbl[K,0] = X[j]
                Tbl[K,1] = X[j+1]
                Tbl[K,2] = Y[i]
                Tbl[K,3] = Y[i+1]
                Tbl[K,4] = C00
                Tbl[K,5] = C01
                Tbl[K,6] = C02
                Tbl[K,7] = C03
                Tbl[K,8] = C10
                Tbl[K,9] = C11
                ...
                Tbl[K,19] = C33
            On each grid square spline is equals to:
                S(x) = SUM(c[i,j]*(x^i)*(y^j), i=0..3, j=0..3)
                t = x-x[j]
                u = y-y[i]

  -- ALGLIB PROJECT --
     Copyright 29.06.2007 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dunpack(<b>const</b> spline2dinterpolant&lt;Precision&gt;&amp; c,
    <b>int</b>&amp; m,
    <b>int</b>&amp; n,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; tbl);
</div></pre>
<a name='sub_spline2dunserialize'></a><h3><code>spline2dunserialize</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Unserialization of the spline interpolant

INPUT PARAMETERS:
    RA  -   array of real numbers which contains interpolant,

OUTPUT PARAMETERS:
    B   -   spline interpolant

  -- ALGLIB --
     Copyright 17.08.2009 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> spline2dunserialize(<b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; ra,
    spline2dinterpolant&lt;Precision&gt;&amp; c);
</div></pre>
<a name=unit_srcond></a><h2><code>srcond</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_smatrixldltrcond' class=toc>smatrixldltrcond</a><br>
<a href='#sub_smatrixrcond' class=toc>smatrixrcond</a><br>
<a name='sub_smatrixldltrcond'></a><h3><code>smatrixldltrcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a matrix given by LDLT-decomposition

The algorithm calculates a lower bound of the condition number. In this
case, the algorithm does not return a lower bound of the condition number,
but an inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    L       -   LDLT-decomposition of matrix A given by the upper or lower
                triangle depending on IsUpper.
                Output of SMatrixLDLT subroutine.
    Pivots  -   table of permutations which were made during LDLT-decomposition,
                Output of SMatrixLDLT subroutine.
    N       -   size of matrix A.
    IsUpper -   storage format.

Result:
    1/LowerBound(cond(A))
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; smatrixldltrcond(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; l,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name='sub_smatrixrcond'></a><h3><code>smatrixrcond</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Condition number estimate of a symmetric matrix

The algorithm calculates a lower bound of the condition number. In this
case, the algorithm does not return a lower bound of the condition number,
but an inverse number (to avoid an overflow in case of a singular matrix).

It should be noted that 1-norm and inf-norm condition numbers of symmetric
matrices are equal, so the algorithm doesn't take into account the
differences between these types of norms.

Input parameters:
    A       -   symmetric definite matrix which is given by its upper or
                lower triangle depending on IsUpper.
                Array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   storage format.

Result:
    1/LowerBound(cond(A))
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
amp::ampf&lt;Precision&gt; smatrixrcond(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name=unit_ssolve></a><h2><code>ssolve</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_smatrixldltsolve' class=toc>smatrixldltsolve</a><br>
<a href='#sub_smatrixsolve' class=toc>smatrixsolve</a><br>
<a name='sub_smatrixldltsolve'></a><h3><code>smatrixldltsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Solving  a system  of linear equations  with a system matrix  given by its
LDLT decomposition

The algorithm solves systems with a square matrix only.

Input parameters:
    A       -   LDLT decomposition of the matrix (the result of the
                SMatrixLDLT subroutine).
    Pivots  -   row permutation table (the result of the SMatrixLDLT subroutine).
    B       -   right side of a system.
                Array whose index ranges within [0..N-1].
    N       -   size of matrix A.
    IsUpper -   points to the triangle of matrix A in which the LDLT
                decomposition is stored.
                If IsUpper=True, the decomposition has the form of U*D*U',
                matrix U is stored in the upper triangle of  matrix A  (in
                that case, the lower triangle isn't used and isn't changed
                by the subroutine).
                Similarly, if IsUpper=False, the decomposition has the form
                of L*D*L' and the lower triangle stores matrix L.

Output parameters:
    X       -   solution of a system.
                Array whose index ranges within [0..N-1].

Result:
    True, if the matrix is not singular. X contains the solution.
    False, if the matrix is singular (the determinant of matrix D is equal
to 0). In this case, X doesn't contain a solution.
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixldltsolve(<b>const</b> ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>const</b> ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt; b,
    <b>int</b> n,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name='sub_smatrixsolve'></a><h3><code>smatrixsolve</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Solving a system of linear equations with a symmetric system matrix

Input parameters:
    A       -   system matrix (upper or lower triangle).
                Array whose indexes range within [0..N-1, 0..N-1].
    B       -   right side of a system.
                Array whose index ranges within [0..N-1].
    N       -   size of matrix A.
    IsUpper -   If IsUpper = True, A contains the upper triangle,
                otherwise A contains the lower triangle.

Output parameters:
    X       -   solution of a system.
                Array whose index ranges within [0..N-1].

Result:
    True, if the matrix is not singular. X contains the solution.
    False, if the matrix is singular (the determinant of the matrix is equal
to 0). In this case, X doesn't contain a solution.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> smatrixsolve(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>const</b> ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; b,
    <b>int</b> n,
    <b>bool</b> isupper,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; x);
</div></pre>
<a name=unit_svd></a><h2><code>svd</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_rmatrixsvd' class=toc>rmatrixsvd</a><br>
<a name='sub_rmatrixsvd'></a><h3><code>rmatrixsvd</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Singular value decomposition of a rectangular matrix.

The algorithm calculates the singular value decomposition of a matrix of
size MxN: A = U * S * V^T

The algorithm finds the singular values and, optionally, matrices U and V^T.
The algorithm can find both first min(M,N) columns of matrix U and rows of
matrix V^T (singular vectors), and matrices U and V^T wholly (of sizes MxM
and NxN respectively).

Take into account that the subroutine does not return matrix V but V^T.

Input parameters:
    A           -   matrix to be decomposed.
                    Array whose indexes range within [0..M-1, 0..N-1].
    M           -   number of rows in matrix A.
    N           -   number of columns in matrix A.
    UNeeded     -   0, 1 or 2. See the description of the parameter U.
    VTNeeded    -   0, 1 or 2. See the description of the parameter VT.
    AdditionalMemory -
                    If the parameter:
                     * equals 0, the algorithm doesnt use additional
                       memory (lower requirements, lower performance).
                     * equals 1, the algorithm uses additional
                       memory of size min(M,N)*min(M,N) of real numbers.
                       It often speeds up the algorithm.
                     * equals 2, the algorithm uses additional
                       memory of size M*min(M,N) of real numbers.
                       It allows to get a maximum performance.
                    The recommended value of the parameter is 2.

Output parameters:
    W           -   contains singular values in descending order.
    U           -   if UNeeded=0, U isn't changed, the left singular vectors
                    are not calculated.
                    if Uneeded=1, U contains left singular vectors (first
                    min(M,N) columns of matrix U). Array whose indexes range
                    within [0..M-1, 0..Min(M,N)-1].
                    if UNeeded=2, U contains matrix U wholly. Array whose
                    indexes range within [0..M-1, 0..M-1].
    VT          -   if VTNeeded=0, VT isnt changed, the right singular vectors
                    are not calculated.
                    if VTNeeded=1, VT contains right singular vectors (first
                    min(M,N) rows of matrix V^T). Array whose indexes range
                    within [0..min(M,N)-1, 0..N-1].
                    if VTNeeded=2, VT contains matrix V^T wholly. Array whose
                    indexes range within [0..N-1, 0..N-1].

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> rmatrixsvd(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt; a,
    <b>int</b> m,
    <b>int</b> n,
    <b>int</b> uneeded,
    <b>int</b> vtneeded,
    <b>int</b> additionalmemory,
    ap::template_1d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; w,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; u,
    ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; vt);
</div></pre>
<a name=unit_trfac></a><h2><code>trfac</code> unit</h2>
<h3>Functions</h3>
<a href='#sub_cmatrixlu' class=toc>cmatrixlu</a><br>
<a href='#sub_hpdmatrixcholesky' class=toc>hpdmatrixcholesky</a><br>
<a href='#sub_rmatrixlu' class=toc>rmatrixlu</a><br>
<a href='#sub_spdmatrixcholesky' class=toc>spdmatrixcholesky</a><br>
<a name='sub_cmatrixlu'></a><h3><code>cmatrixlu</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LU decomposition of a general complex matrix with row pivoting

A is represented as A = P*L*U, where:
* L is lower unitriangular matrix
* U is upper triangular matrix
* P = P0*P1*...*PK, K=min(M,N)-1,
  Pi - permutation matrix for I and Pivots[I]

This is cache-oblivous implementation of LU decomposition. It is optimized
for square matrices. As for rectangular matrices:
* best case - M&gt;&gt;N
* worst case - N&gt;&gt;M, small M, large N, matrix does not fit in CPU cache

INPUT PARAMETERS:
    A       -   array[0..M-1, 0..N-1].
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.


OUTPUT PARAMETERS:
    A       -   matrices L and U in compact form:
                * L is stored under main diagonal
                * U is stored on and above main diagonal
    Pivots  -   permutation matrix in compact form.
                array[0..Min(M-1,N-1)].

  -- ALGLIB routine --
     10.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> cmatrixlu(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots);
</div></pre>
<a name='sub_hpdmatrixcholesky'></a><h3><code>hpdmatrixcholesky</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivious Cholesky decomposition

The algorithm computes Cholesky decomposition  of  a  Hermitian  positive-
definite matrix. The result of an algorithm is a representation  of  A  as
A=U'*U  or A=L*L' (here X' detones conj(X^T)).

INPUT PARAMETERS:
    A       -   upper or lower triangle of a factorized matrix.
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   if IsUpper=True, then A contains an upper triangle of
                a symmetric matrix, otherwise A contains a lower one.

OUTPUT PARAMETERS:
    A       -   the result of factorization. If IsUpper=True, then
                the upper triangle contains matrix U, so that A = U'*U,
                and the elements below the main diagonal are not modified.
                Similarly, if IsUpper = False.

RESULT:
    If  the  matrix  is  positive-definite,  the  function  returns  True.
    Otherwise, the function returns False. Contents of A is not determined
    in such case.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> hpdmatrixcholesky(ap::template_2d_array&lt; amp::campf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>
<a name='sub_rmatrixlu'></a><h3><code>rmatrixlu</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
LU decomposition of a general real matrix with row pivoting

A is represented as A = P*L*U, where:
* L is lower unitriangular matrix
* U is upper triangular matrix
* P = P0*P1*...*PK, K=min(M,N)-1,
  Pi - permutation matrix for I and Pivots[I]

This is cache-oblivous implementation of LU decomposition.
It is optimized for square matrices. As for rectangular matrices:
* best case - M&gt;&gt;N
* worst case - N&gt;&gt;M, small M, large N, matrix does not fit in CPU cache

INPUT PARAMETERS:
    A       -   array[0..M-1, 0..N-1].
    M       -   number of rows in matrix A.
    N       -   number of columns in matrix A.


OUTPUT PARAMETERS:
    A       -   matrices L and U in compact form:
                * L is stored under main diagonal
                * U is stored on and above main diagonal
    Pivots  -   permutation matrix in compact form.
                array[0..Min(M-1,N-1)].

  -- ALGLIB routine --
     10.01.2010
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>void</b> rmatrixlu(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> m,
    <b>int</b> n,
    ap::template_1d_array&lt; <b>int</b> &gt;&amp; pivots);
</div></pre>
<a name='sub_spdmatrixcholesky'></a><h3><code>spdmatrixcholesky</code> function</h3>
<pre>
<div style='color: navy; margin-top: 0; margin-bottom: 0;'>/*************************************************************************
Cache-oblivious Cholesky decomposition

The algorithm computes Cholesky decomposition  of  a  symmetric  positive-
definite matrix. The result of an algorithm is a representation  of  A  as
A=U^T*U  or A=L*L^T

INPUT PARAMETERS:
    A       -   upper or lower triangle of a factorized matrix.
                array with elements [0..N-1, 0..N-1].
    N       -   size of matrix A.
    IsUpper -   if IsUpper=True, then A contains an upper triangle of
                a symmetric matrix, otherwise A contains a lower one.

OUTPUT PARAMETERS:
    A       -   the result of factorization. If IsUpper=True, then
                the upper triangle contains matrix U, so that A = U^T*U,
                and the elements below the main diagonal are not modified.
                Similarly, if IsUpper = False.

RESULT:
    If  the  matrix  is  positive-definite,  the  function  returns  True.
    Otherwise, the function returns False. Contents of A is not determined
    in such case.

  -- ALGLIB routine --
     15.12.2009
     Bochkanov Sergey
*************************************************************************/
</div><div style='margin-top: 0; margin-bottom: 0;'><b>template</b>&lt;unsigned <b>int</b> Precision&gt;
<b>bool</b> spdmatrixcholesky(ap::template_2d_array&lt; amp::ampf&lt;Precision&gt; &gt;&amp; a,
    <b>int</b> n,
    <b>bool</b> isupper);
</div></pre>



</div>
</body>
</html>